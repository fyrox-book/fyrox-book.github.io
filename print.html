<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fyrox Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fyrox-game-engine-book"><a class="header" href="#fyrox-game-engine-book">Fyrox Game Engine Book</a></h1>
<p>Practical reference and user guides for <a href="https://github.com/FyroxEngine/Fyrox">Fyrox Game Engine</a> and its editor <a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">FyroxEd</a>.</p>
<blockquote>
<p>⚠️ Tip: If you want to start using the engine as fast as possible - read this <a href="./beginning/scripting.html">chapter</a>.</p>
</blockquote>
<h2 id="engine-version"><a class="header" href="#engine-version">Engine Version</a></h2>
<p>Fyrox Team is trying to keep the book up-to-date with the latest version from <code>master</code> branch. If something does not
compile with the latest release from crates.io, then you need to
<a href="./beginning/manual_installation.html#using-the-latest-engine-version">use the latest engine from GitHub repo</a>.</p>
<h2 id="how-to-read-the-book"><a class="header" href="#how-to-read-the-book">How to read the book</a></h2>
<p>Almost every chapter in this book can be read in any order, but we recommend reading Chapters 1, 2, 3 (they're quite small)
and then going through <a href="./tutorials/platformer/part1.html">Platformer Tutorial (2D)</a> while learning more about specific
areas that interest you from the other chapters. There is also a <a href="tutorials/fps/tutorial-1/fps-tutorial.html">First-Person Shooter Tutorial (3D)</a>
and <a href="./tutorials/rpg/intro.html">RPG Tutorial (3D)</a>.</p>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>The book is primarily focused on game development with Fyrox, not on its API. You can find API docs
<a href="https://docs.rs/fyrox/latest/fyrox/">here</a>.</p>
<h2 id="required-knowledge"><a class="header" href="#required-knowledge">Required knowledge</a></h2>
<p>We're expecting that you know the basics of Rust programming language, its package manager Cargo. It is also necessary
to know the <em>basics</em> of game development, linear algebra, principles of software development and patterns,
otherwise the book will probably be quite hard for you.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>You can help to improve the book it by making a contribution in its
<a href="https://github.com/fyrox-book/fyrox-book.github.io">repository</a>.</p>
<h2 id="support-the-development"><a class="header" href="#support-the-development">Support the development</a></h2>
<p>The future of the project fully depends on community support, every bit is important!</p>
<p><a href="https://www.patreon.com/mrdimas"><img src="https://c5.patreon.com/external/logo/become_a_patron_button.png" alt="Become a patron!" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This section of the book contains a brief overview of engine's features, it should help you to decide if the engine suits
your needs. The following chapters takes you into a tour over engine's features, its editor, basic concepts and design philosophy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-fyrox"><a class="header" href="#introduction-to-fyrox">Introduction to Fyrox</a></h1>
<p>Fyrox is a feature-rich, general purpose game engine that is suitable for any kind of games. It is capable of power
games with small- or medium-sized worlds, large-sized world most likely will require some manual work.</p>
<p>Games made with the engine are capable of run on desktop platforms (PC, Mac, Linux), Web (WebAssembly),
Android and iOS. See the <a href="introduction/requirements.html#supported-platforms">full list of supported platforms here</a>.</p>
<h2 id="what-can-the-engine-do"><a class="header" href="#what-can-the-engine-do">What can the engine do?</a></h2>
<p>You can create pretty much any kind of game or interactive applications. Here's some examples of what the engine can
do:</p>
<p><img src="introduction/game_example1.jpg" alt="Station Iapetus" />
<img src="introduction/game_example2.jpg" alt="Fish Folly" />
<img src="introduction/game_example3.jpg" alt="2D Platformer" /></p>
<h2 id="how-does-the-engine-work"><a class="header" href="#how-does-the-engine-work">How does the engine work?</a></h2>
<p>The engine consists of two parts that you'll be actively using: the framework and the editor. The framework is a
foundation of the engine, it manages rendering, sound, scripts, plugins, etc. While the editor contains lots of tools
that can be used to create game worlds, manage assets, edit game objects, scripts, and more.</p>
<p><img src="introduction/editor.jpg" alt="Fish Folly" /></p>
<h2 id="programming-languages"><a class="header" href="#programming-languages">Programming languages</a></h2>
<p>Everything of your game can be written entirely in Rust, utilizing its safety guarantees as well as speed. However, it
is possible to use any scripting language that you want, but other languages may have no built-in support, and you will
need to implement this manually.</p>
<h2 id="engine-features"><a class="header" href="#engine-features">Engine Features</a></h2>
<p>This is a more or less complete (yet, it can be outdated) list of engine features:</p>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<ul>
<li>Exceptional safety, reliability, and speed.</li>
<li>PC (Windows, Linux, macOS), Android, iOS, <a href="https://fyrox.rs/examples">Web (WebAssembly) support</a>.</li>
<li>Modern, PBR rendering pipeline.</li>
<li>Comprehensive <a href="https://docs.rs/Fyrox">documentation</a>.</li>
<li>2D support.</li>
<li>Integrated editor.</li>
<li>Fast iterative compilation with native code hot-reloading support.</li>
<li>Classic object-oriented design with an ability to be extended with ECS.</li>
<li>Lots of examples.</li>
</ul>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<ul>
<li>Custom shaders, materials, and rendering techniques.</li>
<li>Physically-based rendering with metallic workflow by default.</li>
<li>High dynamic range (HDR) rendering.</li>
<li>Tone mapping.</li>
<li>Color grading.</li>
<li>Auto-exposure.</li>
<li>Gamma correction.</li>
<li>Deferred shading.</li>
<li>Directional light.</li>
<li>Point lights + shadows.</li>
<li>Spotlights + shadows.</li>
<li>Screen-Space Ambient Occlusion (SSAO).</li>
<li>Soft shadows.</li>
<li>Volumetric light (spot, point).</li>
<li>Batching.</li>
<li>Instancing.</li>
<li>Fast Approximate Anti-Aliasing (FXAA).</li>
<li>Normal mapping.</li>
<li>Parallax mapping.</li>
<li>Render in texture.</li>
<li>Forward rendering for transparent objects.</li>
<li>Sky box.</li>
<li>Deferred decals.</li>
<li>Multi-camera rendering.</li>
<li>Lightmapping.</li>
<li>Soft particles.</li>
<li>Fully customizable vertex format.</li>
<li>Compressed textures support.</li>
<li>High-quality mip-map on-demand generation.</li>
</ul>
<h3 id="scene"><a class="header" href="#scene">Scene</a></h3>
<ul>
<li>Multiple scenes.</li>
<li>Full-featured scene graph.</li>
<li>Level-of-detail (LOD) support.</li>
<li>GPU Skinning.</li>
<li>Various scene nodes:
<ul>
<li>Pivot.</li>
<li>Camera.</li>
<li>Decal.</li>
<li>Mesh.</li>
<li>Particle system.</li>
<li>Sprite.</li>
<li>Multilayer terrain.</li>
<li>Rectangle (2D Sprites)</li>
<li>Rigid body + Rigid Body 2D</li>
<li>Collider + Collider 2D</li>
<li>Joint + Joint 2D</li>
<li>Tile map</li>
<li>Navigation mesh</li>
<li>Ragdoll</li>
<li>Sound + Sound Listener</li>
<li>Various light sources</li>
</ul>
</li>
</ul>
<h3 id="sound"><a class="header" href="#sound">Sound</a></h3>
<ul>
<li><a href="https://github.com/FyroxEngine/Fyrox/tree/master/fyrox-sound">High quality binaural sound with HRTF support</a>.</li>
<li>Generic and spatial sound sources.</li>
<li>Built-in streaming for large sounds.</li>
<li>Raw samples playback support.</li>
<li>Wide variety of supported formats.</li>
<li>HRTF support for excellent positioning and binaural effects.</li>
<li>Reverb effect.</li>
<li>Audio processing graph.</li>
<li>Various filters.</li>
</ul>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<ul>
<li>Powerful serialization system</li>
<li>Almost every entity of the engine can be serialized.</li>
<li>No need to write your own serialization.</li>
</ul>
<h3 id="animation"><a class="header" href="#animation">Animation</a></h3>
<ul>
<li>Animation blending state machine - similar to Mecanim in Unity Engine.</li>
<li>Animation retargetting - allows you to remap animation from one model to another.</li>
<li>Blend space</li>
<li>Root motion</li>
</ul>
<h3 id="asset-management"><a class="header" href="#asset-management">Asset management</a></h3>
<ul>
<li>Advanced asset manager.</li>
<li>Fully asynchronous asset loading.</li>
<li>PNG, JPG, TGA, DDS, etc. textures.</li>
<li>FBX/GLTF/GLB models loader.</li>
<li>WAV, OGG, MP3, etc. sound formats.</li>
<li>Compressed textures support (DXT1, DXT3, DTX5).</li>
</ul>
<h3 id="artificial-intelligence-ai"><a class="header" href="#artificial-intelligence-ai">Artificial Intelligence (AI)</a></h3>
<ul>
<li>A* pathfinder.</li>
<li>Navmesh.</li>
<li>Behavior trees.</li>
</ul>
<h3 id="user-interface-ui"><a class="header" href="#user-interface-ui">User Interface (UI)</a></h3>
<ul>
<li><a href="https://github.com/FyroxEngine/Fyrox/tree/master/fyrox-ui">Advanced node-based UI</a> with lots of widgets.</li>
<li>More than 32 widgets</li>
<li>Powerful layout system.</li>
<li>Full TTF/OTF fonts support.</li>
<li>Based on message passing.</li>
<li>Fully customizable.</li>
<li>GAPI-agnostic.</li>
<li>OS-agnostic.</li>
<li>Button widget.</li>
<li>Border widget.</li>
<li>Canvas widget.</li>
<li>Color picker widget.</li>
<li>Color field widget.</li>
<li>Check box widget.</li>
<li>Decorator widget.</li>
<li>Drop-down list widget.</li>
<li>Grid widget.</li>
<li>Image widget.</li>
<li>List view widget.</li>
<li>Popup widget.</li>
<li>Progress bar widget.</li>
<li>Scroll bar widget.</li>
<li>Scroll panel widget.</li>
<li>Scroll viewer widget.</li>
<li>Stack panel widget.</li>
<li>Tab control widget.</li>
<li>Text widget.</li>
<li>Text box widget.</li>
<li>Tree widget.</li>
<li>Window widget.</li>
<li>File browser widget.</li>
<li>File selector widget.</li>
<li>Docking manager widget.</li>
<li>NumericUpDown widget.</li>
<li><code>Vector3&lt;f32&gt;</code> editor widget.</li>
<li>Menu widget.</li>
<li>Menu item widget.</li>
<li>Message box widget.</li>
<li>Wrap panel widget.</li>
<li>Curve editor widget.</li>
<li>User defined widget.</li>
</ul>
<h3 id="physics"><a class="header" href="#physics">Physics</a></h3>
<ul>
<li>Advanced physics (thanks to the <a href="https://github.com/dimforge/rapier">rapier</a> physics engine)</li>
<li>Rigid bodies.</li>
<li>Rich set of various colliders.</li>
<li>Joints.</li>
<li>Ray cast.</li>
<li>Joints motor.</li>
<li>2D support.</li>
<li>Many other useful features.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h1>
<p>As any other software, Fyrox has its own system requirements that will provide the best user experience.</p>
<ul>
<li><strong>CPU</strong> - at least 2 core CPU with 1.5 GHz per each core. The more is better.</li>
<li><strong>GPU</strong> - any relatively modern GPU with OpenGL 3.3+ support. If the editor fails to start, then it is most likely your
video card does not support OpenGL 3.3+. Do <strong>not</strong> try to run the editor on virtual machines, pretty much all of them
have rudimentary support for graphics APIs which won't let you run the editor.</li>
<li><strong>RAM</strong> - at least 1 Gb of RAM. The more is better.</li>
<li><strong>VRAM</strong> - at least 256 Mb of video memory. It highly depends on your game.</li>
<li><strong>Monitor</strong> - 1920x1080 or higher resolution, lower resolutions may work as well.</li>
</ul>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Engine</th><th>Editor</th></tr></thead><tbody>
<tr><td>Windows</td><td>✅</td><td>✅</td></tr>
<tr><td>Linux</td><td>✅</td><td>✅</td></tr>
<tr><td>macOS</td><td>✅¹</td><td>✅</td></tr>
<tr><td>WebAssembly</td><td>✅</td><td>❌²</td></tr>
<tr><td>Android</td><td>✅</td><td>❌²</td></tr>
<tr><td>iOS</td><td>✅</td><td>❌²</td></tr>
</tbody></table>
</div>
<ul>
<li>✅ - first-class support</li>
<li>❌ - not supported</li>
<li>¹ - macOS suffers from bad GPU performance on Intel chipsets, M1+ works well.</li>
<li>² - the editor works only on PC, it requires rich filesystem functionality as well as decent threading support.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic concepts</a></h1>
<p>Let's briefly get over some basic concepts of the engine, there's not much, but all of them are crucial to understand
design decisions made in the engine.</p>
<h2 id="classic-oop"><a class="header" href="#classic-oop">Classic OOP</a></h2>
<p>The engine uses somewhat classic OOP with composition over inheritance - complex objects in the engine can be constructed
using simpler objects. It is also possible to use ECS approach, but you need to manually synchronize ECS entities with
the engine entities. This approach is recommended for games with a high number of entities. There's no built-in ECS
framework, but there are plenty of them in the Rust ecosystem.</p>
<h2 id="scenes"><a class="header" href="#scenes">Scenes</a></h2>
<p>In Fyrox, you break down your game in a set of reusable scenes. Pretty much anything can be a scene: a player, a weapon,
a bot, level parts, etc. Scenes can be nested one into another, this helps you to break down complex scenes into reusable
parts. A Scene in Fyrox also plays the role of a prefab, there's pretty much no difference between them.</p>
<h2 id="nodes-and-scene-graph"><a class="header" href="#nodes-and-scene-graph">Nodes and Scene Graph</a></h2>
<p>A scene is made of one or more nodes. Every scene must have at least one root node, to which everything else is attached.
A scene node contains specific set of properties as well as a number of scripts which are responsible for custom
game logic.</p>
<p>The typical structure of a scene node can be represented by the following example. The base object for every scene node is
a <code>Base</code> node, it contains a transform, a list of children, etc. A more complex node, that <em>extends</em> functionality of the <code>Base</code>
node stores an instance of <code>Base</code> inside it, i.e. composition. For example, a <code>Mesh</code> node is a <code>Base</code> node <em>plus</em> some specific info
(a list of surfaces, material, etc.). The "hierarchy" depth is unlimited e.g. a <code>Light</code> node in the engine is an enumeration
of three possible types of light source: <code>Directional</code>, <code>Point</code>, and <code>Spot</code>. All three of these light sources all contain a <code>BaseLight</code> node,
which in turn contains a <code>Base</code> node. Graphically, it can be represented like so:</p>
<pre><code class="language-text">`Point`
|__ Point Light Properties (radius, etc.)
|__`BaseLight`
   |__ Base Light Properties (color, etc.)
   |__`Base`
      |__ Base Node Properties (transform, children nodes, etc.)
</code></pre>
<p>As you can see, this forms the nice tree (graph) that shows what the object contains. This is a very natural way of describing
scene nodes, it gives you the full power of building an object of any complexity.</p>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>Plugin is a container for "global" game data and logic, its main usage is to provide scripts with some data and to
manage global game state. Your game can have multiple plugins, but usually only one acts as an "entry point".</p>
<h2 id="scripts"><a class="header" href="#scripts">Scripts</a></h2>
<p>Script - is a separate piece of data and logic, that can be attached to scene nodes. This is the primary (but not only)
way of adding custom game logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-philosophy-and-goals"><a class="header" href="#design-philosophy-and-goals">Design Philosophy and Goals</a></h1>
<p>Let's talk a bit about design philosophy and goals of the engine. Development of the engine started in the beginning
of 2019 as a hobby project to learn Rust, and it quickly showed that Rust can be a game changer in the game development
industry. Initially, the engine was just a port of <a href="https://github.com/mrDIMAS/DmitrysEngine">an engine</a> that is written
in C. At the beginning, it was very interesting to build such complex thing as game engine in such low level language without
any safety guarantees. After a year of development, it became annoying to fix memory related issues (memory corruption,
leaks, etc.), luckily at that time Rust's popularity grew, and it showed on my radar. I (<a href="https://github.com/mrDIMAS">@mrDIMAS</a>)
was able to port the engine to it in less than a year. Stability has improved dramatically, no more random crashes,
performance was at the same or better levels - time invested in learning new language was paid off. Development speed
does not degrade over time as it was in C, it is very easy to manage growing project.</p>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p>One of the main goals in the development of the engine is to provide a high level of safety. What does this mean?
In short: protection from memory-safety related bugs. This does not include any logic errors, but when your game is free
of random crashes due to memory unsafety, it is much easier to fix logic bugs, because you don't have to think about
potentially corrupted memory.</p>
<p>Safety also dictates the architectural design decisions of your game. The typical callback hell, that is possible to do in
many other languages, is very tedious to implement in Rust. It is possible, but it requires quite a lot of manual work
which quickly tells you that you're doing it wrong.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Game engines are usually built using system-level programming languages, which provide peak performance levels. Fyrox is not
an exception. One of its design goals is to provide high levels of performance by default, leaving an opportunity for
adding custom solutions for performance-critical places.</p>
<h2 id="ease-of-use"><a class="header" href="#ease-of-use">Ease of use</a></h2>
<p>Another very important part is that the engine should be friendly to newcomers. It should lower the entry threshold, not make
it worse. Fyrox uses well known and battle-tested concepts, thus making it easier to make games with it. On the other hand,
it can still be extended with anything you need - it tries to be as good for veterans of the game industry as it is for
newcomers.</p>
<h2 id="battle-tested"><a class="header" href="#battle-tested">Battle-tested</a></h2>
<p>Fyrox has large projects built on it, which helps with understanding the real needs of a general-purpose game engine. It also helps
reveal weak spots in the design and fix them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>This chapter contains answers for frequently asked questions.</p>
<h2 id="which-graphics-api-does-the-engine-use"><a class="header" href="#which-graphics-api-does-the-engine-use">Which graphics API does the engine use?</a></h2>
<p>Fyrox uses OpenGL 3.3 on PC and OpenGL ES 3.0 on WebAssembly. Why? Mainly due to historical reasons. Back in the day
(Q4 of 2018), there weren't any good alternatives to it with a wide range of supported platforms. For example, <code>wgpu</code>
<a href="https://crates.io/crates/wgpu/0.1.0">didn't even exist</a>, as its first version was released in January 2019. Other crates were taking their first baby steps and weren't ready for production.</p>
<h3 id="why-not-use-alternatives-now"><a class="header" href="#why-not-use-alternatives-now">Why not use alternatives now?</a></h3>
<p>There is no need for it. The current implementation works and is more than good enough. So instead of focusing on
replacing something that works for little to no benefit, the current focus is on adding features that are missing as
well as improving existing features when needed. If you have some specific demands, you can implement your own graphics
server with a GAPI that you want. See <a href="introduction/../rendering/server.html">this chapter</a> for more info.</p>
<h2 id="is-the-engine-based-on-ecs"><a class="header" href="#is-the-engine-based-on-ecs">Is the engine based on ECS?</a></h2>
<p>No, the engine uses a mixed composition-based, object-oriented design with message passing and other different approaches
that fit the most for a particular task. Why not use ECS for everything, though? Pragmatism. Use the right tool for the job.
Don't use a microscope to hammer nails. As was mentioned in the previous chapter, it is possible to use ECS, but you need
to manually synchronize the state of your entities with respective engine entities.</p>
<h2 id="what-kinds-of-games-can-i-make-using-fyrox"><a class="header" href="#what-kinds-of-games-can-i-make-using-fyrox">What kinds of games can I make using Fyrox?</a></h2>
<p>Pretty much any kind of games, except maybe games with vast open-worlds (since there's no built-in world streaming).
In general, it depends on your game development experience.</p>
<h2 id="what-if-i-dont-need-the-editor"><a class="header" href="#what-if-i-dont-need-the-editor">What if I don't need the editor?</a></h2>
<p>You can completely ignore the editor if you need, you can even delete it from your project without any consequences.
It is also possible to initialize the engine manually, as an ordinary Rust crate. See
<a href="introduction/../engine/manual_initialization.html">this chapter</a> for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section of the book will guide you through the basics of the engine. You will learn how to create a project, use
plugins, scripts, assets, and the editor. Fyrox is a modern game engine with its own scene editor, that helps you to edit
game worlds, manage assets, and much more. By the end this section, you will have learned how to manage game and
engine entities, understand how they are structured and have basic knowledge of data management in the engine.</p>
<p>The next chapter will guide you through the major setup of the engine - creating a game project using the special project generator
tool.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-and-project-creation"><a class="header" href="#installation-and-project-creation">Installation and Project Creation</a></h1>
<p>Fyrox is a compiled game engine, this means that your game needs to be compiled to native code before it can be run.
This fact requires a specific project structure which is generated when you're making a new project. This project
consists of a few Rust crates (game, editor, executors for each platform). Every Fyrox game is just a plugin for both
the engine and the editor crates. This approach allows the game to run from the editor and enables editing of the game
entities from within it, or just run the game without the editor (since not every game needs an editor). This chapter
will cover how to install the engine with its platform-specific dependencies, how to use the plugins and scripting
system, and how to run the editor.</p>
<h2 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform-specific Dependencies</a></h2>
<p>Before starting to use the engine, make sure all required platform-specific development dependencies are installed. If
using Windows or macOS, no additional dependencies are required other than
the <a href="https://rustup.rs">latest Rust installed</a> with the appropriate toolchain for your platform.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>On Linux, Fyrox needs the following libraries for development: <code>libxcb-shape0</code>, <code>libxcb-xfixes0</code>, <code>libxcb1</code>,
<code>libxkbcommon</code>, <code>libasound2</code>, <code>libegl-mesa0</code> and the <code>build-essential</code> package group.</p>
<p>For Debian based distros like Ubuntu, they can be installed like below:</p>
<pre><code class="language-shell">sudo apt install libxcb-shape0-dev libxcb-xfixes0-dev libxcb1-dev libxkbcommon-dev libasound2-dev libegl-mesa0 build-essential
</code></pre>
<p>For NixOS, run <code>nix develop</code> from the root of your project to open a shell with all the required dependencies.
<code>flake.nix</code> is included in the generated project for you. It's content is the following:</p>
<details>
<summary>flake.nix</summary>
<pre><code class="language-nix">{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = {
    nixpkgs,
    rust-overlay,
    ...
  }:
  let
    overlays = [
      (import rust-overlay)
    ];

    systems = [
      "x86_64-linux"
      "aarch64-linux"
    ];

    forAllSystems = f:
      nixpkgs.lib.genAttrs systems
      (system: f { pkgs = import nixpkgs { inherit system overlays; }; });
  in
  {
    devShells = forAllSystems ({ pkgs }: with pkgs; {
      default = mkShell rec {
        buildInputs = [
          rust-bin.stable.latest.default

          pkg-config
          xorg.libxcb
          alsa-lib
          wayland
          libxkbcommon
          libGL
        ];
        LD_LIBRARY_PATH = "${lib.makeLibraryPath buildInputs}";
      };
    });
  };
}
</code></pre>
</details>
<h2 id="project-manager"><a class="header" href="#project-manager">Project Manager</a></h2>
<p><a href="https://fyrox.rs/download.html"><img src="https://fyrox.rs/assets/0.36/project_manager.png" alt="project manager" /></a></p>
<p><a href="https://fyrox.rs/download.html">Project manager</a> is a part of the engine that allows you to manage multiple projects made with the engine all at once.
It allows you to create a new project or import an existing one, run the project or edit it in the editor,
upgrade the project to a selected version of the engine, and many more options. If you want to learn more about
the project manager, read <a href="beginning/project_manager.html">this chapter</a>.</p>
<p><a href="https://fyrox.rs/download.html">Download the project manager</a> for your OS from the website or install it using
<code>cargo install fyrox-project-manager</code> and run it. Then click the <code>+Create</code> button, select the path where you want the
project to be located and click <code>Create</code>. The project manager will create a new directory for your project with the
following structure (some files are omitted to be less verbose):</p>
<pre><code class="language-text">YourProject
├───Cargo.toml
├───data
│       scene.rgs
├───game
│   │   Cargo.toml
│   └───src
│           lib.rs
├───editor
├───executor
├───executor-android
├───executor-wasm
└───game-dylib
</code></pre>
<p>The most important parts in this structure:</p>
<ul>
<li><code>Cargo.toml</code> - the workspace of your project.</li>
<li><code>game</code> - your game code.</li>
<li><code>data</code> - the folder where all the assets must be located (subfolders allowed).</li>
<li><code>editor</code> - the editor for your project (can be deleted if not needed).</li>
<li><code>executor</code> - entry point for PC (can be deleted if not needed).</li>
<li><code>executor-android</code> - entry point for Android (can be deleted if not needed).</li>
<li><code>executor-wasm</code> - entry point for WebAssembly (can be deleted if not needed).</li>
<li><code>game-dylib</code> - special "bridge" for native code hot reloading functionality (can be deleted if not needed).</li>
</ul>
<p>To run the project, select the new project in the list and click <code>Edit</code> button to run the editor, or <code>Run</code> to run
the game without the editor (the game can also be run from the editor). Learn more about the
<a href="beginning/project_manager.html">project manager here</a>.</p>
<p>Your project needs to be compiled from scratch before it can be run, it may take some time, usually it takes up to 10
minutes on a CPU with 4 cores (8 core CPU will compile the engine in just 5 minutes or so). Next runs of the editor will
only compile your game, which usually takes a few seconds. Anyway, after some time you should see the editor window.</p>
<p><img src="beginning/editor.png" alt="editor" /></p>
<p>To cut down iteration times, you may want to use a powerful-yet-dangerous tool called native code hot reloading.
Learn more about it in <a href="beginning/hot_reloading.html">this chapter</a>.</p>
<h2 id="usage-modes"><a class="header" href="#usage-modes">Usage Modes</a></h2>
<p>There are a number of ways in which you can use the engine. For example, if you don't need the editor, just don't
use it. You can still compile your game to a desired platform. Even the project manager and the projects it
generates aren't mandatory at all.</p>
<p>If you want to manually initialize the engine without all these fancy bells and whistles, read
<a href="beginning/../engine/manual_initialization.html">the respective chapter</a>. Keep in mind, however, that this book is written
in assumption that you're using the engine in the recommended way and all non-standard usage may result in
unexpected behavior. The recommended approach does all the "heavy lifting" for you.</p>
<h2 id="adding-game-logic"><a class="header" href="#adding-game-logic">Adding Game Logic</a></h2>
<p>Any object-specific game logic should be added using scripts. A script is a "container" for data and code, that will be
executed by the engine. Read the <a href="beginning/../scripting/scripting.html">respective chapter</a> to learn how to create, edit, and use scripts
in your game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-installation"><a class="header" href="#manual-installation">Manual Installation</a></h1>
<blockquote>
<p>⚠️ This section is mostly for console users and those who like building their software from source code.
This section relies on using <code>fyrox-template</code> CLI tool, Project Manager uses it as well, but with the benefits of a
GUI.</p>
</blockquote>
<h2 id="quick-start-using-console-commands"><a class="header" href="#quick-start-using-console-commands">Quick Start Using Console Commands</a></h2>
<p>Run the following commands to start using the editor as quickly as possible.</p>
<pre><code class="language-sh">cargo install fyrox-template
fyrox-template init --name fyrox_test --style 2d
cd fyrox_test
cargo run --package editor --release
</code></pre>
<h2 id="project-generator-cli"><a class="header" href="#project-generator-cli">Project Generator CLI</a></h2>
<p>Fyrox offers a special tiny command line tool - <code>fyrox-template</code>, the project manager uses its core functionality as
well. This helps generate all the boilerplate code with a single command. Install it by running the following command:</p>
<pre><code class="language-shell">cargo install fyrox-template
</code></pre>
<p><em>Note for Linux:</em> This installs it in <code>$user/.cargo/bin</code>. If receiving errors about the <code>fyrox-template</code> command not<br />
being found, add this hidden cargo bin folder to the operating systems <code>$PATH</code> environment variable.</p>
<p>Now, navigate to the desired project folder and run the following command:</p>
<pre><code class="language-shell">fyrox-template init --name my_game --style 3d
</code></pre>
<p>Note that unlike <code>cargo init</code>, this will create a new folder with the given name.</p>
<p>The tool accepts two arguments - a project name (<code>--name</code>) and a style (<code>--style</code>), which defines the contents of the
default scene. After initializing the project, go to <code>game/src/lib.rs</code> - this is where the game logic is located, as you
will see, the <code>fyrox-template</code> generates quite a bit of code for you. The code is decorated with comments explaining
what each place is for. For more info about each method, please
refer <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">to the docs</a>.</p>
<p>Once the project is generated, two commands can be used to run your game in different modes:</p>
<ul>
<li><code>cargo run --package editor --release</code> - launches the editor with your game attached. The editor allows you to run
your game
from it and edit its game entities. This is intended to be used only for development purposes.</li>
<li><code>cargo run --package executor --release</code> - creates and runs the production binary of your game. This command generates
executables which can be shipped (for example - to a store).</li>
</ul>
<p>Navigate to your project's directory and run <code>cargo run --package editor --release</code>, after a short while, you should see
the editor:</p>
<p><img src="beginning/editor.png" alt="editor" /></p>
<p>In the editor you can start building your game scene. <strong>Important note:</strong> your scene must have at least one camera,
otherwise you won't see a thing. Read the next chapter to learn how to use the editor.</p>
<h2 id="using-the-latest-engine-version"><a class="header" href="#using-the-latest-engine-version">Using the Latest Engine Version</a></h2>
<p>Due to the nature of software development, bugs will inevitably sneak into the major releases, due to this,
it is recommended to always use the latest engine version from the repository on GitHub. This is most likely to have
bugs fixed (you can also contribute by fixing any bugs you find or at least,
by <a href="https://github.com/FyroxEngine/Fyrox/issues">filing an issue</a>).</p>
<h3 id="automatic"><a class="header" href="#automatic">Automatic</a></h3>
<blockquote>
<p>⚠️ <code>fyrox-template</code> has a special sub-command - <code>upgrade</code> to quickly upgrade to a desired engine version. To upgrade
to the latest version (<code>nightly</code>) you should execute <code>fyrox-template upgrade --version nightly</code> command in your game's
directory.</p>
</blockquote>
<p>There are three main variants for <code>--version</code> switch:</p>
<ul>
<li><code>nightly</code> - uses latest nightly version of the engine from GitHub directly. This is the preferable version if you want
to use the latest changes and bug fixes as they are released.</li>
<li><code>latest</code> - uses latest stable version of the engine. This option also supports <code>--local</code> key, that sets the path to
the engine to <code>../Fyrox/fyrox</code> and the editor to <code>../Fyrox/editor</code>. Obviously, this path requires the engine to be
located in the parent directory of your project. This option could be useful if you want to use a custom version of
the engine (for example, if you're developing a patch for the engine).</li>
<li><code>major.minor.patch</code> - uses a specific stable version from crates.io (<code>0.30.0</code> for example).</li>
</ul>
<h3 id="manual"><a class="header" href="#manual">Manual</a></h3>
<p>The Engine version can also be updated manually. The first step is to install the latest <code>fyrox-template</code>, this can be
done with a single <code>cargo</code> command:</p>
<pre><code class="language-shell">cargo install fyrox-template --force --git https://github.com/FyroxEngine/Fyrox
</code></pre>
<p>This will ensure you're using the latest project/script template generator, which is very important; old versions
of the template generator will most likely generate outdated code, which is no longer compatible with the engine.</p>
<p>To switch existing projects to the latest version of the engine, you will need to specify paths pointing to the remote
repository for the <code>fyrox</code> and <code>fyroxed_base</code> dependencies. All you need to do is to change paths to these dependencies
in the root <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[workspace.dependencies.fyrox]
version = { git = "https://github.com/FyroxEngine/Fyrox" }
default-features = false
[workspace.dependencies.fyroxed_base]
version = { git = "https://github.com/FyroxEngine/Fyrox" }
</code></pre>
<p>Now your game will use the latest engine and editor, but beware - new commits may surface some API mis-matches. You can
avoid these by specifying a particular commit, just add <code>rev = "desired_commit_hash"</code> to every dependency like so:</p>
<pre><code class="language-toml">[dependencies]
[workspace.dependencies.fyrox]
version = { git = "https://github.com/FyroxEngine/Fyrox", rev = "0195666b30562c1961a9808be38b5e5715da43af" }
default-features = false
[workspace.dependencies.fyroxed_base]
version = { git = "https://github.com/FyroxEngine/Fyrox", rev = "0195666b30562c1961a9808be38b5e5715da43af" }
</code></pre>
<p>To bring a local git repository of the engine to the latest version, just call <code>cargo update</code> at the root of the
project's workspace. This will pull the latest changes from the remote, unless there is no <code>rev</code> specified.</p>
<p>Learn more about dependency paths on the official <code>cargo</code>
documentation, <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fyroxed-overview"><a class="header" href="#fyroxed-overview">FyroxEd Overview</a></h1>
<p>FyroxEd - is the native editor of Fyrox, it is made with one purpose - to be an integrated game development environment
that helps you build your game from start to finish with relatively low effort.</p>
<p>You'll be spending a lot of time in the editor, so you should get familiar with it and learn how to use its basic functionalities.
This chapter will guide you through the basics, advanced topics will be covered in their respective chapters.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>When you open the editor for the first time you may be confused by the number of windows, buttons, lists, etc. you'll be presented
with. Each window serves a different purpose, but all of them work together to help you make your game. Let's take a look at a
screenshot of the editor and learn what each part of it is responsible for (please note that this can change over time, because
development is quite fast and images can easily become outdated):</p>
<p><img src="beginning/./overview.png" alt="Windows" /></p>
<ul>
<li><strong>World viewer</strong> - shows every object in the scene and their relationships. Allows inspecting and editing the
contents of the scene in a hierarchical form.</li>
<li><strong>Scene preview</strong> - renders the scene with debug info and various editor-specific objects (gizmos, entity icons,
etc.). Allows you to select, move, rotate, scale, delete, etc. various entities. The <strong>Toolbar</strong> on its left side
shows available context-dependent tools.</li>
<li><strong>Inspector</strong> - allows you to modify various properties of the selected object.</li>
<li><strong>Message Log</strong> - displays important messages from the editor.</li>
<li><strong>Navmesh Panel</strong> - allows you to create, delete, and edit navigational meshes.</li>
<li><strong>Command Stack</strong> - displays your most recent actions and allows you to undo or redo their changes.</li>
<li><strong>Asset Browser</strong> - allows you to inspect the assets of your game and to instantiate resources in the scene, among other things.</li>
<li><strong>Audio Context</strong> - allows you to edit the settings of the scene's sound context (global volume, available audio buses, effects,
etc.)</li>
</ul>
<h2 id="creating-or-loading-a-scene"><a class="header" href="#creating-or-loading-a-scene">Creating or loading a Scene</a></h2>
<p>FyroxEd works with scenes - a scene is a container for game entities, you can create and edit one scene at a time. You must have a
scene loaded to begin working with the editor. To create a scene go to <code>File -&gt; New Scene</code>.</p>
<p>To load an existing scene, go to <code>File -&gt; Load</code> and select the desired scene through the file browser. Recently opened
scenes can be loaded more quickly by going to <code>File -&gt; Recent Scenes</code> and selecting the desired one.</p>
<h2 id="populating-a-scene"><a class="header" href="#populating-a-scene">Populating a Scene</a></h2>
<p>A scene can contain various game entities. There are two equivalent ways of creating these:</p>
<ul>
<li>By going to <code>Create</code> in the main menu and selecting the desired entity from the drop down.</li>
<li>By right-clicking on a game entity in the <code>World Viewer</code> and selecting the desired entity from the <code>Create Child</code> sub-menu.</li>
</ul>
<p>Complex objects usually made in 3D modelling software (Blender, 3Ds Max, Maya, etc.) can be saved in various formats.
Fyrox supports FBX format, which is supported by pretty much any 3D modelling software. You can instantiate such objects
by simply dragging the one you want and dropping it on the <code>Scene Preview</code>. While dragging it, you'll also see a preview
of the object.</p>
<p>You can do the same with other scenes made in the editor (<code>rgs</code> files), for example, you can create a scene with a few objects in it
with some scripts and re-use them within other scenes. Such scenes are called <a href="beginning/../scene/prefab.html">prefabs</a>.</p>
<h2 id="saving-a-scene"><a class="header" href="#saving-a-scene">Saving a Scene</a></h2>
<p>To save your work, go to <code>File -&gt; Save</code>. If you're saving a new scene, the editor will ask you to specify a file name and a
path to where the scene will be saved. Scenes loaded from a file will automatically be saved to the path they were loaded
from.</p>
<h2 id="undoing-and-redoing"><a class="header" href="#undoing-and-redoing">Undoing and redoing</a></h2>
<p>FyroxEd remembers your actions and allows you to undo and redo the changes done by these. You can undo or redo changes by either
going to <code>Edit -&gt; Undo/Redo</code> or through the usual shortcuts: <code>Ctrl+Z</code> - to undo, <code>Ctrl+Y</code> - to redo.</p>
<h2 id="controls"><a class="header" href="#controls">Controls</a></h2>
<p>There are number of control keys that you'll be using most of the time, pretty much all of them work in the <code>Scene Preview</code> window:</p>
<h3 id="editor-camera-movement"><a class="header" href="#editor-camera-movement">Editor camera movement</a></h3>
<p>Click and hold <code>[Right Mouse Button]</code> within the <code>Scene Preview</code> window to enable the movement controls:</p>
<ul>
<li><code>[W][S][A][D]</code> - Move camera forward/backward/left/right</li>
<li><code>[Space][Q]/[E]</code> - Raise/Lower Camera</li>
<li><code>[Ctrl]</code> - Speed up</li>
<li><code>[Shift]</code>- Slowdown</li>
</ul>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<ul>
<li><code>[Left Mouse Button]</code> - Select</li>
<li><code>[Middle Mouse Button]</code> - Pan camera in viewing plane</li>
<li><code>[1]</code> - Select interaction mode</li>
<li><code>[2]</code> - Move interaction mode</li>
<li><code>[3]</code> - Scale interaction mode</li>
<li><code>[4]</code> - Rotate interaction mode</li>
<li><code>[5]</code> - Navigational mesh editing mode</li>
<li><code>[6]</code> - Terrain editing interaction mode</li>
<li><code>[Ctrl]+[Z]</code> - Undo</li>
<li><code>[Ctrl]+[Y]</code> - Redo</li>
<li><code>[Delete]</code> - Delete current selection.</li>
</ul>
<h2 id="play-mode"><a class="header" href="#play-mode">Play Mode</a></h2>
<p>One of the key features of the editor is that it allows you to run your game from it in a separate process. Use the <code>Play/Stop</code>
button at the top of the <code>Scene Preview</code> window to enter or leave Play Mode. Keep in mind, that the editor UI will be locked while
you're in Play Mode.</p>
<p>Play Mode can be activated only for projects made with the <code>fyrox-template</code> (or for projects with a similar structure). The editor
calls <code>cargo</code> commands to build and run your game in a separate process. Running the game in a separate process ensures
that the editor won't crash if your game does, it also provides excellent isolation between the game and the editor, not
giving a chance to break the editor by running the game.</p>
<h2 id="additional-utilities"><a class="header" href="#additional-utilities">Additional Utilities</a></h2>
<p>There are also number of powerful utilities that will make your life easier, they can be found under the <code>Utils</code> section of the
main menu:</p>
<ul>
<li>Curve Editor - allows you to create and edit curve resources to make complex laws for game parameters.</li>
<li>Path Fixer - helps you fix incorrect resource references in your scenes.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene-and-scene-graph"><a class="header" href="#scene-and-scene-graph">Scene and Scene Graph</a></h1>
<p>When you're playing a game, you often see various objects scattered around the screen, all of them are forming a
<em>scene</em>. A scene is just a set of a variety objects, as in many other game engines, Fyrox allows you to create multiple
scenes for multiple purposes, for example, one scene could be used for a menu, a bunch of others for game levels,
and another one for an ending screen. Scenes can also be used to create a source of data for other scenes, such scenes
are called <em>prefabs</em>. Scenes can also be rendered in a texture, which can be used in other scenes - this way you
can create interactive screens that show other places.</p>
<p>While playing games, you may have noticed that some objects behaves as if they were linked to other objects, for
example, a character in a role-playing game could carry a sword. While the character holds the sword, it is linked to
his
arm. Such relations between the objects can be presented by a graph structure.</p>
<p>Simply speaking, a graph is a set of objects with hierarchical relationships between each object. Each object in the
graph is called a <em>node</em>. In the example with the sword and the character, the sword is a <em>child</em> node of the character,
and the character is a <em>parent</em> node of the sword (here we ignore the fact that in reality, character
models usually contain complex skeletons, with the sword actually being attached to one of the hands' bones, not to the
character).</p>
<p>You can change the hierarchy of nodes in the editor using a simple drag'n'drop functionality in the <code>World Viewer</code> -
drag a node onto some other node, and it will attach itself to it.</p>
<h2 id="building-blocks-or-scene-nodes"><a class="header" href="#building-blocks-or-scene-nodes">Building Blocks or Scene Nodes</a></h2>
<p>The engine offers various types of "building blocks" for your scene, each such block is called a <em>scene node</em>.</p>
<ul>
<li><a href="beginning/../scene/base_node.html">Base</a> - stores hierarchical information (a handle to the parent node and handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it's used as a
base node for every other scene node via composition.</li>
<li><a href="beginning/../scene/mesh_node.html">Mesh</a> - represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes can be easily created either programmatically, or be made in some 3D modelling software, such as Blender,
and then loaded into the scene.</li>
<li><a href="beginning/../scene/light_node.html">Light</a> - represents a light source. There are three types of light sources:
<ul>
<li><strong>Point</strong> - emits light in every direction. A real-world example would be a light bulb.</li>
<li><strong>Spot</strong> - emits light in a particular direction, with a cone-like shape. A real-world example would be a
flashlight.</li>
<li><strong>Directional</strong> - emits light in a particular direction, but does not have position. The closest real-world
example would be the Sun.</li>
</ul>
</li>
<li><a href="beginning/../scene/probe.html">Reflection Probe</a> - reflection probe is an object that allows "capturing" a scene content in a
cube texture, that can later be used to render reflections and be used as a source of ambient lighting for a scene.</li>
<li><a href="beginning/../scene/camera_node.html">Camera</a> - allows you to see the world. You must have at least one camera in your scene to be
able to see anything.</li>
<li><a href="beginning/../scene/sprite_node.html">Sprite</a> - represents a quad that always faces towards a camera. It can have a texture and
size and can also can be rotated around the "look" axis.</li>
<li><a href="beginning/../scene/particle_system_node.html">Particle system</a> - allows you to create visual effects using a huge set of small
particles. It can be used to create smoke, sparks, blood splatters, etc.</li>
<li><a href="beginning/../scene/terrain_node.html">Terrain</a> - allows you to create complex landscapes with minimal effort.</li>
<li><a href="beginning/../scene/decal_node.html">Decal</a> - paints on other nodes using a texture. It is used to simulate cracks in concrete
walls, damaged parts of the road, blood splatters, bullet holes, etc.</li>
<li><a href="beginning/../physics/rigid_body.html">Rigid Body</a> - a physical entity that is responsible for the dynamic of the rigid. There is
a special variant for 2D - <code>RigidBody2D</code>.</li>
<li><a href="beginning/../physics/collider.html">Collider</a> - a physical shape for a rigid body. It is responsible for contact manifold
generation, without it, any rigid body will not participate in simulation correctly, so every rigid body must have at
least one collider. There is a special variant for 2D - <code>Collider2D</code>.</li>
<li><a href="beginning/../physics/joint.html">Joint</a> - a physical entity that restricts motion between two rigid bodies. It has various
amounts of degrees of freedom depending on the type of the joint. There is a special variant for 2D - <code>Joint2D</code>.</li>
<li><a href="beginning/../scene/rectangle.html">Rectangle</a> - a simple rectangle mesh that can have a texture and a color. It is a very simple
version of a Mesh node, yet it uses very optimized renderer, that allows you to render dozens of rectangles
simultaneously. This node is intended for use in <strong>2D games</strong> only.</li>
<li><a href="beginning/../scene/tilemap.html">Tile Map</a> - tile map is a 2D "image", made out of a small blocks called tiles. Tile maps used</li>
<li>in 2D games to build game worlds quickly and easily. An example of a tile map could be something like this:</li>
<li><a href="beginning/../sound/sound.html">Sound</a> - a sound source universal for 2D and 3D. Spatial blend factor allows you to select
a proportion between 2D and 3D.</li>
<li><a href="beginning/../sound/listener.html">Listener</a> - an audio receiver that captures the sound at a particular point in your scene and
sends it to an audio context for processing and outputting to an audio playback device.</li>
<li>Animation Player - a container for multiple animations. It can play animations made in the
<a href="beginning/../animation/anim_editor.html">animation editor</a> and apply animation poses to respective scene nodes.</li>
<li>Animation Blending State Machine - a state machine that mixes multiple animations from multiple states into one; each
state is backed by one or more animation playing or blending nodes. See
its <a href="beginning/../animation/absm_editor.html">respective chapter</a> for more info.</li>
</ul>
<p>Every node can be created either in the editor (through <code>Create</code> on the main menu, or through <code>Add Child</code> after
right-clicking on a game entity) or programmatically via their respective node builder (
see <a href="https://docs.rs/fyrox/latest/fyrox/scene/index.html">API docs</a> for more info). These scene nodes allow you to build
almost any kind of game. It is also possible to create your own types of nodes, but that is an advanced topic, which is
covered in a <a href="beginning/../scene/custom_node.html">future chapter</a>.</p>
<h2 id="local-and-global-coordinates"><a class="header" href="#local-and-global-coordinates">Local and Global Coordinates</a></h2>
<p>A graph describes your scene in a very natural way, allowing you think in terms of relative and absolute coordinates
when working with <em>scene nodes</em>.</p>
<p>A scene node has two kinds of transform - a local and global. The local transform defines where the node is located
relative to its origin, its scale as a percentage, and its rotation around any arbitrary axis.
The global transform is almost the same, but it also includes the whole chain of transforms of the parent nodes. Going
back to the example of the character and the sword, if the character moves, and by extension the sword, the global
transform of the sword will reflect the changes made to the character position, yet its local transform will not, since
that represents the sword's position relative to the character's, which didn't change.</p>
<p>This mechanism is very simple, yet powerful. The full grace of it unfolds when you're working with 3D models with
skeletons. Each bone in a skeleton has its parent and a set of children, which allows you to rotate, translate, or scale
them to
animate your entire character.</p>
<h2 id="scripts-1"><a class="header" href="#scripts-1">Scripts</a></h2>
<p>Scene node can have zero or more scripts assigned to it to execute some logic associated with the node. Scripting
is a separate large topic, and it is described in the <a href="beginning/../scripting/scripting.html">respective chapter</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets"><a class="header" href="#assets">Assets</a></h1>
<p>Asset (or resource) is a shared container for some data that is usually stored in an external storage (a disk,
a web server, etc.). Pretty much every game depends on various assets, such as 3D models, textures, sounds, etc.
Fyrox has its own assets pipeline made to make your life easier.</p>
<h2 id="asset-types"><a class="header" href="#asset-types">Asset Types</a></h2>
<p>The engine offers a set of assets that should cover all of your needs:</p>
<ul>
<li><a href="beginning/../resources/model.html">Models</a> - are a set of objects. They can be a simple 3D model (barrels, bushes, weapons,
etc.) or complex scenes with lots of objects and possibly other model instances. Fyrox supports a number main formats:
FBX and GLTF - which can be used to import 3D models, RGS - which are scenes made in FyroxEd. RGS models are
special, as they can be used as <a href="beginning/../scene/prefab.html">hierarchical prefabs</a>.</li>
<li><a href="beginning/../resources/texture.html">Textures</a> - are images used to add graphical details to objects. The
engine supports multiple texture formats, such as PNG, JPG, BMP, etc. Compressed textures in DDS format are also supported.</li>
<li><a href="beginning/../resources/sound.html">Sound buffers</a> - are data buffers for sound sources. Fyrox supports a number of sound formats,
such as WAV, OGG, MP3, etc. formats.</li>
<li><a href="beginning/../resources/curve.html">Curves</a> - are parametric curves. They're used to create complex functions for numeric parameters.
They can be made in the <code>Curve Editor</code> (<code>Utils -&gt; Curve Editor</code>)</li>
<li><a href="beginning/../sound/hrtf.html">HRIR Spheres</a> - head-related impulse response collection used for head-related transfer function
in the HRTF sound rendering.</li>
<li><a href="beginning/../ui/font.html">Fonts</a> - arbitrary TTF/OTF fonts.</li>
<li><a href="beginning/../rendering/materials.html">Materials</a> - materials for rendering.</li>
<li><a href="beginning/../rendering/shaders.html">Shaders</a> - shaders for rendering.</li>
<li>UI Style - a set of named variables that can be used to alternate the look of widgets, all at once.</li>
<li>Tile Set - a set of descriptions for tiles used in <a href="beginning/../scene/tilemap.html">tile maps</a>.</li>
<li>Animation Tracks Container - a special container for shared data of <a href="beginning/../animation/animation.html">animations</a>.</li>
<li>It is also possible to create custom assets. See <a href="beginning/../resources/custom.html">respective chapter</a> for more info.</li>
<li>Many more very specific asset types.</li>
</ul>
<h2 id="asset-management-1"><a class="header" href="#asset-management-1">Asset Management</a></h2>
<p>Asset management is performed from the <code>Asset Browser</code> window in the editor, you can select an asset, preview it, and edit
its import options.</p>
<p><img src="beginning/assets.png" alt="asset browser" /></p>
<p>The most interesting part here is the import options section under the previewer. It allows you to set asset-specific import options
and apply them. Every asset has its own set of import options. See their respective asset page from the section above to learn
what each import option is for.</p>
<h2 id="asset-instantiation"><a class="header" href="#asset-instantiation">Asset Instantiation</a></h2>
<p>Some asset types can be instantiated in scenes; for now, you can only create direct instances from models. This
is done by simply dragging the model you want to instantiate and dropping it on the <code>Scene Preview</code>. While dragging it,
you'll also see a preview of the model.</p>
<p><img src="beginning/preview.gif" alt="preview" /></p>
<p>The maximum number of asset instances is not limited by the engine but it is by the memory and CPU resources of your PC.
Note that the engine does try to reuse data across instances as much as possible.</p>
<p>You can also instantiate assets dynamically from your code. Here's an example of that for a Model:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn instantiate_model(
    path: &amp;Path,
    resource_manager: ResourceManager,
    scene: &amp;mut Scene,
) -&gt; Handle&lt;Node&gt; {
    // Load the model first. Alternatively, you can store the resource handle somewhere and use it for instantiation.
    let model = resource_manager.request::&lt;Model&gt;(path).await.unwrap();

    model.instantiate(scene)
}
<span class="boring">}</span></code></pre></pre>
<p>This is very useful with prefabs that you may want to instantiate in a scene at runtime.</p>
<h2 id="loading-assets"><a class="header" href="#loading-assets">Loading Assets</a></h2>
<p>Usually, there is no need to manually handle the loading of assets since you have the editor to help with that - just create
a scene with all the required assets. However, there are times when you may need to instantiate some asset dynamically, for
example, a bot prefab. For these cases, you can use the <code>ResourceManager::request&lt;T&gt;</code> method with the appropriate type,
such as <code>Model</code>, <code>Texture</code>, <code>SoundBuffer</code>, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-management"><a class="header" href="#data-management">Data Management</a></h1>
<p>The engine uses pools to store most objects (scene nodes in a
graph, animations in an animation player, sound sources in an audio context, etc.). Since you'll use them quite often, reading and understanding this chapter is recommended.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Rust ownership system and borrow checker, in particular, dictate the rules of data management. In game development, you
often have the need to reference objects from other objects. In languages like C, this is usually achieved by simply storing a raw
pointer and calling it a day. That works, yet it's remarkably unsafe - you risk either forgetting to destroy an object and leaking
memory or destroying an object still being referenced and then trying to access deallocated memory. Other languages, like C++, allow
you to store <em>shared pointers</em> to your data, which by keeping a reference count, ensures the previous doesn't happen at the cost of
a, most often, negligible overhead. Rust counts with smart pointers similar to this, though not without their limitations. There is the <code>Rc/Arc</code> - they function like <em>shared pointers</em>, except they don't allow mutating their content, only
reading it. If you want mutability, you use either a <code>RefCell</code> for a
single-threaded environment, or a <code>Mutex</code> for a multithreaded environment. That is where the problems begin. For
types such as <code>Rc&lt;RefCell&gt;</code> or <code>Arc&lt;Mutex&gt;</code>, Rust enforces its borrowing rules at runtime, which are unlimited readers but
a single writer. Any attempt to borrow mutably more than once at a time will lead to a runtime error.</p>
<p>Another problem with these shared references is that is very easy to accidentally create cyclical references
that prevent objects from ever being destroyed. While the previous could be lived with, the last problem is especially
severe in the case of games: the overhead of runtime checks. In the case of a <code>Rc&lt;RefCell&gt;</code>, it is a single
reference counter for given accesses to the data, but in the case of a <code>Arc&lt;Mutex&gt;</code>, it is a mutex lock.</p>
<p>The solution to these problems is far from ideal; it certainly has its own downfalls. Instead of scattering objects across memory
and then having to manage the lifetime of each of them through reference counting, we can store all of the objects in a single
and contiguous memory block and then use indices to access each object. Such a structure is called a pool.</p>
<h2 id="technical-details"><a class="header" href="#technical-details">Technical Details</a></h2>
<p>A pool is an efficient method of data management. A pool is a vector with entries that can be either vacant or occupied. Each
entry, regardless of its status, also stores a number called a <em>generation</em> number. This is used
to understand whether an entry has changed over time or not. When an entry is reused, its generation number is
increased, rendering all previously created handles leading to the entry invalid. This is a simple and efficient
algorithm for tracking the lifetime of objects.</p>
<p>To access the data in the entries, the engine uses the previously mentioned <em>handles</em>. A handle is a pair of the index of an entry
and a generation number. When you put an object in the pool, this gives you the handle that leads to the object, as well as the
entry's current generation number. The number remains valid until you "free" the object, which makes the entry vacant again.</p>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<ul>
<li>Since a pool is a contiguous memory block, it is far more CPU cache-friendly. This reduces the occurrences of CPU cache misses, which makes accesses to data blazingly fast.</li>
<li>Almost every entity in Fyrox lives on its own pool, which makes it easy to create data structures
like graphs, where nodes refer to other nodes. In this case, nodes simply need to store a handle to refer to other nodes.</li>
<li>Simple lifetime management. There is no way to leak memory since cross-references can only be done via handles.</li>
<li>Fast random access with a constant complexity.</li>
<li>Handles are the same size as a pointer on a 64-bit architecture, just 8 bytes.</li>
</ul>
<h2 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h2>
<ul>
<li>Pools can contain lots of gaps between currently used memory, which may lead to less efficient memory usage.</li>
<li>Handles are sort of weak references, but worse. Since they do not own any data nor even point to their data, you
need a reference to its pool instance in order to borrow the data a handle leads to.</li>
<li>Handles introduce a level of indirection that can hurt performance in places with high loads that require random
access, though this is not too significant as random access is already somewhat slow because of potential
CPU cache misses.</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>You'll use <code>Handle</code> <em>a lot</em> while working with Fyrox. So where are the main usages of pools and
handles? The largest is in a <a href="beginning/../scene/graph.html">scene graph</a>. This stores all the nodes in a pool and gives handles
to each node. Each scene node stores a handle to their parent node and a set of handles to their children nodes. A scene graph
automatically ensures that such handles are valid. In <a href="beginning/../scripting/script.html">scripts</a>, you can also store handles
to scene nodes and assign them in the editor.</p>
<p><a href="beginning/../animation/animation.html">Animation</a> is another place that stores handles to animated scene nodes.
<a href="beginning/../animation/blending.html">Animation Blending State Machine</a> stores its own state graph using a pool; it also takes
handles to animations from an animation player in a scene.</p>
<p>And the list could keep going for a long time. This is why you need to understand the basic concepts of data management, as to
efficiently and fearlessly use Fyrox.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>Once an object is placed in a pool, you have to use its respective handle to get a reference to it. This can
be done with either <code>pool.borrow(handle)</code> or <code>pool.borrow_mut(handle)</code>, or by using the <code>Index</code> trait: <code>pool[handle]</code>. Note that
these methods panic when the handle given is invalid. If you want to be safe, use the <code>try_borrow(handle)</code> or
<code>try_borrow_mut(handle)</code> method.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let obj = pool.borrow_mut(handle);
*obj = 11;

let obj = pool.borrow(handle);
assert_eq!(*obj, 11);
<span class="boring">}</span></code></pre></pre>
<h2 id="freeing"><a class="header" href="#freeing">Freeing</a></h2>
<p>You can extract an object from a pool by calling <code>pool.free(handle)</code>. This will give you the object back and make all current
handles to it invalid.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

pool.free(handle);

let obj = pool.try_borrow(handle);
assert_eq!(obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="take-and-reserve"><a class="header" href="#take-and-reserve">Take and Reserve</a></h2>
<p>Sometimes you may want to temporarily extract an object from a pool, do something with it, and then put it back, yet not want
to break every handle to the object in the process. There are three methods for this:</p>
<ol>
<li><code>take_reserve</code> + <code>try_take_reserve</code> - moves an object out of the pool but leaves the entry in an occupied state. This function returns a tuple with two values <code>(Ticket&lt;T&gt;, T)</code>. The latter one being your object, and the former one being a wrapper over its index that allows you to return the object once you're done with it. This is called a ticket. Note that attempting to borrow a moved object will cause a panic!</li>
<li><code>put_back</code> - moves the object back using the given ticket. The ticket contains information about where in the pool to return the object to.</li>
<li><code>forget_ticket</code> - makes the pool entry vacant again. Useful in cases where you move an object
out of the pool, and then decide you won't return it. If this is the case, you <strong>must</strong> call
this method, otherwise, the corresponding entry will remain unusable.</li>
</ol>
<p>Reservation example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let (ticket, ref mut obj) = pool.take_reserve(handle);

*obj = 123;

// Attempting to fetch while there is an existing reservation, will fail.

let attempt_obj = pool.try_borrow(handle);
assert_eq!(attempt_obj, None);

// Put the object back, allowing borrowing again.

pool.put_back(ticket, *obj);

let obj = pool.borrow(handle);

assert_eq!(obj, &amp;123);
<span class="boring">}</span></code></pre></pre>
<p>Forget example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let (ticket, _obj) = pool.take_reserve(handle);

pool.forget_ticket(ticket);

let obj = pool.try_borrow(handle);

assert_eq!(obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>There are a few possible iterators, each one serving its own purpose:</p>
<ol>
<li><code>iter/iter_mut</code> - creates an iterator over occupied pool entries, returning references to each object.</li>
<li><code>pair_iter/pair_iter_mut</code> - creates an iterator over occupied pool entries, returning tuples of a handle and reference
to each object.</li>
</ol>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let _handle = pool.spawn(1);

let mut iter = pool.iter_mut();

let next_obj = iter.next().unwrap();

assert_eq!(next_obj, &amp;1);

let next_obj = iter.next();

assert_eq!(next_obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="direct-access"><a class="header" href="#direct-access">Direct Access</a></h2>
<p>You have the ability to get an object from a pool using only an index. The methods for that are <code>at</code> and <code>at_mut</code>.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>To check if a handle is valid, you can use the <code>is_valid_handle</code> method.</p>
<h2 id="type-erased-handles"><a class="header" href="#type-erased-handles">Type-erased Handles</a></h2>
<p>The pool module also offers type-erased handles that can be of use in some situations. Still, try to avoid using these, as they may introduce hard-to-reproduce bugs. Type safety is always good :3</p>
<p>A type-erased handle is called an <code>ErasedHandle</code> and can be created either manually or from a strongly-typed handle.
Both handle types are interchangeable; you can use the <code>From</code> and <code>Into</code> traits to convert from one to the other.</p>
<h3 id="getting-a-handle-to-an-object-by-its-reference"><a class="header" href="#getting-a-handle-to-an-object-by-its-reference">Getting a Handle to an Object by its Reference</a></h3>
<p>If you need to get a handle to an object from only having a reference to it, you can use the <code>handle_of</code> method.</p>
<h3 id="iterate-over-and-filter-out-objects"><a class="header" href="#iterate-over-and-filter-out-objects">Iterate Over and Filter Out Objects</a></h3>
<p>The <code>retain</code> method allows you to filter your pool's content using a closure provided by you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow Checker</a></h1>
<p>Rust has a <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">famous borrow checker</a>, which has become a
sort of horror story for newcomers. It is often treated like an enemy that prevents you from writing anything
useful in the ways you may be used to in other languages. In fact, it is a very useful part of Rust that proves the correctness
of your program and prevents you from doing nasty things like <a href="https://en.wikipedia.org/wiki/Memory_corruption">memory corruption</a>,
<a href="https://en.wikipedia.org/wiki/Race_condition#Data_race">data races</a>, etc. This chapter explains how Fyrox solves
the most common borrowing issues and makes game development as easy as in any other game engine.</p>
<h2 id="multiple-borrowing"><a class="header" href="#multiple-borrowing">Multiple Borrowing</a></h2>
<p>When writing a script logic, there is often a need to do a multiple borrowing of some data, usually it is other scene
nodes. In normal circumstances, you can borrow each node one-by-one, but in other cases you can't do an action
without borrowing two or more nodes simultaneously. In this case, you can use multi-borrowing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct MyScript {
    some_node: Handle&lt;Node&gt;,
    some_other_node: Handle&lt;Node&gt;,
    yet_another_node: Handle&lt;Node&gt;,
}

impl ScriptTrait for MyScript {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Begin multiple borrowing.
        let mbc = ctx.scene.graph.begin_multi_borrow();

        // Borrow immutably.
        let some_node_ref_1 = mbc.try_get(self.some_node).unwrap();

        // Then borrow other nodes mutably.
        let some_other_node_ref = mbc.try_get_mut(self.some_other_node).unwrap();
        let yet_another_node_ref = mbc.try_get_mut(self.yet_another_node).unwrap();

        // We can borrow the same node immutably pretty much infinite number of times, if it wasn't
        // borrowed mutably.
        let some_node_ref_2 = mbc.try_get(self.some_node).unwrap();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, you can borrow multiple nodes at once with no compilation errors. Borrowing rules in this case
are enforced at runtime. They're the same as standard Rust borrowing rules:</p>
<ol>
<li>You can have infinite number of immutable references to the same object.</li>
<li>You can have only one mutable reference to the same object.</li>
</ol>
<p>Multi-borrow context provides detailed error messages for cases when borrowing has failed. For example, it will
tell you if you're trying to mutably borrow an object that is already borrowed as immutable (and vice versa).
It also provides handle validation and will tell you what's wrong with it. It could be either an invalid index
or generation. The latter means that the object at the handle was changed and therefore the handle is invalid.</p>
<p>The previous example looks kinda synthetic and does not show the real-world code that could lead to borrowing
issues. Let's fix this. Imagine that you're making a shooter, and that you have bots that can follow and attack
targets. Then the code could look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Bot {
    target: Handle&lt;Node&gt;,
    absm: Handle&lt;Node&gt;,
}

impl ScriptTrait for Bot {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Begin multiple borrowing.
        let mbc = ctx.scene.graph.begin_multi_borrow();

        // At first, borrow a node on which this script is running on.
        let this = mbc.get_mut(ctx.handle);

        // Try to borrow the target. It can fail in two cases:
        // 1) `self.target` is invalid or unassigned handle.
        // 2) A node is already borrowed, this could only happen if the bot have itself as the target.
        match mbc.try_get_mut(self.target) {
            Ok(target) =&gt; {
                // Check if we are close enough to target.
                let close_enough = target
                    .global_position()
                    .metric_distance(&amp;this.global_position())
                    &lt; 1.0;

                // Switch animations accordingly.
                let mut absm = mbc
                    .try_get_component_of_type_mut::&lt;AnimationBlendingStateMachine&gt;(self.absm)
                    .unwrap();
                absm.machine_mut()
                    .get_value_mut_silent()
                    .set_parameter("Attack", Parameter::Rule(close_enough));
            }
            Err(err) =&gt; {
                // Optionally, you can print the actual reason why borrowing wasn't successful.
                Log::err(err.to_string())
            }
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, for this code to compile we need to borrow at least two nodes simultaneously: the node with <code>Bot</code>
script and the <code>target</code> node. This is because we're calculating distance between the two nodes to switch
animations accordingly (attack if the target is close enough).</p>
<p>As with pretty much any approach, this one is not ideal and comes with its own pros and cons. The pros are quite
simple:</p>
<ul>
<li>No compilation errors - sometimes Rust is too strict about borrowing rules, and valid code does not pass its
checks.</li>
<li>Better ergonomics - no need to juggle with temporary variable here and there to perform an action.</li>
</ul>
<p>The cons are:</p>
<ul>
<li>Multi-borrowing is slightly slower (~1-4% depending on your use case) - this happens because the
multi-borrowing context checks borrowing rules at runtime.</li>
</ul>
<h2 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h2>
<p>Sometimes the code becomes so convoluted that it is hard to maintain and understand what it is doing.
This happens when code coupling gets to a certain point, which requires very broad context for the code to
be executed. For example, if bots in your game have weapons it is so tempting to just borrow the weapon
and call something like <code>weapon.shoot(..)</code>. When your weapon is simple, then it might work fine. However, when
your game gets bigger and weapons get new features, a simple <code>weapon.shoot(..)</code> might be not enough. It could be
because the <code>shoot</code> method gets more and more arguments or some other reason. This is quite common. In
general, when your code becomes tightly coupled, it becomes hard to maintain it, and, more importantly, can
easily result in issues with the borrow checker. To illustrate this, let's look at
this code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Weapon {
    bullets: u32,
}

impl Weapon {
    fn shoot(&amp;mut self, self_handle: Handle&lt;Node&gt;, graph: &amp;mut Graph) {
        if self.bullets &gt; 0 {
            let this = &amp;graph[self_handle];
            let position = this.global_position();
            let direction = this.look_vector().scale(10.0);

            // Cast a ray in front of the weapon.
            let mut results = Vec::new();
            graph.physics.cast_ray(
                RayCastOptions {
                    ray_origin: position.into(),
                    ray_direction: direction,
                    max_len: 10.0,
                    groups: Default::default(),
                    sort_results: false,
                },
                &amp;mut results,
            );

            // Try to damage all the bots that were hit by the ray.
            for result in results {
                for node in graph.linear_iter_mut() {
                    if let Some(bot) = node.try_get_script_mut::&lt;Bot&gt;() {
                        if bot.collider == result.collider {
                            bot.health -= 10.0;
                        }
                    }
                }
            }

            self.bullets -= 1;
        }
    }
}

impl ScriptTrait for Weapon {}

#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Bot {
    weapon: Handle&lt;Node&gt;,
    collider: Handle&lt;Node&gt;,
    health: f32,
}

impl ScriptTrait for Bot {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Try to shoot the weapon.
        if let Some(weapon) = ctx
            .scene
            .graph
            .try_get_script_component_of_mut::&lt;Weapon&gt;(self.weapon)
        {
            // !!! This will not compile, because it requires mutable access to the weapon and to
            // the script context at the same time. This is impossible to do safely, because we've
            // just borrowed the weapon from the context.

            // weapon.shoot(ctx.handle, &amp;mut ctx.scene.graph);
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>This is probably one of the typical implementations of shooting in games - you cast a ray from the weapon
and if it hits a bot, you apply some damage to it. In this case, bots can also shoot, and this is where
borrow checker again gets in our way. If you try to uncomment the
<code>// weapon.shoot(ctx.handle, &amp;mut ctx.scene.graph);</code> line, you'll get a compilation error that tells you that
<code>ctx.scene.graph</code> is already borrowed. It seems like we are stuck, and we need to somehow fix this issue.
We can't use multi-borrowing in this case because it still enforces borrowing rules and instead of compilation
error, you'll runtime error.</p>
<p>To solve this, you can use the well-known message passing mechanism. The core idea is to not call methods
immediately, but to collect all the needed data for the call and send it an object, so it can do the call later.
Here's how it will look:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Weapon {
    bullets: u32,
}

impl Weapon {
    fn shoot(&amp;mut self, self_handle: Handle&lt;Node&gt;, graph: &amp;mut Graph) {
        // -- This method is the same
    }
}

#[derive(Debug)]
pub struct ShootMessage;

impl ScriptTrait for Weapon {
    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Subscribe to shooting message.
        ctx.message_dispatcher
            .subscribe_to::&lt;ShootMessage&gt;(ctx.handle);
    }

    fn on_message(
        &amp;mut self,
        message: &amp;mut dyn ScriptMessagePayload,
        ctx: &amp;mut ScriptMessageContext,
    ) {
        // Receive shooting messages.
        if message.downcast_ref::&lt;ShootMessage&gt;().is_some() {
            self.shoot(ctx.handle, &amp;mut ctx.scene.graph);
        }
    }
}

#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Bot {
    weapon: Handle&lt;Node&gt;,
    collider: Handle&lt;Node&gt;,
    health: f32,
}

impl ScriptTrait for Bot {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Note, that we know nothing about the weapon here - just its handle and a message that it
        // can accept and process.
        ctx.message_sender.send_to_target(self.weapon, ShootMessage);
    }
}

<span class="boring">}</span></code></pre></pre>
<p>The weapon now subscribes to <code>ShootMessage</code> and listens to it in <code>on_message</code> method and from there it can
perform the actual shooting without any borrowing issues. The bot now just sends the <code>ShootMessage</code> instead of
borrowing the weapon trying to call <code>shoot</code> directly. The messages do not add any one-frame delay as you might
think, they're processed in the same frame, so there's no one-or-more frames desynchronization.</p>
<p>This approach with messages has its own pros and cons. The pros are quite significant:</p>
<ul>
<li>Decoupling - coupling is now very loose and done mostly on the message side.</li>
<li>Easy to refactor - since the coupling is loose, you can refactor the internals with a low chance of breaking
existing code, that could otherwise be done because of intertwined and convoluted code.</li>
<li>No borrowing issues - the method calls are done in different places and thus there are no lifetime collisions.</li>
<li>Easy to write unit and integration tests - this comes from loose coupling.</li>
</ul>
<p>The cons are the following:</p>
<ul>
<li>Message passing is slightly slower than direct method calls (~1-7% depending on your use case) - you should
keep message granularity at a reasonable level. Do not use message passing for tiny changes, as it will most likely make
your game slower.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-manager-1"><a class="header" href="#project-manager-1">Project Manager</a></h1>
<p>This chapter explains how to use various parts of the project manager, what it can do in general, and why you should
prefer it over good ol' console commands.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><img src="beginning/project_manager.png" alt="project manager" /></p>
<p>Project manager is a tool that is able to create projects, import existing projects, configure and build them, etc. Its
main purpose is to reduce the complexity of project management to the minimum. For example, a new project can be created
and built in a few clicks. While the same is possible to be done manually, it requires some juggling with console commands
that in some cases (code hot reloading) contains a lot of unexpected parts.</p>
<h2 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a New Project</a></h2>
<p>To create a new project simply click on <code>+Create</code> button, and you should see the following window:</p>
<p><img src="beginning/pm_create_project.png" alt="project manager wizard" /></p>
<p>This window contains four major options for your project:</p>
<ul>
<li><code>Path</code> - specifies a parent directory in which a project's directory will be created and then filled with the
project's files.</li>
<li><code>Name</code> - project name, it must follow specific rules. The name must start either from a letter or underscore (<code>_</code>),
the rest of the characters must be letters, numbers, hyphens (<code>-</code>), underscore (<code>_</code>). The project manager performs
name validation for you:</li>
</ul>
<p><img src="beginning/pm_validation.png" alt="project manager name validation" /></p>
<ul>
<li><code>Style</code> - defines initial content of the default scene. In general, it does not restrict you to a specific number
of dimensions—you can still use both 2D and 3D or mix them.</li>
<li><code>Version Control</code> - allows you to select a desired version control system (VCS) for your project. It is Git by default,
but you can select any VCS you like or disable it completely by selecting <code>None</code> option.</li>
</ul>
<p>Every project has its own item in the list of projects, it shows important information about the project:</p>
<p><img src="beginning/pm_project_info.png" alt="project info" /></p>
<ol>
<li>Project name.</li>
<li>Full path to the project.</li>
<li>Version of the engine the project uses.</li>
<li>Code hot reloading marker.</li>
</ol>
<h2 id="project-management"><a class="header" href="#project-management">Project Management</a></h2>
<p><img src="beginning/pm_management.png" alt="project management" /></p>
<p>When a project is selected, it is possible to manage it using the toolbar on the right side. The available options
are the following:</p>
<ul>
<li><code>Hot Reloading</code> - allows you to enable or disable code hot reloading. Code hot reloading is a handy feature
for rapid prototyping. See <a href="beginning/./hot_reloading.html">the respective chapter</a> for more info.</li>
<li><code>Edit</code> - builds and runs the editor.</li>
<li><code>Run</code> - builds and runs the game. Final builds of the game should be produced using the project exporter tool of the
editor. See <a href="beginning/../shipping/shipping.html">the respective chapter</a> for more info.</li>
<li><code>Open IDE</code> - opens the specified IDE to edit the project's source code.</li>
<li><code>Upgrade</code> - opens a separate tool that allows you to select a desired engine version. See
<a href="beginning/project_manager.html#project-upgrade">the section below</a> for more info.</li>
<li><code>Clean</code> - removes all build artifacts from the project. Essentially it just runs <code>cargo clean</code> command for your project.</li>
<li><code>Locate</code> - opens the project directory in the file system explorer.</li>
<li><code>Delete</code> - deletes the project. This is a destructive operation, and it is "gated" with a separate confirmation dialog.</li>
<li><code>Exclude</code> - removes the project from the list of projects.</li>
</ul>
<h2 id="project-upgrade"><a class="header" href="#project-upgrade">Project Upgrade</a></h2>
<p><img src="beginning/pm_upgrade.png" alt="project manager upgrade" /></p>
<p>This tiny tool allows you to select a desired version of the engine in a few clicks. Available options are the following:</p>
<ul>
<li><code>Specific</code> - specific version of the engine. The version must comply with semver rules (for example - <code>0.36.0</code>).</li>
<li><code>Nightly</code> - latest possible <em>potentially unstable</em> version of the engine directly from the development branch (<code>master</code>)
of the <a href="https://github.com/FyroxEngine/Fyrox">GitHub repo</a>. Use it if you need latest features and bugfixes.</li>
<li><code>Local</code> - special option that allows you to switch the engine to local copy of the engine repository. The engine must
be located in the parent folder of your project's directory.</li>
</ul>
<h2 id="settings"><a class="header" href="#settings">Settings</a></h2>
<p><img src="beginning/pm_settings.png" alt="project manager settings" /></p>
<p>Project manager has its own settings, it is not much for now, but it will grow over time. Currently, there's only one
option—an IDE that can be used to edit source code of your project.</p>
<p>All that you need to is to specify a name of the executable of your IDE. The image above uses <code>RustRover</code> IDE. Keep in
mind, that you must modify your <code>PATH</code> environment variable to include full path to the specified executable, otherwise
this option will not work correctly!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-hot-reloading"><a class="header" href="#code-hot-reloading">Code Hot Reloading</a></h1>
<p>Fyrox supports code hot reloading (CHR for short), which allows you to recompile the game code while the game is running.
This functionality significantly reduces iteration times and allows rapid prototyping. This way, Rust becomes a sort of
"scripting" language, but with all Rust safety and performance guarantees. CHR in action looks like this:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/vq6P3Npydmw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="how-to-use"><a class="header" href="#how-to-use">How To Use</a></h2>
<blockquote>
<p>⚠️ If you have an existing project from one of the previous versions of the engine, the best way to add support for
CHR is to re-generate the entire project and copy all the assets and game code in the new project. CHR requires very
specific project structure and a small mistake in it could lead to incorrect behavior.</p>
</blockquote>
<p>CHR is quite simple to use - a project generated by the project manager or <code>fyrox-template</code> already has all that is
needed for hot reloading. There are two ways of enabling hot reloading support—using the project manager and doing
the same manually using console commands.</p>
<h3 id="project-manager-2"><a class="header" href="#project-manager-2">Project Manager</a></h3>
<p>The easiest way of enabling hot reloading support is to simply click on <code>Hot Reloading</code> checkbox in the project
manager and click <code>Edit</code> or <code>Run</code>:</p>
<p><img src="beginning/project_manager_hot_reloading.png" alt="project manager hot reloading" /></p>
<p>Note the small "fire" icon, it means that the project has this feature turned on. You can enable or disable it at any
time.</p>
<h3 id="console-commands"><a class="header" href="#console-commands">Console Commands</a></h3>
<p>Doing the same via console commands requires some bootstrapping. At first, you need to compile your game plugin using the following
command:</p>
<pre><code class="language-shell">RUSTFLAGS="-C prefer-dynamic=yes" cargo build --package game_dylib --no-default-features --features="dylib-engine" --profile dev-hot-reload
</code></pre>
<p>This command will compile the engine DLL (<code>fyrox_dylib.dll/so</code>) and the plugin DLL (<code>game_dylib.dll/so</code>). Please note the
mandatory environment variable <code>RUSTFLAGS="-C prefer-dynamic=yes"</code>. It forces the compiler to link the standard library
dynamically. It is crucial because if not set, the standard library will be duplicated in game plugin and engine,
which will lead to subtle bugs.</p>
<blockquote>
<p>⚠️ Environment variables can be set in a different ways, depending on your OS. On Linux it simply prepends the actual
command, on Windows it requires a <a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/set_1#examples">separate command</a>.
Other OSes can have their own ways of setting environment variables.</p>
</blockquote>
<p>The next step is to compile the editor in CHR mode. To do that, run the following command:</p>
<pre><code class="language-shell">RUSTFLAGS="-C prefer-dynamic=yes" cargo run --package editor --no-default-features --features="dylib" --profile dev-hot-reload
</code></pre>
<p>This command will compile the editor in CHR mode and run it. After this, all you need to do is to select build profile
in the editor to be <code>Debug (HR)</code>:</p>
<p><img src="beginning/build_profile.png" alt="img.png" /></p>
<p>Once that's done you can run your game by clicking on the green <code>Play</code> button. You can switch between CHR and normal mode
(static linking) at any time. Keep in mind that if you run the editor in CHR mode, it will also reload all changed plugins.</p>
<h2 id="build-profiles"><a class="header" href="#build-profiles">Build Profiles</a></h2>
<p>CHR uses separate build profiles: <code>dev-hot-reload</code> (no optimizations) and <code>release-hot-reload</code> (with optimizations).
Separate build profiles allow you to quickly switch between statically linked plugins and code hot reloading. This could
be useful if you're experiencing some issues with hot reloading (see next section for more info).</p>
<h2 id="stability"><a class="header" href="#stability">Stability</a></h2>
<p>CHR is a very new and experimental feature of the engine. It is based on wildly unsafe functionality which could result
in memory corruption, subtle bugs, etc. If you experience weird behavior of your game after hot reloading, run the
game in normal (static linking) mode instead. Please report any bugs in the <a href="https://github.com/FyroxEngine/Fyrox/issues">issue tracker</a>
of the engine. CHR was tested on two relatively large games - <a href="https://github.com/mrDIMAS/FishFolly">Fish Folly</a> and
<a href="https://github.com/mrDIMAS/StationIapetus">Station Iapetus</a>. You can download these projects and try CHR yourself.</p>
<h2 id="technical-details-and-limitations"><a class="header" href="#technical-details-and-limitations">Technical Details and Limitations</a></h2>
<p>CHR is using the standard operating system (OS) mechanism of shared libraries (DLL for short). Pretty much any OS can load
native code into a running process dynamically from a DLL. Any dynamically loaded library can then be unloaded from the
process memory. This gives a perfect opportunity to reload game code in runtime. It may sound quite easy, but in practice,
there are a lot of issues.</p>
<h3 id="plugin-entities-and-reloading"><a class="header" href="#plugin-entities-and-reloading">Plugin Entities and Reloading</a></h3>
<p>Plugins can supply the engine with a predefined set of entities (such as scripts, etc.). These entities are serialized into
a memory blob before the plugin itself is unloaded. When all plugins are reloaded, this memory blob is used to restore
the state of plugin entities. That being said, pretty much all the plugin entities must be serializable (implement <code>Visit</code> trait).</p>
<h3 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects</a></h3>
<p>Trait objects are very problematic with hot reloading, because internally trait objects contain vtable with function
pointers. These pointers can be easily invalidated if the plugin is unloaded. This applies even to engine trait objects
if they're created directly from the plugin side. The only way to bypass this issue is to use special methods from the
engine to create its trait objects. It is possible to add a lint to clippy to check for such cases (see the respective
<a href="https://github.com/rust-lang/rust-clippy/issues/12819">issue</a>).</p>
<h3 id="dangling-objects"><a class="header" href="#dangling-objects">Dangling Objects</a></h3>
<p>The current plugin system tries its best to remove all plugin entities from the engine internals before reloading plugins.
However, some objects could be overlooked by this system, which could result in crash or memory corruption. The current<br />
approach of preventing from having dangling objects is based on the built-in reflection system—the plugin system iterates
across all fields of every object and checks its assembly name. If the assembly name matches the plugin's assembly name,
then this object must be deleted before the plugin is unloaded.</p>
<h3 id="non-serializable-entities"><a class="header" href="#non-serializable-entities">Non-serializable Entities</a></h3>
<p>Not every object can be serialized, and in this case, the current plugin system calls a special method to restore such
non-serializable entities after hot reloading. Such entities could include server connections, job queues, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-logic"><a class="header" href="#game-logic">Game Logic</a></h1>
<p>A game based on Fyrox is a plugin to the engine and the editor. The plugin defines global application logic and can provide
a set of scripts, that can be used to assign custom logic to scene nodes. Every script can be attached to only one
plugin. All of these entities "live" in the engine, which is initialized from one of platform-specific executors. It
is some sort of OS-dependent entry point of your game. Read the <a href="scripting/executor.html">respective chapter</a> for more info.</p>
<p>Fyrox uses scripts to create custom game logic, scripts can be written only in Rust which ensures that your game will
be crash-free, fast and easy to refactor.</p>
<p>The overall structure of plugins and scripts could be described in this diagram:</p>
<p><img src="scripting/structure.svg" alt="structure" /></p>
<p>The next chapters will cover all parts and will help you to learn how to use plugins and scripts correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins-1"><a class="header" href="#plugins-1">Plugins</a></h1>
<p>A game based on Fyrox is a plugin to the engine and the editor. Plugin defines global application logic and provides
a set of scripts, that can be used to assign custom logic to scene nodes.</p>
<p>Plugin is an "entry point" of your game, it has a fixed set of methods that can be used for initialization, update,
OS event handling, etc. Every plugin could be linked to the engine (and the editor) in two ways: statically or dynamically
using hot reloading. <a href="scripting/../beginning/hot_reloading.html">Code hot reloading</a> is usually used for development purposes only.</p>
<p>The main purpose of the plugins is to hold and operate on some global application data, that can be used in scripts and
provide a set of scripts to the engine. Plugins also have much wider access to engine internals, than scripts. For example,
it is possible to change scenes, add render passes, change resolution, etc. which is not possible from scripts.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Plugin structure is defined by <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">Plugin</a> trait. Typical implementation can be generated by <code>fyrox-template</code> tool,
and it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
pub struct Game {
    scene: Handle&lt;Scene&gt;,
}

impl Game {
    pub fn new(scene_path: Option&lt;&amp;str&gt;, context: PluginContext) -&gt; Self {
        context
            .async_scene_loader
            .request(scene_path.unwrap_or("data/scene.rgs"));

        Self {
            scene: Handle::NONE,
        }
    }
}

impl Plugin for Game {
    fn register(&amp;self, context: PluginRegistrationContext) {
        // Register scripts here.
    }

    fn register_property_editors(&amp;self) -&gt; PropertyEditorDefinitionContainer {
        // Register custom property editors for the editor here.
        PropertyEditorDefinitionContainer::empty()
    }

    fn init(&amp;mut self, scene_path: Option&lt;&amp;str&gt;, context: PluginContext) {
        // Do initialization logic here. Usually it just requests a scene:
        context
            .async_scene_loader
            .request(scene_path.unwrap_or("data/scene.rgs"));
    }

    fn on_loaded(&amp;mut self, context: PluginContext) {
        // For hot reloading only! Only for development.
        // Re-initialize non-serializable data.
    }

    fn on_deinit(&amp;mut self, _context: PluginContext) {
        // Do a cleanup here.
    }

    fn update(&amp;mut self, _context: &amp;mut PluginContext) {
        // Add your global update code here.
    }

    fn on_os_event(&amp;mut self, _event: &amp;Event&lt;()&gt;, _context: PluginContext) {
        // Do something on OS event here.
    }

    fn on_graphics_context_initialized(&amp;mut self, context: PluginContext) {
        // Executed when graphics context was initialized.
    }

    fn before_rendering(&amp;mut self, context: PluginContext) {
        // Executed before rendering begins.
    }

    fn on_graphics_context_destroyed(&amp;mut self, context: PluginContext) {
        // Executed when graphics context was destroyed.
    }

    fn on_ui_message(&amp;mut self, _context: &amp;mut PluginContext, _message: &amp;UiMessage) {
        // Handle UI events here.
    }

    fn on_scene_begin_loading(&amp;mut self, path: &amp;Path, context: &amp;mut PluginContext) {
        // Handle started scene loading here.
    }

    fn on_scene_loaded(
        &amp;mut self,
        _path: &amp;Path,
        scene: Handle&lt;Scene&gt;,
        data: &amp;[u8],
        context: &amp;mut PluginContext,
    ) {
        if self.scene.is_some() {
            context.scenes.remove(self.scene);
        }

        self.scene = scene;
    }

    fn on_scene_loading_failed(
        &amp;mut self,
        path: &amp;Path,
        error: &amp;VisitError,
        context: &amp;mut PluginContext,
    ) {
        // Handle failed scenes here.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, the game structure (<code>struct Game</code>) implements a bunch of traits.</p>
<ul>
<li><code>Reflect</code> - is needed for static reflection to inspect the content of the plugin.</li>
<li><code>Visit</code> - is mostly needed for hot reloading, to save/load the content of the plugin.</li>
<li><code>Default</code> - provides sensible default state of the game.</li>
</ul>
<p><code>Plugin</code> trait is very special - it can execute the actual game logic in one of its methods:</p>
<ul>
<li><code>register</code> - called once on start allowing you to register your scripts. <strong>Important:</strong> You must register all your
scripts here, otherwise the engine (and the editor) will know nothing about them. Also, you should register loaders for
your custom resources here. See <a href="scripting/../resources/custom.html">Custom Resource chapter</a> more info.</li>
<li><code>init</code> - called once when the plugin registers in the engine. This method allows you to initialize the game into some
sensible state. Keep in mind, that the editor will <strong>not</strong> call this method, it does not create any game instance. The method
has <code>scene_path</code> parameter, in short it is a path to a scene that is currently opened in the editor (it will be <code>None</code>
if either there's no opened scene or your game was started outside the editor). It is described in
<a href="scripting/plugin.html#editor-and-plugins">Editor and Plugins</a> section down below.</li>
<li><code>on_deinit</code> - it is called when the game is about to shut down. Can be used for any clean up, for example logging that
the game has closed.</li>
<li><code>update</code> - it is called each frame at a stable rate (usually 60 Hz, but can be configured in the Executor) after the
plugin is created and fully initialized. It is the main place where you should put <em>object-independent</em> game logic (such
as user interface handling, global application state management, etc.), any other logic should be added via scripts.</li>
<li><code>on_os_event</code> - it is called when the main application window receives an event from the operating system, it can be
any event such as keyboard, mouse, game pad events or any other events. Please note that as for <code>update</code> method, you
should put here only <em>object-independent</em> logic. Scripts can catch OS events too.</li>
<li><code>on_ui_message</code> - it is called when there is a message from the user interface, it should be used to react to user
actions (like pressed buttons, etc.)</li>
<li><code>on_graphics_context_initialized</code> - it is called when a graphics context was successfully initialized. This method could
be used to access the renderer (to change its quality settings, for instance). You can also access a main window instance
and change its properties (such as title, size, resolution, etc.).</li>
<li><code>on_graphics_context_destroyed</code> - it is called when the current graphics context was destroyed. It could happen on a
small number of platforms, such as Android. Such platforms usually have some sort of suspension mode, in which you are
not allowed to render graphics, to have a "window", etc.</li>
<li><code>before_rendering</code> - it is called when the engine is about to render a new frame. This method is useful to perform
offscreen rendering (for example - <a href="scripting/../ui/rendering.html#offscreen-rendering">user interface</a>).</li>
<li><code>on_scene_begin_loading</code> - it is called when the engine starts to load a game scene. This method could be used to
show a progress bar or some sort of loading screen, etc.</li>
<li><code>on_scene_loaded</code> - it is called when the engine successfully loaded a game scene. This method could be used to add
custom logic to do something with a newly loaded scene.</li>
</ul>
<h2 id="plugin-context"><a class="header" href="#plugin-context">Plugin Context</a></h2>
<p>Vast majority of methods accept <code>PluginContext</code> - it provides almost full access to engine entities, it has access
to the renderer, scenes container, resource manager, user interface, main application window. Typical content of the
context is something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PluginContext&lt;'a, 'b&gt; {
    pub scenes: &amp;'a mut SceneContainer,
    pub resource_manager: &amp;'a ResourceManager,
    pub user_interfaces: &amp;'a mut UiContainer,
    pub graphics_context: &amp;'a mut GraphicsContext,
    pub dt: f32,
    pub lag: &amp;'b mut f32,
    pub serialization_context: &amp;'a Arc&lt;SerializationContext&gt;,
    pub widget_constructors: &amp;'a Arc&lt;WidgetConstructorContainer&gt;,
    pub performance_statistics: &amp;'a PerformanceStatistics,
    pub elapsed_time: f32,
    pub script_processor: &amp;'a ScriptProcessor,
    pub async_scene_loader: &amp;'a mut AsyncSceneLoader,
    pub loop_controller: ApplicationLoopController&lt;'b&gt;,
    pub task_pool: &amp;'a mut TaskPoolHandler,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>scenes</code> - a scene container, could be used to manage game scenes - add, remove, borrow. An example of scene loading
is given in the previous code snippet in <code>Game::new()</code> method.</li>
<li><code>resource_manager</code> - is used to load external resources (scenes, models, textures, animations, sound buffers, etc.) from
different sources (disk, network storage on WebAssembly, etc.)</li>
<li><code>user_interfaces</code> - use it to create user interface for your game, the interface is scene-independent and will remain
the same even if there are multiple scenes created. There's always at least one user interface created, it can be accessed
using <code>.first()/first_mut()</code> methods. The engine support unlimited instances of user interfaces.</li>
<li><code>graphics_context</code> - a reference to the graphics_context, it contains a reference to the window and the current renderer.
It could be <code>GraphicsContext::Uninitialized</code> if your application is suspended (possible only on Android).</li>
<li><code>dt</code> - a time passed since the last frame. The actual value is implementation-defined, but on current implementation it
is equal to 1/60 of a second and does not change event if the frame rate is changing (the engine stabilizes update rate
for the logic).</li>
<li><code>lag</code> - a reference to the time accumulator, that holds remaining amount of time that should be used to update a plugin.
A caller splits <code>lag</code> into multiple sub-steps using <code>dt</code> and thus stabilizes update rate. The main use of this variable,
is to be able to reset <code>lag</code> when you're doing some heavy calculations in a game loop (i.e. loading a new level) so the
engine won't try to "catch up" with all the time that was spent in heavy calculation.</li>
<li><code>serialization_context</code> - it can be used to register scripts and custom scene nodes constructors at runtime.</li>
<li><code>widget_constructors</code> - it can be used to register custom widgets.</li>
<li><code>performance_statistics</code> - performance statistics from the last frame. To get a rendering performance statistics, use
<code>Renderer::get_statistics</code> method, that could be obtained from the renderer instance in the current graphics context.</li>
<li><code>elapsed_time</code> - amount of time (in seconds) that passed from creation of the engine. Keep in mind, that this value
is <strong>not</strong> guaranteed to match real time. A user can change delta time with which the engine "ticks" and this delta time
affects elapsed time.</li>
<li><code>script_processor</code> - a reference to the current script processor instance, which could be used to access a list of
scenes that supports scripts.</li>
<li><code>async_scene_loader</code> - a reference to the current asynchronous scene loader instance. It could be used to request
a new scene to be loaded.</li>
<li><code>window_target</code> - special field that associates main application event loop (not game loop) with OS-specific windows.
It also can be used to alternate control flow of the application.</li>
<li><code>task_pool</code> - task pool for asynchronous task management.</li>
</ul>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>Plugin context provides access to a special variable <code>window_target</code>, which could be used to alternate control flow of
the application. The most common use of it is to close the game by calling <code>window_target.unwrap().exit()</code> method.
Notice the <code>unwrap()</code> here, <code>window_target</code> could not be available at all times. Ideally you should do checked access here.</p>
<h2 id="editor-and-plugins"><a class="header" href="#editor-and-plugins">Editor and Plugins</a></h2>
<p>When you're running your game from the editor, it starts the game as a separate process and if there's a scene opened
in the editor, it tells the game instance to load it on startup. Let's look closely at <code>Plugin::init</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn init(&amp;mut self, scene_path: Option&lt;&amp;str&gt;, context: PluginContext) {
        // Do initialization logic here. Usually it just requests a scene:
        context
            .async_scene_loader
            .request(scene_path.unwrap_or("data/scene.rgs"));
    }
<span class="boring">}</span></code></pre></pre>
<p>The <code>scene_path</code> parameter is a path to a scene that is currently opened in the editor, your game should use it if you
need to load a currently selected scene of the editor in your game. However, it is not strictly necessary - you may
desire to start your game from a specific scene all the time, even when the game starts from the editor. If the parameter
is <code>None</code>, then there is no scene loaded in the editor or the game was run outside the editor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts-2"><a class="header" href="#scripts-2">Scripts</a></h1>
<p>Script - is a container for game data and logic that can be assigned to a scene node. Fyrox uses Rust for scripting,
so scripts are as fast as native code. Every scene node can have any number of scripts assigned.</p>
<h2 id="when-to-use-scripts-and-when-not"><a class="header" href="#when-to-use-scripts-and-when-not">When to Use Scripts and When Not</a></h2>
<p>Scripts are meant to be used to add data and some logic to scene nodes. That being said, you should not use scripts
to hold some global state of your game (use your game plugin for that). For example, use scripts for your game items,
bots, player, level, etc. On the other hand <strong>do not</strong> use scripts for leader boards, game menus, progress information,
etc.</p>
<p>Also, scripts cannot be assigned to UI widgets due to intentional Game &lt;-&gt; UI decoupling reasons. All user interface
components should be created and handled in the game plugin of your game.</p>
<h2 id="script-structure"><a class="header" href="#script-structure">Script Structure</a></h2>
<p>Typical script structure is something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Default, Debug, Clone, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "bf0f9804-56cb-4a2e-beba-93d75371a568")]
#[visit(optional)]
struct MyScript {
    // Add fields here.
}

impl ScriptTrait for MyScript {
    fn on_init(&amp;mut self, context: &amp;mut ScriptContext) {
        // Put initialization logic here.
    }

    fn on_start(&amp;mut self, context: &amp;mut ScriptContext) {
        // Put start logic - it is called when every other script is already initialized.
    }

    fn on_deinit(&amp;mut self, context: &amp;mut ScriptDeinitContext) {
        // Put de-initialization logic here.
    }

    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: &amp;mut ScriptContext) {
        // Respond to OS events here.
    }

    fn on_update(&amp;mut self, context: &amp;mut ScriptContext) {
        // Put object logic here.
    }

    fn on_message(
        &amp;mut self,
        message: &amp;mut dyn ScriptMessagePayload,
        ctx: &amp;mut ScriptMessageContext,
    ) {
        // See "message passing" section below.
    }
}

#[derive(Visit, Reflect, Debug)]
struct MyPlugin;

impl Plugin for MyPlugin {
    fn register(&amp;self, context: PluginRegistrationContext) {
        context
            .serialization_context
            .script_constructors
            .add::&lt;MyScript&gt;("My Script");
    }
}

fn add_my_script(node: &amp;mut Node) {
    node.add_script(MyScript::default())
}
<span class="boring">}</span></code></pre></pre>
<p>Each script must implement following traits:</p>
<ul>
<li><code>Visit</code> implements serialization/deserialization functionality, it is used by the editor to save your object to a
scene file.</li>
<li><code>Reflect</code> implements compile-time reflection that provides a way to iterate over script fields, set their values,
find fields by their paths, etc.</li>
<li><code>Debug</code> - provides debugging functionality, it is mostly for the editor to let it turn the structure and its fields
into string.</li>
<li><code>Clone</code> - makes your structure clone-able, since we can clone objects, we also want the script instance to be
cloned.</li>
<li><code>Default</code> implementation is very important - the scripting system uses it to create your scripts in the default state.
This is necessary to set some data to it and so on. If it's a special case, you can always implement your own <code>Default</code>'s
implementation if it's necessary for your script.</li>
<li><code>TypeUuidProvider</code> is used to attach some unique id for your type, every script <strong>must</strong> have a unique ID, otherwise,
the engine will not be able to save and load your scripts. To generate a new UUID, use
<a href="https://www.uuidgenerator.net/">Online UUID Generator</a> or any other tool that can generate UUIDs.</li>
<li><code>ComponentProvider</code> - gives access to inner fields of the script marked with <code>#[component(include)]</code> attribute.</li>
</ul>
<p><code>#[visit(optional)]</code> attribute is used to suppress serialization errors when some fields are missing or changed.</p>
<h2 id="script-template-generator"><a class="header" href="#script-template-generator">Script Template Generator</a></h2>
<p>You can use <code>fyrox-template</code> tool to generate all required boilerplate code for a new script, it makes adding new scripts
much less tedious. To generate a new script use <code>script</code> command:</p>
<pre><code class="language-shell">fyrox-template script --name MyScript
</code></pre>
<p>It will create a new file in <code>game/src</code> directory with <code>my_script.rs</code> name and fill with required code. Do not forget
to add the module with the new script to <code>lib.rs</code> like this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use your script name instead of `my_script` here.
pub mod my_script;
<span class="boring">}</span></code></pre></pre>
<p>Comments in each generated method should help you to figure out which code should be placed where and what is the purpose
of every method.</p>
<blockquote>
<p>⚠️ Keep in mind that every new script must be registered in <code>PluginConstructor::register</code>, otherwise you won't be able
to assign the script in the editor to a node. See the next section for more info.</p>
</blockquote>
<h2 id="script-registration"><a class="header" href="#script-registration">Script Registration</a></h2>
<p>Every script must be registered before use, otherwise the engine won't "see" your script and won't let you assign it
to an object. <code>PluginConstructor</code> trait has <code>register</code> method exactly for script registration. To register a script
you need to register it in the list of script constructors like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct MyPlugin;

impl Plugin for MyPlugin {
    fn register(&amp;self, context: PluginRegistrationContext) {
        context
            .serialization_context
            .script_constructors
            .add::&lt;MyScript&gt;("My Script");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Every script type (<code>MyScript</code> in the code snippet above, you need to change it to your script type) must be registered using
<a href="https://docs.rs/fyrox/latest/fyrox/script/constructor/struct.ScriptConstructorContainer.html#method.add">ScriptConstructorsContainer::add</a>
method, which accepts a script type as a generic argument and its name, that will be shown in the editor. The name can be
arbitrary, it is used only in the editor. You can also change it at any time, it won't break existing scenes.</p>
<h2 id="script-attachment"><a class="header" href="#script-attachment">Script Attachment</a></h2>
<p>To assign a script and see it in action, run the editor, select an object and find <code>Scripts</code> property in the Inspector.
Click on a small <code>+</code> button and select your script from the drop-down list on the newly added entry. To see the script
in action, click "Play/Stop" button. The editor will run your game in separate process with the scene active in the editor.</p>
<p>The script can be attached to a scene node from code:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_my_script(node: &amp;mut Node) {
    node.add_script(MyScript::default())
}
<span class="boring">}</span></code></pre></pre>
<p>Initialization as well as update of newly assigned script will happen on next update tick of the engine.</p>
<h2 id="script-context"><a class="header" href="#script-context">Script Context</a></h2>
<p>Script context provides access to the environment that can be used to modify engine and game state from scripts. Typical
content of the context is something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ScriptContext&lt;'a, 'b, 'c&gt; {
    pub dt: f32,
    pub elapsed_time: f32,
    pub plugins: PluginsRefMut&lt;'a&gt;,
    pub handle: Handle&lt;Node&gt;,
    pub scene: &amp;'b mut Scene,
    pub scene_handle: Handle&lt;Scene&gt;,
    pub resource_manager: &amp;'a ResourceManager,
    pub message_sender: &amp;'c ScriptMessageSender,
    pub message_dispatcher: &amp;'c mut ScriptMessageDispatcher,
    pub task_pool: &amp;'a mut TaskPoolHandler,
    pub graphics_context: &amp;'a mut GraphicsContext,
    pub user_interfaces: &amp;'a mut UiContainer,
    pub script_index: usize,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>dt</code> - amount of time passed since last frame. The value of the variable is implementation-defined, usually it is
something like 1/60 (0.016) of a second.</li>
<li><code>elapsed_time</code> - amount of time that passed since start of your game (in seconds).</li>
<li><code>plugins</code> - a mutable reference to all registered plugins, it allows you to access some "global" game data that does
not belong to any object. For example, a plugin could store key mapping used for player controls, you can access it
using <code>plugins</code> field and find desired plugin. In case of a single plugin, you just need to cast the reference to a
particular type using <code>context.plugins[0].cast::&lt;MyPlugin&gt;().unwrap()</code> call.</li>
<li><code>handle</code> - a handle of the node to which the script is assigned to (parent node). You can borrow the node using
<code>context.scene.graph[handle]</code> call. Typecasting can be used to obtain a reference to a particular node type.</li>
<li><code>scene</code> - a reference to parent scene of the script, it provides you full access to scene content, allowing you to
add/modify/remove scene nodes.</li>
<li><code>scene_handle</code> - a handle of a scene the script instance belongs to.</li>
<li><code>resource_manager</code> - a reference to resource manager, you can use it to load and instantiate assets.</li>
<li><code>message_sender</code> - a message sender. Every message sent via this sender will be then passed to every
<code>ScriptTrait::on_message</code> method of every script.</li>
<li><code>message_dispatcher</code> - a message dispatcher. If you need to receive messages of a particular type, you must subscribe
to a type explicitly.</li>
<li><code>task_pool</code> - task pool for asynchronous task management.</li>
<li><code>graphics_context</code> - Current graphics context of the engine.</li>
<li><code>user_interfaces</code> - a reference to user interface container of the engine. The engine guarantees that there's
at least one user interface exists. Use <code>context.user_interfaces.first()/first_mut()</code> to get a reference to it.</li>
<li><code>script_index</code> - index of the script. Never save this index, it is only valid while this context exists!</li>
</ul>
<h2 id="execution-order"><a class="header" href="#execution-order">Execution order</a></h2>
<p>Scripts have strictly defined execution order for their methods (the order if execution is linear and <strong>do not</strong> depend
on actual tree structure of the graph where the script is located):</p>
<ul>
<li><code>on_init</code> - called first for every script instance</li>
<li><code>on_start</code> - called after every <code>on_init</code> is called</li>
<li><code>on_update</code> - called zero or more times per one render frame. The engine stabilizes update rate of the logic, so if
your game runs at 15 FPS, the logic will still run at 60 FPS thus the <code>on_update</code> will be called 4 times per frame. The
method can also be not called at all, if the FPS is very high. For example, if your game runs at 240 FPS, then <code>on_update</code>
will be called once per 4 frames.</li>
<li><code>on_message</code> - called once per incoming message.</li>
<li><code>on_os_event</code> - called once per incoming OS event.</li>
<li><code>on_deinit</code> - called at the end of the update cycle once when the script (or parent node) is about to be deleted.</li>
</ul>
<p>If a scene node has multiple scripts assigned, then they will be processed as described above in the same order as they
assigned to the scene node.</p>
<h2 id="message-passing-1"><a class="header" href="#message-passing-1">Message passing</a></h2>
<p>Script system of Fyrox supports message passing for scripts. Message passing is a mechanism that allows you to send some
data (message) to a node, hierarchy of nodes or the entire graph. Each script can subscribe for a specific message type.
It is an efficient way for decoupling scripts from each other. For instance, you may want to detect and respond to some
event in your game. In this case when the event has happened, you send a message of a type and every "subscriber" will
react to it. This way subscribers will not know anything about sender(s); they'll only use message data to do some actions.</p>
<p>A simple example where the message passing can be useful is when you need to react to some event in your game. Imagine,
that you have weapons in your game, and they can have a laser sight that flashes with a different color when some target
was hit. In very naive approach you can handle all laser sights where you handle all intersection for projectiles, but
this adds a very tight coupling between laser sight and projectiles. This is totally unnecessary coupling can be made
loose by using message passing. Instead of handling laser sights directly, all you need to do is to broadcast an
<code>ActorDamaged { actor: Handle&lt;Node&gt;, attacker: Handle&lt;Node&gt; }</code> message. Laser sight in its turn can subscribe for such
message and handle all incoming messages and compare <code>attacker</code> with owner of the laser sight and if the hit was made
by <code>attacker</code> flash with some different color. In code this would like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum Message {
    Damage {
        actor: Handle&lt;Node&gt;,
        attacker: Handle&lt;Node&gt;,
    },
}

#[derive(Default, Clone, Reflect, Visit, Debug, ComponentProvider, TypeUuidProvider)]
#[type_uuid(id = "eb3c6354-eaf5-4e43-827d-0bb10d6d966b")]
#[visit(optional)]
struct Projectile;

impl ScriptTrait for Projectile {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Broadcast the message globally.
        ctx.message_sender.send_global(Message::Damage {
            actor: Default::default(),
            attacker: ctx.handle,
        });
    }
}

#[derive(Default, Clone, Reflect, Visit, Debug, ComponentProvider, TypeUuidProvider)]
#[type_uuid(id = "ede36945-5cba-41a1-9ef9-9b33b0f0db36")]
#[visit(optional)]
struct LaserSight;

impl ScriptTrait for LaserSight {
    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Subscript to messages.
        ctx.message_dispatcher.subscribe_to::&lt;Message&gt;(ctx.handle);
    }

    fn on_message(
        &amp;mut self,
        message: &amp;mut dyn ScriptMessagePayload,
        _ctx: &amp;mut ScriptMessageContext,
    ) {
        // React to message.
        if let Some(Message::Damage { actor, attacker }) = message.downcast_ref::&lt;Message&gt;() {
            Log::info(format!("{actor} damaged {attacker}",))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There are few key parts:</p>
<ul>
<li>You should explicitly subscribe script instance to a message type, otherwise messages of the type won't be delivered
to your script. This is done using the message dispatcher: <code>ctx.message_dispatcher.subscribe_to::&lt;Message&gt;(ctx.handle);</code>.
This should be done in <code>on_start</code> method, however it is possible to subscribe/unsubscribe at runime.</li>
<li>You can react to messages only in special method <code>on_message</code> - here you just need to check for message type using
pattern matching and do something useful.</li>
</ul>
<p>Try to use message passing in all cases, loose coupling significantly improves code quality and readability, however
in simple projects it can be ignored completely.</p>
<h2 id="accessing-other-scripts-data"><a class="header" href="#accessing-other-scripts-data">Accessing Other Script's Data</a></h2>
<p>Every script "lives" on some scene node, so to access a script data from some other script you need to know
a handle of a scene node with that script first. You can do this like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb05ad-ab56-4be6-8a06-73e73d8b1f48")]
#[visit(optional)]
struct MyScript {
    second_node: Handle&lt;Node&gt;,
}

impl ScriptTrait for MyScript {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        if let Some(second_nodes_script_ref) = ctx
            .scene
            .graph
            .try_get_script_of::&lt;MyOtherScript&gt;(self.second_node)
        {
            if second_nodes_script_ref.counter &gt; 60.0 {
                Log::info("Done!");
            }
        }

        // The code below is equivalent to the code above. The only difference is that
        // it borrows the node and then borrows the script from it, giving you access
        // to the node.
        if let Some(second_node_ref) = ctx.scene.graph.try_get(self.second_node) {
            if let Some(second_nodes_script_ref) = second_node_ref.try_get_script::&lt;MyOtherScript&gt;()
            {
                if second_nodes_script_ref.counter &gt; 60.0 {
                    Log::info("Done!");
                }
            }
        }
    }
}

#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb05ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct MyOtherScript {
    counter: f32,
}

impl ScriptTrait for MyOtherScript {
    fn on_update(&amp;mut self, _ctx: &amp;mut ScriptContext) {
        // Counting.
        self.counter += 1.0;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example we have the two script types: <code>MyScript</code> and <code>MyOtherScript</code>. Now imagine that we have two scene
nodes, where the first one contains <code>MyScript</code> and the second one <code>MyOtherScript</code>. <code>MyScript</code> knows about
the second node by storing a handle of in <code>second_node</code> field. <code>MyScript</code> waits until <code>MyOtherScript</code> will count
its internal counter to <code>60.0</code> and then prints a message into the log. This code does immutable borrowing and
does not allow you to modify other script's data. If you a mutable access, then use <code>try_get_script_of_mut</code>
method (or <code>try_get_script_mut</code> for the alternative code).</p>
<p><code>second_node</code> field of the <code>MyScript</code> is usually assigned in the editor, but you can also find the node in
your scene by using the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        self.second_node = ctx
            .scene
            .graph
            .find_by_name_from_root("SomeName")
            .map(|(handle, _)| handle)
            .unwrap_or_default();
    }
<span class="boring">}</span></code></pre></pre>
<p>This code searches for a node with <code>SomeName</code> and assigns its handle to the <code>second_node</code> variable in the script
for later use.</p>
<h2 id="accessing-plugins-from-scripts"><a class="header" href="#accessing-plugins-from-scripts">Accessing Plugins From Scripts</a></h2>
<p>Sometimes there's a need to access plugin data from scripts, there may be various reasons for that, for example
you may need to register a bot in the list of bots. This list could then be used for AI to search targets without
searching in the entire scene graph at every frame.</p>
<p>Accessing plugins from scripts is very easy, all you need to do is to call <code>get/get_mut</code> method from <code>ctx.plugins</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Debug, Reflect, Visit)]
struct GamePlugin {
    bots: Vec&lt;Handle&lt;Node&gt;&gt;,
}

impl Plugin for GamePlugin {
    // ..
}

#[derive(Clone, Debug, Default, Visit, Reflect, ComponentProvider, TypeUuidProvider)]
#[type_uuid(id = "460cd09f-8768-4f38-8799-5e9c0c08b8fd")]
struct Bot {
    // ..
}

impl ScriptTrait for Bot {
    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Get a reference to the plugin.
        let plugin = ctx.plugins.get_mut::&lt;GamePlugin&gt;();
        // Register self in the "global" list of bots.
        plugin.bots.push(ctx.handle);
    }

    fn on_deinit(&amp;mut self, ctx: &amp;mut ScriptDeinitContext) {
        let plugin = ctx.plugins.get_mut::&lt;GamePlugin&gt;();
        // Unregister the bot from the list.
        if let Some(index) = plugin
            .bots
            .iter()
            .position(|handle| *handle == ctx.node_handle)
        {
            plugin.bots.remove(index);
        }
    }

    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let plugin = ctx.plugins.get::&lt;GamePlugin&gt;();
        for bot in plugin.bots.iter() {
            if *bot != ctx.handle {
                // Search for target.
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example the Bot script registers itself in a global list of bots on start, and unregisters on destruction.
<code>update</code> is then used to search for targets in that list.</p>
<p>In multiplayer games, plugin could store server/client instances and scripts could easily access them to send messages
across the network for other players. In general, you could use plugins as an arbitrary, global data storage for your
scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tasks"><a class="header" href="#tasks">Tasks</a></h1>
<p>Fyrox supports task-based programming for both scripts and plugins. Task is a closure that does something in a separate
thread and then the result of it is returned back to the main thread. This is very useful technique, that allows you to
perform heavy calculations using all available CPU power, not just one CPU core with a single main thread. Tasks could
be used for pretty much anything, that can be done as a separate piece of work.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>Main thread spawns a task which is then sent to the task pool. There's a fixed set of worker threads, that extracts
tasks from the task pool when there's any. Task's code is then executed in one of the worker thread, which may take
any amount of time. When the task is completed, its result is sent to the main thread and then a callback closure is
executed to do a desired action on task completion. Usually it's something relatively fast - for example you may
spawn a task that calculates a path on a large navigational mesh and when it is done, you store that path in one of your
script instance from which the task was spawned. As you can see, there are two major parts - the task itself and the
closure. Graphically it can be represented like this:</p>
<p><img src="scripting/task.svg" alt="task" /></p>
<p>Green line represents the main thread and the two purple lines are the worker threads. There could be any number of
worker threads, and usually it is a worker thread per each CPU core. Let's take a look at a typical task path on
this image (yellow-ish one). At first, we spawn a task, and it is immediately put in the task pool (in the same thread),
after this if we have a free worker thread it extracts our task from the pool and sends it to execution. As you can
see any task must implement <code>Send</code> trait, otherwise you'll get a <em>compilation error</em>. When the task is complete, the
worker thread sends the result (again, the result must be <code>Send</code>) to the main thread and an associated callback closure
is executed to do something with the result. While the task is being executed, the main thread is not blocked, and it
can do other useful stuff.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>The following example calculates a path on a navigational mesh in using task-based approach described above. At first,
it prepares the "environment" for the task by cloning a shared navigational mesh (<code>Arc&lt;RwLock&lt;NavMesh&gt;&gt;</code>) into a
local variable. Then it spawns a new task (<code>async move { .. }</code> block) which reads the shared navigational mesh
and calculates a long path, that could take a few frames to compute (imagine a huge island, and we need to get
a path from one corner to another). As the last argument to the <code>spawn_script_task</code> method we pass a closure that
will be executed on the main thread when the task is complete. It just saves the computed path in the script's
field which is then used for visualization.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Default, Reflect, Debug, Clone, ComponentProvider, TypeUuidProvider)]
#[type_uuid(id = "efc71c98-ecf1-4ec3-a08d-116e1656611b")]
struct MyScript {
    navmesh: Handle&lt;Node&gt;,
    path: Option&lt;Vec&lt;Vector3&lt;f32&gt;&gt;&gt;,
}

impl ScriptTrait for MyScript {
    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Borrow a navigational mesh scene node first.
        if let Some(navmesh_node) = ctx
            .scene
            .graph
            .try_get_of_type::&lt;NavigationalMesh&gt;(self.navmesh)
        {
            // Take a shared reference to the internal navigational mesh.
            let shared_navmesh = navmesh_node.navmesh();

            // Spawn a task, that will calculate a long path.
            ctx.task_pool.spawn_script_task(
                ctx.scene_handle,
                ctx.handle,
                ctx.script_index,
                async move {
                    let navmesh = shared_navmesh.read();

                    if let Some((_, begin_index)) =
                        navmesh.query_closest(Vector3::new(1.0, 0.0, 3.0))
                    {
                        if let Some((_, end_index)) =
                            navmesh.query_closest(Vector3::new(500.0, 0.0, 800.0))
                        {
                            let mut path = Vec::new();
                            if navmesh
                                .build_path(begin_index, end_index, &amp;mut path)
                                .is_ok()
                            {
                                return Some(path);
                            }
                        }
                    }

                    None
                },
                |path, this: &amp;mut MyScript, _ctx| {
                    this.path = path;

                    Log::info("Path is calculated!");
                },
            );
        }
    }

    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Draw the computed path.
        if let Some(path) = self.path.as_ref() {
            for segment in path.windows(2) {
                ctx.scene.drawing_context.add_line(Line {
                    begin: segment[0],
                    end: segment[1],
                    color: Default::default(),
                })
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Plugins could also spawn tasks, which operates on application scale basis, unlike script tasks which operates with
separate script instances. A plugin task is a bit easier to use:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Visit, Reflect)]
struct MyGame {
    data: Option&lt;Vec&lt;u8&gt;&gt;,
}

impl MyGame {
    pub fn new(context: PluginContext) -&gt; Self {
        context.task_pool.spawn_plugin_task(
            // Emulate heavy task by reading a potentially large file. The game will be fully
            // responsive while it runs.
            async move {
                let mut file = File::open("some/file.txt").unwrap();
                let mut data = Vec::new();
                file.read_to_end(&amp;mut data).unwrap();
                data
            },
            // This closure is called when the future above has finished, but not immediately - on
            // the next update iteration.
            |data, game: &amp;mut MyGame, _context| {
                // Store the data in the game instance.
                game.data = Some(data);
            },
        );

        // Immediately return the new game instance with empty data.
        Self { data: None }
    }
}

impl Plugin for MyGame {
    fn update(&amp;mut self, _context: &amp;mut PluginContext) {
        // Do something with the data.
        if let Some(data) = self.data.take() {
            println!("The data is: {:?}", data);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<p>You should avoid task-based approach for small (in time terms) tasks, because each task has additional cost which
might be larger than the actual task executed in-place. This is because you need to send your task to a separate
thread using a channel, then the callback closure is stored as a trait object which involves memory allocation.
Since tasks uses type erasure technique, they perform dynamic type casting which is not free. Also, there could be
any other implementation-defined "slow" spots.</p>
<p>A general advice would be: run a profiler first to find hot spots in your game, then try to optimize them. If you
hit the optimization limit, use tasks. Do not use tasks until you really need them, try to optimize your game first!
If you're working on a simple 2D game, you'll never need to use tasks. You might need to use tasks when your have,
for instance, a procedurally generated world that should be generated on the fly. For example, if you're making a
dungeon crawler with infinite world. Tasks are also very useful for large games with loads of content and activities.
You could off-thread AI, world manipulation (for example if you have a destructible world), etc. In other words -
do not use a sledgehammer to hammer nails, unless you have a <em>huge</em> nail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executor"><a class="header" href="#executor">Executor</a></h1>
<p>Executor is a simple wrapper that drives your game plugins, it is intended to be used for production builds of your game.
The editor runs the executor in a separate process when you're entering the play mode. Basically, there is no significant
difference between running the game from the editor or running it as a separate application. The main difference is that
the editor passes <code>scene_path</code> parameter for the executor when entering the play mode.</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>Why there's a need for such a thing like executor? The first reason was already highlighted - game process isolation
during the game development. The next major reason is the fact that your game can be run on a number of different platforms.
If you <a href="scripting/../introduction/requirements.html#supported-platforms">check the list of supported platforms</a>, you'll understand
why there's such a need. Each platform has its own way of how the native code is processed. For example, on WebAssembly
the game code is compiled into an WASM module which is then loaded by a web browser and executed. This platform requires
the native code to be compiled into a "dynamic library", while, for instance, the PC builds can be compiled directly
into an executable file. Android, for instance, requires the game to be compiled into a shared library (<code>.so</code>) and then
loaded by a bunch of "glue" code and executed.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Executor is meant to be a part of your project's workspace, its typical look could something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{pool::Handle, uuid::Uuid},
</span><span class="boring">    engine::executor::Executor,
</span><span class="boring">    plugin::{Plugin, PluginConstructor, PluginContext},
</span><span class="boring">    scene::{Scene},
</span><span class="boring">};
</span><span class="boring">struct GameConstructor;
</span><span class="boring">impl PluginConstructor for GameConstructor {
</span><span class="boring">    fn create_instance(
</span><span class="boring">        &amp;self,
</span><span class="boring">        _scene_path: Option&lt;&amp;str&gt;,
</span><span class="boring">        _context: PluginContext,
</span><span class="boring">    ) -&gt; Box&lt;dyn Plugin&gt; {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span>fn main() {
    let mut executor = Executor::new();
    // Register your game constructor here.
    executor.add_plugin_constructor(GameConstructor);
    executor.run()
}</code></pre></pre>
<p>The executor has full access to the engine, and through it to the main application window. You can freely change desired
parts, <code>Executor</code> implements <code>Deref&lt;Target = Engine&gt; + DerefMut</code> traits, so you can use its instance as an "alias"
to engine instance.</p>
<p>To add a plugin to the executor, just use <code>add_plugin_constructor</code> method, it accepts any entity that implements
<code>PluginConstructor</code> traits.</p>
<h2 id="typical-use-cases"><a class="header" href="#typical-use-cases">Typical Use Cases</a></h2>
<p>This section covers typical use cases for the <code>Executor</code>.</p>
<h3 id="setting-window-title"><a class="header" href="#setting-window-title">Setting Window Title</a></h3>
<p>You can set window title when creating executor instance:</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    let executor = Executor::from_params(
        EventLoop::new().ok(),
        GraphicsContextParams {
            window_attributes: WindowAttributes {
                // Set window title.
                title: "My Game".to_string(),
                ..Default::default()
            },
            vsync: true,
            msaa_sample_count: None,
            graphics_server_constructor: Default::default(),
            named_objects: false,
        },
    );
    // ...
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene-1"><a class="header" href="#scene-1">Scene</a></h1>
<p>Scene is a container for game entities. Scene allows you to create an isolated "world" which won't
interact with other scenes, it is very useful for many more or less complex games.</p>
<p>What game scenes cannot handle is user interface entities, they're handled by a separate scene class,
so-called UI scene. UI scenes are discussed in the <a href="scene/../ui/ui.html">respective chapter</a>. UI can still
be incorporated in the game scene, see <a href="scene/../ui/rendering.html">this chapter</a> for more info.</p>
<h2 id="how-to-create"><a class="header" href="#how-to-create">How to create</a></h2>
<p>A scene could be created either in the editor or programmatically. You can also combine both approaches, where
you build all "static" content in the editor and adding rest of the entities (bots, interactive objects, etc.)
manually by instantiating the respective prefabs at runtime.</p>
<h3 id="using-fyroxed"><a class="header" href="#using-fyroxed">Using FyroxEd</a></h3>
<p>There is a <a href="scene/../beginning/editor_overview.html">separate chapter</a> in the book that should help you to create a
scene. After a scene is created, you can load it using async scene loader:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct MyGame {
    main_scene: Handle&lt;Scene&gt;,
}

impl Plugin for MyGame {
    fn init(&amp;mut self, scene_path: Option&lt;&amp;str&gt;, context: PluginContext) {
        // Step 1. Kick off scene loading in a separate thread. This method could
        // be located in any place of your code.
        context.async_scene_loader.request("path/to/your/scene.rgs")
    }

    fn on_scene_loaded(
        &amp;mut self,
        path: &amp;Path,
        scene: Handle&lt;Scene&gt;,
        data: &amp;[u8],
        context: &amp;mut PluginContext,
    ) {
        // Step 2.
        // This method is called once a scene was fully loaded.
        // You may want to remove previous scene first.
        if self.main_scene.is_some() {
            context.scenes.remove(self.main_scene)
        }

        // Remember new scene as main.
        self.main_scene = scene;
    }

    fn on_scene_begin_loading(&amp;mut self, path: &amp;Path, context: &amp;mut PluginContext) {
        // This method is called if a scene just began to load.
    }

    fn on_scene_loading_failed(
        &amp;mut self,
        path: &amp;Path,
        error: &amp;VisitError,
        context: &amp;mut PluginContext,
    ) {
        // This method is called if a scene failed to load.
    }

    // ...
<span class="boring">}</span></code></pre></pre>
<p>The code is quite straightforward. At first, we're using async scene loader to create a scene loading request.
This request will be processed in a separate thread, leaving your game fully responsible while the scene is loading.
Next, when the scene is fully loaded and added to the engine, <code>on_scene_loaded</code> method is called. Usually there's
only one active scene, so we're removing the previous one and setting the new one as active.</p>
<p>There are two additional methods:</p>
<ol>
<li><code>on_scene_begin_loading</code> - is called when a scene is just began to load. Keep in mind that async scene loader
could load multiple scenes at once, and this method is guaranteed to be called exactly before the scene is started
to load.</li>
<li><code>on_scene_loading_failed</code> - is called when a scene is failed to load. This method could be useful if you're using
non-verified scenes (i.e. from game mods) and want to react somehow when the scene is failed to load.</li>
</ol>
<h3 id="create-scene-manually"><a class="header" href="#create-scene-manually">Create scene manually</a></h3>
<p>A scene could also be created manually, the following code creates a cube and a camera to visualize the cube:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_scene(ctx: &amp;mut PluginContext) -&gt; Handle&lt;Scene&gt; {
    let mut scene = Scene::new();

    // Use node builders, create sounds, add physics, etc. here to fill the scene.
    // The following code creates a simple cube and a camera to visualize it.
    CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

    MeshBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 0.0, 3.0))
                .build(),
        ),
    )
    .with_surfaces(vec![
        SurfaceBuilder::new(surface::CUBE.resource.clone()).build()
    ])
    .build(&amp;mut scene.graph);

    ctx.scenes.add(scene)
}
<span class="boring">}</span></code></pre></pre>
<p>See the respective node builders <a href="scene/../scene/graph.html#using-node-builders">docs</a> to populate the scene.</p>
<h2 id="where-are-all-my-scenes-located"><a class="header" href="#where-are-all-my-scenes-located">Where are all my scenes located?</a></h2>
<p>All scenes "live" in the engine, the engine has ownership over your scene after you've added it to the engine.
You can borrow a scene at any time using its handle and do some changes to it and its nodes:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        // Borrow a scene using its handle. `try_get` performs immutable borrow, to mutably borrow the scene
        // use `try_get_mut`.
        if let Some(scene) = context.scenes.try_get(self.main_scene) {
            // Do something.
            println!("{:?}", scene.graph.performance_statistics);
        }
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="building-a-scene-asynchronously"><a class="header" href="#building-a-scene-asynchronously">Building a scene asynchronously</a></h2>
<p>You can create your scene in a separate thread and then pass it to the main thread to insert it in the engine. Why this
is needed? Remember the last time you've played a relatively large game, you've probably noticed that it has
loading screens and loading screen has some fancy interactive stuff with progress bar. Loading screen is fully
responsive while the game is doing a hard job loading the world for you. Got it already? Asynchronous scene loading is
needed to create/load large scenes with tons of resources without blocking the main thread, thus leaving the game
fully responsive.</p>
<h2 id="managing-multiple-scenes"><a class="header" href="#managing-multiple-scenes">Managing multiple scenes</a></h2>
<p>Usually you should have only one scene active (unless you're making something very special), you should use
<code>.enabled</code> flag of a scene to turn it off or on. Deactivated scenes won't be rendered, the physics won't be
updated, the sound will stop, and so on. In other words, the scene will be frozen. This is useful for situations
when you often need to switch between scenes, leaving other scenes in frozen state. One of the examples where this
can be useful is menus. In most games when you're entering the menu, game world is paused.</p>
<p>If multiple scenes are enabled, they'll be rendered in the same order as they were created. Multiple active
scenes have very limited use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph"><a class="header" href="#graph">Graph</a></h1>
<p>Graph is a set of objects with hierarchical relationships between each object. It is one of the most important
entities in the engine. Graph takes care of your scene objects and does all the hard work for you.</p>
<h2 id="how-to-create-1"><a class="header" href="#how-to-create-1">How to create</a></h2>
<p>You don't need to create a graph manually, every scene has its own instance of the graph. It can be accessed pretty
easily: <code>scene_ref.graph</code></p>
<h2 id="adding-nodes"><a class="header" href="#adding-nodes">Adding nodes</a></h2>
<p>There are two ways of adding nodes to the graph, either using <em>node builders</em> or manually by calling <code>graph.add_node</code>.</p>
<h3 id="using-node-builders"><a class="header" href="#using-node-builders">Using node builders</a></h3>
<p>Every node in the engine has its respective builder which can be used to create an instance of the node. Using
builders is a preferable way to create scene nodes. The most significant node builders are the following:</p>
<ol>
<li><code>BaseBuilder</code> - creates an instance of base node. See <a href="scene/./base_node.html">Base node</a> for more info.</li>
<li><code>PivotBuilder</code> - creates an instance of pivot node. See <a href="scene/./base_node.html">Base node</a> for more info.</li>
<li><code>CameraBuilder</code> - creates an instance of camera node. See <a href="scene/./camera_node.html">Camera node</a> for more info.</li>
<li><code>MeshBuilder</code> - creates an instance of mesh node. See <a href="scene/./mesh_node.html">Mesh node</a> for more info.</li>
<li><code>LightBuilder</code> - creates an instance of light node. See <a href="scene/./light_node.html">Light node</a> for more info.</li>
<li><code>SpriteBuilder</code> - creates an instance of sprite node. See <a href="scene/./sprite_node.html">Sprite node</a> for more info.</li>
<li><code>ParticleSystemBuilder</code> - creates an instance of particle system node.
See <a href="scene/./particle_system_node.html">Particle system node</a> for more info.</li>
<li><code>TerrainBuilder</code> - creates an instance of terrain node. See <a href="scene/./terrain_node.html">Terrain node</a> for more info.</li>
<li><code>DecalBuilder</code> - creates an instance of decal node. See <a href="scene/./decal_node.html">Decal node</a> for more info.</li>
<li><code>RigidBodyBuilder</code> - creates an instance of rigid body node. See <a href="scene/../physics/rigid_body.html">Rigid body</a> for more
info.</li>
<li><code>ColliderBuilder</code> - creates an instance of collider node. See <a href="scene/../physics/collider.html">Collider</a> for more info.</li>
<li><code>JointBuilder</code> - creates an instance of joint node. See <a href="scene/../physics/joint.html">Joint</a> for more info.</li>
<li><code>RectangleBuilder</code> - creates an instance of 2D rectangle node. See <a href="scene/./rectangle.html">Rectangle</a> for more info.</li>
<li><code>AnimationPlayerBuilder</code> - creates an instance of <code>AnimationPlayer</code> node. See <a href="scene/../animation/animation.html">Animation</a>
chapter for more info.</li>
<li><code>AnimationBlendingStateMachineBuilder</code> - creates an instance of <code>AnimationBlendingStateMachineBuilder</code> node.
See <a href="scene/../animation/blending.html">Animation Blending</a> chapter for more info.</li>
<li><code>ReflectionProbeBuilder</code> - creates an instance of a <a href="scene/probe.html">Reflection Probe</a> node.</li>
<li><code>TileMapBuilder</code> - creates an instance of a <a href="scene/tilemap.html">Tile Map</a> node.</li>
<li><code>Ragdoll</code> - creates and instance of a <a href="scene/../physics/ragdoll.html">Ragdoll</a> node.</li>
</ol>
<p>Every builder, other than <code>BaseBuilder</code>, accepts <code>BaseBuilder</code> as a parameter in <code>.new(..)</code> method. Why so?
Because every node (other than Base) is "derived" from Base via composition and the derived
builder must know how to build Base node. While it may sound confusing, it is actually very useful and clear.
Consider this example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_camera(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(
        // Here we passing a base builder. Note that, since we can build Base node separately
        // we can pass any custom values to it while building.
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(2.0, 0.0, 3.0))
                .build(),
        ),
    )
    // Here we just setting desired Camera properties.
    .with_fov(60.0f32.to_radians())
    .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, we're creating an instance of BaseBuilder and fill it with desired properties as well as filling
the CameraBuilder's instance properties. This is a very flexible mechanism, allowing you to build complex hierarchies
in a declarative manner:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_node(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(
        BaseBuilder::new()
            // Add some children nodes.
            .with_children(&amp;[
                // A staff...
                MeshBuilder::new(
                    BaseBuilder::new()
                        .with_name("MyFancyStaff")
                        .with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(0.5, 0.5, 1.0))
                                .build(),
                        ),
                )
                .build(&amp;mut scene.graph),
                // and a spell.
                SpriteBuilder::new(
                    BaseBuilder::new()
                        .with_name("MyFancyFireball")
                        .with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(-0.5, 0.5, 1.0))
                                .build(),
                        ),
                )
                .build(&amp;mut scene.graph),
            ])
            .with_local_transform(
                TransformBuilder::new()
                    .with_local_position(Vector3::new(2.0, 0.0, 3.0))
                    .build(),
            ),
    )
    .with_fov(60.0f32.to_radians())
    .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>This code snippet creates a camera for first-person role-playing game's player, it will have a staff in "right-hand"
and a spell in the left hand. Of course, all of this is very simplified, but should give you the main idea. Note
that staff and fireball will be children nodes of camera, and when setting their transform, we're actually setting
<strong>local</strong> transform which means that the transform will be relative to camera's. The staff and the spell will move
together with the camera.</p>
<h3 id="adding-a-node-manually"><a class="header" href="#adding-a-node-manually">Adding a node manually</a></h3>
<p>For some rare cases you may also want to delay adding a node to the graph, specifically for that purpose, every node
builder has <code>.build_node</code> method which creates an instance of <code>Node</code>  but does not add it to the graph.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_node_manually(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    let node: Node = CameraBuilder::new(BaseBuilder::new()).build_node();

    // We must explicitly add the node to the graph.
    scene.graph.add_node(node)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-to-modify-the-hierarchy"><a class="header" href="#how-to-modify-the-hierarchy">How to modify the hierarchy</a></h2>
<p>For many cases, you can't use builders to create complex hierarchy, the simplest example of such situation when
you're creating an instance of some 3D model. If you want the instance to be a child object of some other object,
you should attach it explicitly by using <code>graph.link_nodes(..)</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn link_weapon_to_camera(
    scene: &amp;mut Scene,
    camera: Handle&lt;Node&gt;,
    resource_manager: ResourceManager,
) {
    let weapon = block_on(resource_manager.request::&lt;Model&gt;("path/to/weapon.fbx"))
        .unwrap()
        .instantiate(scene);

    // Link weapon to the camera.
    scene.graph.link_nodes(weapon, camera);
}
<span class="boring">}</span></code></pre></pre>
<p>Here we've loaded a weapon 3D model, instantiated it on scene and attached to <em>existing</em> camera.</p>
<h2 id="how-to-remove-nodes"><a class="header" href="#how-to-remove-nodes">How to remove nodes</a></h2>
<p>A node could be removed by simply calling <code>graph.remove_node(handle)</code>, this method removes the node from the
graph <strong>with all of its children nodes</strong>. Sometimes this is unwanted behavior, and you want to preserve children
nodes while deleting parent node. To do that, you need to explicitly detach children nodes of the node you're about
to delete:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_preserve_children(scene: &amp;mut Scene, node_to_remove: Handle&lt;Node&gt;) {
    for child in scene.graph[node_to_remove].children().to_vec() {
        scene.graph.unlink_node(child);
    }

    scene.graph.remove_node(node_to_remove);
}
<span class="boring">}</span></code></pre></pre>
<p>After calling this function, every child node of <code>node_to_remove</code> will be detached from it and the <code>node_to_remove</code>
will be deleted. <code>remove_node</code> has some limitations: it cannot be used to extract "sub-graph" from the graph, it
just drops nodes immediately.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transformation"><a class="header" href="#transformation">Transformation</a></h1>
<p>Transformation (transform for short) - is a special entity that changes coordinate system from one to another. It is used
primarily in scene nodes to store their position/rotation/scale/pivots/etc. Fyrox has quite complex transformations, that
supports:</p>
<ol>
<li>Position (<code>T</code>)</li>
<li>Rotation (<code>R</code>)</li>
<li>Scale (<code>S</code>)</li>
<li>Pre-rotation (<code>Rpre</code>)</li>
<li>Post-rotation (<code>Rpost</code>)</li>
<li>Rotation Pivot (<code>Rp</code>)</li>
<li>Rotation Offset (<code>Roff</code>)</li>
<li>Scaling Offset (<code>Soff</code>)</li>
<li>Scaling Pivot (<code>Sp</code>)</li>
</ol>
<p>Final transformation matrix will be <code>Transform = T * Roff * Rp * Rpre * R * Rpost * Rp⁻¹ * Soff * Sp * S * Sp⁻¹</code>. In 99.9%
cases first three are enough for pretty much every task. Other six components used for specific stuff (mainly for nodes
that imported from FBX file format).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefabs"><a class="header" href="#prefabs">Prefabs</a></h1>
<p>A prefab is a separate scene that can be instantiated in some other scene, while preserving links between properties
of its instances and of its parent prefab. Prefabs allow you to create a part of a scene and have multiple instances of
it in other scenes.</p>
<p>Let's quickly check what that means on practice. The engine has a prefab system which allows you to build
hierarchical scenes which can include any number of other scenes as child scenes. Child scenes can have their own child
scenes and so on. This is very efficient decoupling mechanism that allows you to put pieces of the scene in separate
scenes (prefabs) and modify them independently. The changes in child scenes will be automatically reflected to all parent
scenes. Here is the very simple example of why this is important: imagine you need to populate a town with 3D models of
cars. Each kind of car has its own 3D model and for example, a collision body that won't allow the player to walk through
cars. How would you do this? The simplest (and dumbest) solution is to copy dozens of car models in the scene, and
you're done. Imagine that now you need to change something in your car, for example, add a trunk that can be opened.
What will you do? Of course, you should "iterate" over each car model and do the required changes, you simply don't have
any other option. This will eat huge amount of time and in general it is very non-productive.</p>
<p>This is where prefabs will save you hours of work. All you need to do is to create a car prefab and instantiate it
multiple times in your scene. When you'll need to change something in the car, you simply go to the prefab and change
it. After that every prefab instance will have your changes!</p>
<p>Prefabs can be used to create self-contained entities in your game, examples of this includes: visual effects,
any scripted game entities (bots, turrets, player, doors, etc.). Such prefabs can be either directly instantiated in
a scene in the editor, or instantiated at runtime when needed.</p>
<h2 id="how-to-create-and-use-a-prefab"><a class="header" href="#how-to-create-and-use-a-prefab">How to create and use a prefab</a></h2>
<p>All you need to do is to make a scene in the editor with all required objects and save it! After that, you can use the
scene in other scenes and just do its instantiation, as in usual 3D models. You can either instantiate it from the
editor by drag'n'drop a prefab to scene previewer, or do standard <a href="scene/../resources/model.html#instantiation">model resource instantiation</a></p>
<h2 id="property-inheritance"><a class="header" href="#property-inheritance">Property inheritance</a></h2>
<p>As already mentioned in the intro section, instances inherit properties from their parent prefabs. For example, you
can change position of an object in prefab and every instance will reflect that change - the object's instances will
also move. This works until there's no manual change to a property in instance, if you do so, your change is
considered with higher priority. See <a href="scene/./inheritance.html">this chapter</a> for more info.</p>
<h2 id="hierarchical-prefabs"><a class="header" href="#hierarchical-prefabs">Hierarchical Prefabs</a></h2>
<p>Prefabs can have other prefab instances inside it. This means that you can, for example, create a room populated with
instances of other prefabs (bookshelves, chairs, tables, etc.) and then use the room prefab to build a bigger scene.
The changes in the base prefabs will be reflected in their instances, regardless of how deep the hierarchy is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-inheritance-1"><a class="header" href="#property-inheritance-1">Property Inheritance</a></h1>
<p>Property inheritance is used to propagate changes of unmodified properties from a prefab to its instances. For example,
you can change scale of a node in a prefab and its instances will have the same scale too, unless the scale is
set explicitly in an instance. Such feature allows you to tweak instances, add some unique details to them, but take
general properties from parent prefabs.</p>
<p>Property inheritance works for prefab hierarchies of any depth, this means that you can create something like this:
a room prefab can have multiple instances of various furniture prefabs in it, while the furniture prefabs can also be
constructed from other prefabs and so on. In this case if you modify a property in one of the prefabs in the chain,
all instance will immediately sync their unmodified properties.</p>
<h2 id="how-to-create-inheritable-properties"><a class="header" href="#how-to-create-inheritable-properties">How To Create Inheritable Properties</a></h2>
<p>It is possible to use property inheritance for script variables. To make a property of your script inheritable, all you
need is to wrap its value using <code>InheritableVariable</code> wrapper.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Reflect, Visit, Default, Clone, Debug)]
struct MyScript {
    foo: InheritableVariable&lt;f32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The engine will automatically resolve the correct value for the property when a scene with the script is loaded. If your
property was modified, then its value will remain the same, it won't be overwritten by parent's value. Keep in mind,
that the type of the inheritable variable must be cloneable and support reflection.</p>
<p><code>InheritableVariable</code> implements the <code>Deref&lt;Target = T&gt; + DerefMut</code> traits, this means that any access via the <code>DerefMut</code> trait
will mark the property as modified. This could be undesired in some cases so <code>InheritableVariable</code> supports special <code>xxx_silent</code>
methods that don't touch the internal modifiers and allows you to substitute the value with some other "silently" -
without marking the variable as modified.</p>
<h2 id="which-fields-should-be-inheritable"><a class="header" href="#which-fields-should-be-inheritable">Which Fields Should Be Inheritable?</a></h2>
<p>Inheritable variables intended to be "atomic" - it means that the variable stores some simple variable (<code>f32</code>, <code>String</code>,
<code>Handle&lt;Node&gt;</code>, etc.). While it is possible to store "compound" variables (<code>InheritableVariable&lt;YourStruct&gt;</code>), it is
not advised because of inheritance mechanism. When the engine sees inheritable variable, it searches the same variable
in a parent entity and copies its value to the child, thus completely replacing its content. In this case, even if you
have inheritable variables inside compound field, they won't be inherited correctly. Let's demonstrate this in the
following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Reflect, Clone, PartialEq, Eq, Debug)]
struct SomeComplexData {
    foo: InheritableVariable&lt;u32&gt;,
    bar: InheritableVariable&lt;String&gt;,
}

#[derive(Reflect, Debug)]
struct MyEntity {
    some_field: InheritableVariable&lt;f32&gt;,

    // This field won't be inherited correctly - at first it will take parent's value and then
    // will try to inherit inner fields, but its is useless step, because inner data is already
    // a full copy of parent's field value.
    incorrectly_inheritable_data: InheritableVariable&lt;SomeComplexData&gt;,

    // Subfields of this field will be correctly inherited, because the field itself is not inheritable.
    inheritable_data: SomeComplexData,
}
<span class="boring">}</span></code></pre></pre>
<p>This code snippet should clarify, that inheritable fields should contain some "simple" data, and almost never - complex
structs.</p>
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p>The editor wraps all inheritable properties in a special widget that supports property reversion. Reversion allows you
to drop current changes and take the parent's property value. This is useful if you want a property to inherit its parent's
value. In the Inspector it looks like this:</p>
<p><img src="scene/./revert.png" alt="revert" /></p>
<p>Clicking on the <code>&lt;</code> button will take the value from the parent prefab and the property won't be marked as modified anymore. In case
there is no parent prefab, the button will just drop <code>modified</code> flag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-node"><a class="header" href="#base-node">Base node</a></h1>
<p>Base node is a scene node that stores hierarchical information (a handle to the parent node and a set of handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it
is used as a base node for every other scene node (via composition).</p>
<p>It has no graphical information, so it is invisible all the time, but it is useful as a "container" for children
nodes.</p>
<h2 id="how-to-create-2"><a class="header" href="#how-to-create-2">How to create</a></h2>
<p>Use the <code>PivotBuilder</code> to create an instance of the Pivot node (remember <code>Base</code> node itself is used only to build other
node types):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let handle = PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);
<span class="boring">}</span></code></pre></pre>
<h2 id="building-a-complex-hierarchy"><a class="header" href="#building-a-complex-hierarchy">Building a complex hierarchy</a></h2>
<p>To build a complex hierarchy of some nodes, use <code>.with_children()</code> method of the <code>BaseBuilder</code>, it allows you
to build a hierarchy of any complexity:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let handle =
        PivotBuilder::new(
            BaseBuilder::new().with_children(&amp;[
                CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph),
                PivotBuilder::new(BaseBuilder::new().with_children(&amp;[
                    PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph),
                ]))
                .build(&amp;mut scene.graph),
            ]),
        )
        .build(&amp;mut scene.graph);
<span class="boring">}</span></code></pre></pre>
<p>Note that when we're building a <code>Camera</code> instance, we're passing a new instance of <code>BaseBuilder</code> to it, this
instance can also be used to set some properties and a set of children nodes.</p>
<p>The "fluent syntax" is not mandatory to use, the above code snipped could be rewritten like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let camera = CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

    let child_base = PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

    let base =
        PivotBuilder::new(BaseBuilder::new().with_children(&amp;[child_base])).build(&amp;mut scene.graph);

    let handle = PivotBuilder::new(BaseBuilder::new().with_children(&amp;[camera, base]))
        .build(&amp;mut scene.graph);
<span class="boring">}</span></code></pre></pre>
<p>However, it looks less informative, because it loses the hierarchical view and it is harder to tell the relations
between objects.</p>
<h2 id="transform"><a class="header" href="#transform">Transform</a></h2>
<p>Base node has a local transform that allows you to translate/scale/rotate/etc. your node as you want to. For example,
to move a node at specific location you could use this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    scene.graph[node_handle]
        .local_transform_mut()
        .set_position(Vector3::new(1.0, 0.0, 2.0));
<span class="boring">}</span></code></pre></pre>
<p>You could also chain multiple <code>set_x</code> calls, like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    scene.graph[node_handle]
        .local_transform_mut()
        .set_position(Vector3::new(1.0, 0.0, 2.0))
        .set_scale(Vector3::new(2.0, 2.0, 2.0))
        .set_rotation_offset(Vector3::new(1.0, 1.0, 0.0));
<span class="boring">}</span></code></pre></pre>
<p>See more info about transformations <a href="scene/./transform.html">here</a>.</p>
<h2 id="visibility"><a class="header" href="#visibility">Visibility</a></h2>
<p><code>Base</code> node stores all info about local visibility and global visibility (with parent's chain visibility included).
Changing node's visibility could be useful if you want to improve performance by hiding distant objects (however it
strongly advised to use level-of-detail for this) or to hide some objects in your scene. There are three main methods
to set or fetch visibility:</p>
<ul>
<li><code>set_visibility</code> - sets local visibility for a node.</li>
<li><code>visibility</code> - returns current local visibility of a node.</li>
<li><code>global_visibility</code> - returns combined visibility of a node. It includes visibility of every parent node in the
hierarchy, so if you have a parent node with some children nodes and set parent's visibility to <code>false</code>, global visibility
of children nodes will be <code>false</code> too, even if local visibility is <code>true</code>. This is useful technique for hiding complex
objects with lots of children nodes.</li>
</ul>
<h2 id="enablingdisabling-scene-nodes"><a class="header" href="#enablingdisabling-scene-nodes">Enabling/disabling scene nodes</a></h2>
<p>A scene node could be enabled or disabled. Disabled nodes are excluded from a game loop and has almost zero CPU consumption
(their global transform/visibility/enabled state is still updated due to limitations of the engine). Disabling a node
could be useful if you need to completely freeze some hierarchy and do keep it in this state until it is enabled again.
It could be useful to disable parts of a scene with which a player cannot interact to improve performance. Keep in mind,
that enabled state is hierarchical like visibility. When you're disabling a parent node with some children nodes, the
children nodes will be disabled too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-node"><a class="header" href="#mesh-node">Mesh node</a></h1>
<p>Mesh is a scene node that represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes could be easily created either programmatically or be made in some 3D modelling software (like Blender)
and loaded in your scene.</p>
<h2 id="surfaces"><a class="header" href="#surfaces">Surfaces</a></h2>
<p>Surface is a set of triangles that uses the same <a href="scene/../rendering/materials.html">material</a>. Mesh node could contain zero of
more surfaces; each surface contains a set of vertices and indices that binds vertices with triangles. Mesh nodes split
into surfaces to be rendered effectively by modern GPUs.</p>
<h2 id="how-to-create-3"><a class="header" href="#how-to-create-3">How to create</a></h2>
<p>There are basically two ways, how to pick one depends on your needs. In general, using a 3D modelling software is
the way to go, especially with tons and tons of free 3D models available online.</p>
<blockquote>
<p>⚠️ The engine supports <em>only</em> FBX and GLTF file format for 3D models!
To use GLTF, specify <code>gltf</code> feature of the engine in your root Cargo.toml</p>
</blockquote>
<h3 id="using-a-3d-modelling-software"><a class="header" href="#using-a-3d-modelling-software">Using a 3D modelling software</a></h3>
<p>To create a 3D model, you could use <a href="https://www.blender.org/">Blender</a> and then export it to <code>FBX</code> file format.
To load your 3D model in the game, you should do few simple steps (loading a 3D model does not differ from a prefab
instantiation):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_model_to_scene(
    scene: &amp;mut Scene,
    path: &amp;Path,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    // Request model resource and block until it loading.
    let model_resource = block_on(resource_manager.request::&lt;Model&gt;(path)).unwrap();

    // Create an instance of the resource in the scene.
    model_resource.instantiate(scene)
}
<span class="boring">}</span></code></pre></pre>
<p>This code snippet intentionally omits proper <code>async/await</code> usage (instead it just blocks current thread until
model is loading) and error handling. In the real game you should carefully handle all errors and use <code>async/await</code>
properly.</p>
<h3 id="creating-a-procedural-mesh"><a class="header" href="#creating-a-procedural-mesh">Creating a procedural mesh</a></h3>
<p>A mesh instance could be created from code, such meshes are called "procedural". They're suitable for cases when you
cannot create a mesh in 3D modelling software.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_procedural_mesh(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    let mut material = Material::standard();

    // Material is completely optional, but here we'll demonstrate that it is possible to
    // create procedural meshes with any material you want.
    material.bind(
        "diffuseTexture",
        Some(resource_manager.request::&lt;Texture&gt;("some_texture.jpg")),
    );

    // Notice the MeshBuilder.
    MeshBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, -0.25, 0.0))
                .build(),
        ),
    )
    .with_surfaces(vec![SurfaceBuilder::new(SurfaceResource::new_ok(
        ResourceKind::Embedded,
        // Our procedural mesh will have a form of squashed cube.
        // A mesh can have unlimited number of surfaces.
        SurfaceData::make_cube(Matrix4::new_nonuniform_scaling(&amp;Vector3::new(
            25.0, 0.25, 25.0,
        ))),
    ))
    .with_material(MaterialResource::new_ok(ResourceKind::Embedded, material))
    .build()])
    .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, creating a mesh procedurally requires lots of manual work and not so easy.</p>
<h2 id="animation-1"><a class="header" href="#animation-1">Animation</a></h2>
<p>Mesh node supports bone-based animation (skinning) and blend shapes. See <a href="scene/./../animation/animation.html">Animation chapter</a>
for more info.</p>
<h2 id="data-buffers"><a class="header" href="#data-buffers">Data Buffers</a></h2>
<p>It is possible to access vertex buffer and index buffer of a mesh to either read or write some data there.
For example, the following code extracts world-space positions of every vertex of an animated mesh:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract_world_space_vertices(mesh: &amp;Mesh, graph: &amp;Graph) -&gt; Vec&lt;Vector3&lt;f32&gt;&gt; {
    let mut vertices = Vec::new();

    for surface in mesh.surfaces() {
        let guard = surface.data();
        let data = guard.data_ref();

        for vertex in data.vertex_buffer.iter() {
            let Ok(position) = vertex.read_3_f32(VertexAttributeUsage::Position) else {
                continue;
            };

            let Ok(weights) = vertex.read_4_f32(VertexAttributeUsage::BoneWeight) else {
                continue;
            };

            let Ok(indices) = vertex.read_4_u8(VertexAttributeUsage::BoneIndices) else {
                continue;
            };

            let mut world_space_vertex = Vector3::default();
            for (weight, index) in weights.iter().zip(indices.iter()) {
                if let Some(bone_node) = surface
                    .bones()
                    .get(*index as usize)
                    .and_then(|bone_handle| graph.try_get(*bone_handle))
                {
                    let bone_transform =
                        bone_node.global_transform() * bone_node.inv_bind_pose_transform();
                    world_space_vertex += bone_transform
                        .transform_point(&amp;Point3::from(position))
                        .coords
                        .scale(*weight);
                }
            }

            vertices.push(world_space_vertex);
        }
    }

    vertices
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lighting"><a class="header" href="#lighting">Lighting</a></h1>
<p>This chapter explains how the lighting works in the engine and which methods of lighting it uses. Fyrox uses
industry-standard physically based rendering pipeline by default.</p>
<h2 id="ambient-lighting"><a class="header" href="#ambient-lighting">Ambient lighting</a></h2>
<p>The engine uses PBR pipeline which supports two major ways of applying ambient lighting.</p>
<h3 id="environment-lighting-via-ibl"><a class="header" href="#environment-lighting-via-ibl">Environment lighting (via IBL)</a></h3>
<p>Physically correct ambient image-based lighting (IBL). It uses an environment map as a source of lighting for the
entire scene. By default, every scene has an environment map with bright-blue sky, and this bright lighting is
used to light the scene. To change it, use the following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = fyrox::core::futures::join!(
        resource_manager.request::&lt;Texture&gt;("path/to/front.jpg"),
        resource_manager.request::&lt;Texture&gt;("path/to/back.jpg"),
        resource_manager.request::&lt;Texture&gt;("path/to/left.jpg"),
        resource_manager.request::&lt;Texture&gt;("path/to/right.jpg"),
        resource_manager.request::&lt;Texture&gt;("path/to/up.jpg"),
        resource_manager.request::&lt;Texture&gt;("path/to/down.jpg")
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
    .build()
    .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let skybox_texture = skybox.cubemap().unwrap();
    let mut data = skybox_texture.data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}

fn set_scene_skybox(scene: &amp;mut Scene, resource_manager: ResourceManager) {
    scene.set_skybox(create_skybox(resource_manager));
}
<span class="boring">}</span></code></pre></pre>
<p>This, however, may still produce weird lighting inside indoor scenes - all objects will be equally lit from
the respective side of the skybox. The engine has a special mechanism to solve this issue called reflection
probes. See the <a href="scene/probe.html">respective chapter for more info</a>.</p>
<h3 id="single-color-lighting"><a class="header" href="#single-color-lighting">Single-color lighting</a></h3>
<p>Simplest possible lighting, but not physically correct. Every scene has default ambient lighting setting, it is
defined by a single RGB color. By default, every scene has some pre-defined ambient lighting, it is bright enough,
so you can see your objects. In some cases, you may need to adjust it or even make it black (for horror games for
instance), this can be achieved by a few lines of code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_ambient_lighting(scene: &amp;mut Scene) {
    scene.rendering_options.ambient_lighting_color = Color::opaque(30, 30, 30);
    scene.rendering_options.environment_lighting_source = EnvironmentLightingSource::AmbientColor;
<span class="boring">}</span></code></pre></pre>
<p>Please keep in mind that ambient lighting does not mean global illumination, it is a different lighting technique
which is not available in the engine yet.</p>
<h2 id="light-sources"><a class="header" href="#light-sources">Light Sources</a></h2>
<p>There are number of built-in light sources:</p>
<ol>
<li>Directional Light</li>
<li>Point Light</li>
<li>Spot Light</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-node"><a class="header" href="#light-node">Light node</a></h1>
<p>The engine offers complex lighting system with various types of light sources.</p>
<h2 id="light-types"><a class="header" href="#light-types">Light types</a></h2>
<p>There are three main types of light sources: directional, point, and spotlights.</p>
<h3 id="directional-light"><a class="header" href="#directional-light">Directional light</a></h3>
<p>Directional light does not have a position, its rays are always parallel, and it has a particular direction in space.
An example of directional light in real-life could be our Sun. Even if it is a point light, it is so far away from
the Earth, so we can assume that its rays are always parallel. Directional light sources are suitable for outdoor
scenes.</p>
<p>A directional light source could be created like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_directional_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    DirectionalLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new())).build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>By default, the light source will be oriented to lit "the ground". In other words its direction will be faced towards
<code>(0.0, -1.0, 0.0)</code> vector. You can rotate it as you want by setting local transform of it while building. Something
like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_oriented_directional_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    DirectionalLightBuilder::new(BaseLightBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_rotation(UnitQuaternion::from_axis_angle(
                    &amp;Vector3::x_axis(),
                    -45.0f32.to_radians(),
                ))
                .build(),
        ),
    ))
    .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="point-light"><a class="header" href="#point-light">Point light</a></h3>
<p>Point light is a light source that emits lights in all directions, it has a position, but does not have an orientation.
An example of a point light source: light bulb.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_point_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    PointLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .with_radius(5.0)
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spotlight"><a class="header" href="#spotlight">Spotlight</a></h3>
<p>Spotlight is a light source that emits lights in cone shape, it has a position and orientation. An example of
a spotlight source: flashlight.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_spot_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    SpotLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .with_distance(5.0)
        .with_hotspot_cone_angle(50.0f32.to_radians())
        .with_falloff_angle_delta(10.0f32.to_radians())
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="light-scattering"><a class="header" href="#light-scattering">Light scattering</a></h2>
<p><img src="scene/scattering.png" alt="scattering" /></p>
<p>Spot and point lights support light scattering effect. Imagine you're walking with a flashlight in a foggy weather,
the fog will scatter the light from your flashlight making it, so you'll see the "light volume". Light scattering is
<strong>enabled by default</strong>, so you don't have to do anything to enable it. However, in some cases you might want to disable
it, you can do this either while building a light source or change light scattering options on existing light source.
Here is the small example of how to do that.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn disable_light_scatter(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;) {
    scene.graph[light_handle]
        .component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .enable_scatter(false);
}
<span class="boring">}</span></code></pre></pre>
<p>You could also change the amount of scattering per each color channel, using this you could imitate the
<a href="https://en.wikipedia.org/wiki/Rayleigh_scattering">Rayleigh scattering</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_rayleigh_scattering(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;) {
    scene.graph[light_handle]
        .component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .set_scatter(Vector3::new(0.03, 0.035, 0.055));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="shadows"><a class="header" href="#shadows">Shadows</a></h2>
<p>By default, light sources cast shadows. You can change this by using <code>set_cast_shadows</code> method of a light source. You
should carefully manage shadows: shadows giving the most significant performance impact, you should keep the number of
light sources that can cast shadows at lowest possible to keep performance at good levels. You can also turn
on/off shadows when you need:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn switch_shadows(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;, cast_shadows: bool) {
    scene.graph[light_handle]
        .component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .set_cast_shadows(cast_shadows);
}
<span class="boring">}</span></code></pre></pre>
<p>Not every light should cast shadows, for example a small light that a player can see only in a distance can have
shadows disabled. You should set the appropriate values depending on your scene, just remember: the fewer the shadows
the better the performance. The most expensive shadows are from point lights, the less, from spotlights and directional
lights.</p>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<p>Lights are not cheap, every light source has some performance impact. As a general rule, try to keep the amount
of light sources at reasonable levels and especially try to avoid creating tons of light sources in a small area.
Keep in mind that the less area the light needs to "cover", the higher the performance. This means that you can have
tons of small light sources for free.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflection-probe"><a class="header" href="#reflection-probe">Reflection Probe</a></h1>
<p>Reflection probe is an object that allows "capturing" a scene content in a cube texture, that
can later be used to render reflections and be used as a source of ambient lighting for a scene.</p>
<h2 id="update-mode"><a class="header" href="#update-mode">Update Mode</a></h2>
<p>Reflection probe can be updated either once or every frame. The default mode is [<code>UpdateMode::Once</code>].
If you need dynamic reflections, then use [<code>UpdateMode::EachFrame</code>] mode. However, it may lead
to performance issues.</p>
<h2 id="performance-3"><a class="header" href="#performance-3">Performance</a></h2>
<p>Reflection probe renders the scene six times which is quite slow. In most cases, it does not matter
because most of the probes can be updated just once (static probes). Such probes can have
increased resolution.</p>
<p>Dynamic probes are the heaviest and require careful performance tweaking. There should be a balance
between the resolution and the speed. Reflection probes does frustum culling, so some part of
the scene geometry can be excluded. This functionality can be tweaked by setting the far clipping
plane distance to lower values to prevent the probe to render distant objects.</p>
<h2 id="interaction-with-cameras"><a class="header" href="#interaction-with-cameras">Interaction With Cameras</a></h2>
<p>When rendering, the engine will automatically pick a reflection probe for a camera. It is done
by a simple point-box intersection test. This reflection probe will then be used for rendering
using the camera.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The following example creates a new reflection probe 20 units wide in all directions, centered
at (0.0, 10.0, 0.0) point with a rendering position offset by 10 units along X axis.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_probe(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    ReflectionProbeBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                // The center of the probe's bounding box is located 10 units above the ground.
                .with_local_position(Vector3::new(0.0, 10.0, 0.0))
                // The size of the probe's bounding box is 20 units.
                .with_local_scale(Vector3::repeat(20.0))
                .build(),
        ),
    )
    // Set resolution of the probe.
    .with_resolution(256)
    // The probe will capture the scene once it is created.
    .with_update_mode(UpdateMode::Once)
    // Set the capture point slightly off-center. The probe will capture the scene at
    // (10.0, 10.0, 0.0) point.
    .with_rendering_local_position(Vector3::new(10.0, 0.0, 0.0))
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite"><a class="header" href="#sprite">Sprite</a></h1>
<p>Sprite is just a quad mesh that is always facing camera. It has size, color, rotation around "look" axis and a texture.
Sprites are useful mostly for projectiles, like glowing plasma, and for things that should always face a camera.</p>
<blockquote>
<p>⚠️ It should be noted that <strong>sprites are not meant to be used for 2D games</strong>, they're only for 3D.
Use <a href="scene/./rectangle.html">Rectangle node</a> if you need 2D sprites.</p>
</blockquote>
<h2 id="how-to-create-4"><a class="header" href="#how-to-create-4">How to create</a></h2>
<p>A sprite instance could be created using <code>SpriteBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_sprite(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    SpriteBuilder::new(BaseBuilder::new())
        .with_size(2.0)
        .with_rotation(45.0f32.to_radians())
        .with_color(Color::RED)
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>A sprite with a texture could be created by using <code>.with_material</code> method of the builder:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_sprite_with_texture(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    let mut material = Material::standard_sprite();
    material.bind(
        "diffuseTexture",
        Some(resource_manager.request::&lt;Texture&gt;("path/to/your_texture.jpg")),
    );

    // Material resources can be shared across multiple sprites (via simple `clone`).
    // This significantly improves performance if you have multiple rectangles with the
    // same material.
    let material_resource = MaterialResource::new_ok(ResourceKind::Embedded, material);

    SpriteBuilder::new(BaseBuilder::new())
        .with_material(material_resource)
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Please note, that this code create a material per each sprite. This could be very unoptimal if you're using tons of
sprites at once, share the same material resource across multiple sprites if you can. Otherwise, each sprite will be
rendered in a separate draw call and the overall performance will be very low.</p>
<h2 id="animation-2"><a class="header" href="#animation-2">Animation</a></h2>
<p>See <a href="scene/../animation/spritesheet/spritesheet.html">Sprite Animation</a> chapter for more info.</p>
<h2 id="general-rules"><a class="header" href="#general-rules">General rules</a></h2>
<p>Sprites <strong>must not</strong> be used to create any visual effects that involve many particles. You should use
<a href="scene/particle_system_node.html">particle systems</a> for that. Why so? Particles systems are very well optimized for managing
huge amounts of particles at the same time, but sprites are not. Each sprite is quite heavy to be used as a particle in
particle systems, it has a lot of "useless" info that will eat a lot of memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-system"><a class="header" href="#particle-system">Particle system</a></h1>
<p>Particle system is a scene node that is used to create complex visual effects (VFX). It operates on huge amount
of particles at once allowing you to do complex simulation that involves large number of particles. Typically,
particle systems are used to create following visual effects: smoke, sparks, blood splatters, steam, etc.</p>
<p><img src="scene/./particle_system_example.png" alt="smoke" /></p>
<h2 id="basic-concepts-1"><a class="header" href="#basic-concepts-1">Basic Concepts</a></h2>
<p>Particle system uses <em>single</em> texture for every particle in the system, only Red channel is used. Red channel interpreted
as an alpha for all particles.</p>
<p>Every particle is affected by <code>Acceleration</code> parameters of the particle system. It defines acceleration
(in m/s<sup>2</sup>) that will affect velocities of every particle. It is used to simulate gravity.</p>
<h3 id="particle"><a class="header" href="#particle">Particle</a></h3>
<p>Particle is a square (not quadrilateral, this is important) with a texture which is always facing towards camera. It
has the following properties:</p>
<ul>
<li><code>Position</code> - defines a position in <em>local</em> coordinates of particle system (this means that if you rotate a particle
system, all particles will be rotated too).</li>
<li><code>Velocity</code> - defines a speed vector (in local coordinates) that will be used to modify local position of the particle
each frame.</li>
<li><code>Size</code> - size (in meters) of the square shape of the particle.</li>
<li><code>Size Modifier</code> - a numeric value (in meters per second), that will be added to the Size at each frame, it is used
to modify size of the particles.</li>
<li><code>Lifetime</code> - amount of time (in seconds) that the particle can be active for.</li>
<li><code>Rotation</code> - angle (in radians) that defines rotation around particle-to-camera axis (clockwise).</li>
<li><code>Rotation Speed</code> - speed (in radians per second, rad/s) of rotation of the particle.</li>
<li><code>Color</code> - RGBA color of the particle.</li>
</ul>
<h3 id="emitters"><a class="header" href="#emitters">Emitters</a></h3>
<p>Particle system uses <em>emitters</em> to define a set of zones where particles will be spawned, it also defines initial ranges of
parameters of particles. Particle system must have at least one emitter to generate particles.</p>
<p>Emitter can be one of the following types:</p>
<ul>
<li><code>Cuboid</code> - emits particles uniformly in a cuboid shape, the shape cannot be rotated, only translated.</li>
<li><code>Sphere</code> - emits particles uniformly in a sphere shape.</li>
<li><code>Cylinder</code> - emits particle uniformly in a cylinder shape, the shape cannot be rotated, only translated.</li>
</ul>
<p>Each emitter have fixed set of parameters that affects <em>initial</em> values for every spawned particle:</p>
<ul>
<li><code>Position</code> - emitter have its own <em>local</em> position (position relative to parent particle system node), this helps you
to create complex particle systems that may spawn particles from multiple zones in space at once.</li>
<li><code>Max Particles</code> - maximum number of particles available for spawn. By default, it is <code>None</code>, which says that there is
no limit.</li>
<li><code>Spawn Rate</code> - rate (in units per second) defines how fast the emitter will spawn particles.</li>
<li><code>Lifetime Range</code> - numeric range (in seconds) for particle lifetime values. The lower the beginning of the range
the less spawned particles will live, and vice versa.</li>
<li><code>Size Range</code> - numeric range (in meters) for particle size.</li>
<li><code>Size Modifier Range</code> - numeric range (in meters per second, m/s) for particle size modifier parameter.</li>
<li><code>X/Y/Z Velocity Range</code> - a numeric range (in meters per second, m/s) for a respective velocity axis (X, Y, Z)
that defines initial speed along the axis.</li>
<li><code>Rotation Range</code> - a numeric range (in radians) for initial rotation of a new particle.</li>
<li><code>Rotation Speed Range</code> - a numeric range (in radians per second, rad/s) for rotation speed of a new particle.</li>
</ul>
<p><strong>Important:</strong> Every range (like Lifetime Range, Size Range, etc.) parameter generates <em>random</em> value for respective
parameter of a particle. You can tweak the seed of current random number generator (<code>fyrox::core::thread_rng()</code>) to
ensure that generated values will be different each time.</p>
<h2 id="how-to-create-5"><a class="header" href="#how-to-create-5">How to create</a></h2>
<p>There are multiple ways of creating a particle system, pick one that best suits your current needs.</p>
<h3 id="using-the-editor"><a class="header" href="#using-the-editor">Using the editor</a></h3>
<p>The best way to create a particle system is to configure it in the editor, creating from code is possible too (see below),
but way harder and may be not intuitive, because of the large number of parameters. The editor allows you see the result
and tweak it very fast. Create a particle system by <code>Create -&gt; Particle System</code> and then you can start editing its
properties. By default, new particle system has one Sphere particle emitter, you can add new emitters by clicking <code>+</code>
button at the right of <code>Emitters</code> property in the Inspector (or remove by clicking <code>-</code>). Here's a simple example:</p>
<p><img src="scene/./particle_system.png" alt="particle system" /></p>
<p>Now start tweaking desired parameters, it is hard to give any recommendations of how to achieve a particular effect,
only practice matters here.</p>
<h3 id="using-the-code"><a class="header" href="#using-the-code">Using the code</a></h3>
<p>You can also create particle systems from code (in case if you need some procedurally-generated effects):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_smoke(graph: &amp;mut Graph, resource_manager: &amp;mut ResourceManager, pos: Vector3&lt;f32&gt;) {
    let mut material = Material::standard_particle_system();
    material.bind(
        "diffuseTexture",
        Some(resource_manager.request::&lt;Texture&gt;("data/particles/smoke_04.tga")),
    );
    let material_resource = MaterialResource::new_ok(ResourceKind::Embedded, material);

    ParticleSystemBuilder::new(
        BaseBuilder::new()
            .with_lifetime(5.0)
            .with_local_transform(TransformBuilder::new().with_local_position(pos).build()),
    )
    .with_acceleration(Vector3::new(0.0, 0.0, 0.0))
    .with_color_over_lifetime_gradient({
        let mut gradient = ColorGradient::new();
        gradient.add_point(GradientPoint::new(0.00, Color::from_rgba(150, 150, 150, 0)));
        gradient.add_point(GradientPoint::new(
            0.05,
            Color::from_rgba(150, 150, 150, 220),
        ));
        gradient.add_point(GradientPoint::new(
            0.85,
            Color::from_rgba(255, 255, 255, 180),
        ));
        gradient.add_point(GradientPoint::new(1.00, Color::from_rgba(255, 255, 255, 0)));
        gradient
    })
    .with_emitters(vec![SphereEmitterBuilder::new(
        BaseEmitterBuilder::new()
            .with_max_particles(100)
            .with_spawn_rate(50)
            .with_x_velocity_range(-0.01..0.01)
            .with_y_velocity_range(0.02..0.03)
            .with_z_velocity_range(-0.01..0.01),
    )
    .with_radius(0.01)
    .build()])
    .with_material(material_resource)
    .build(graph);
}
<span class="boring">}</span></code></pre></pre>
<p>This code creates smoke effect with smooth dissolving (by using color-over-lifetime gradient). Please refer to
<a href="https://docs.rs/fyrox/latest/fyrox/scene/particle_system/index.html">API docs</a> for particle system for more information.</p>
<h3 id="using-prefabs"><a class="header" href="#using-prefabs">Using prefabs</a></h3>
<p>If you need to create particle systems made in the editor, you can always use prefabs. Create a scene with desired
particle system and then <a href="scene/../resources/model.html#instantiation">instantiate</a> it to your scene.</p>
<h2 id="soft-particles"><a class="header" href="#soft-particles">Soft particles</a></h2>
<p>Fyrox used special technique, called soft particles, that smooths sharp transitions between particles and scene geometry:</p>
<p><img src="scene/./soft_particles.png" alt="soft particles" /></p>
<p>This technique especially useful for effects such as smoke, fog, etc. where you don't want to see the "edge" between
particles and scene geometry. You can tweak this effect using <code>Soft Boundary Sharpness Factor</code>, the larger the value
the more "sharp" the edge will be and vice versa.</p>
<h2 id="restarting-emission"><a class="header" href="#restarting-emission">Restarting emission</a></h2>
<p>You can "rewind" particle systems in the "initial" state by calling <code>particle_system.clear_particles()</code> method, it
will remove all generated particles and emission will start over.</p>
<h2 id="enabling-or-disabling-particle-systems"><a class="header" href="#enabling-or-disabling-particle-systems">Enabling or disabling particle systems</a></h2>
<p>By default, every particle system is enabled. Sometimes there is a need to create a particle system, but not enable
it (for example for some delayed effect). You can achieve this by calling <code>particle_system.set_enabled(true/false)</code>
method. Disabled particle systems will still be drawn, but emission and animation will be stopped. To hide particle
system completely, use <code>particle_system.set_visibility(false)</code> method.</p>
<h2 id="performance-4"><a class="header" href="#performance-4">Performance</a></h2>
<p>Particle systems using special renderer that optimized to draw millions of particles with very low overhead, however
particles simulated on CPU side and may significantly impact overall performance when there are many particle systems
with lots of particles in each.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Particle systems does not interact with lighting, this means that particles will not be lit by light sources in the scene.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terrain"><a class="header" href="#terrain">Terrain</a></h1>
<p>Terrain is a scene node that represents uniform grid of cells where each cell can have different height. Other, commonly
known name for terrain is heightmap. Terrains used to create maps for open-world games, it is used to create hills,
mountains, plateau, roads, etc.</p>
<p><img src="scene/./terrain.png" alt="terrain" /></p>
<h2 id="basic-concepts-2"><a class="header" href="#basic-concepts-2">Basic concepts</a></h2>
<p>There are few basic concepts that you should understand before trying to use terrains. This will help you to understand
design decisions and potential use cases.</p>
<h3 id="heightmap"><a class="header" href="#heightmap">Heightmap</a></h3>
<p>As it was already mentioned, terrain is a uniform grid where X and Z coordinates of cells have fixed values, while Y
can change. In this case we can store only width, height and resolution numerical parameters to calculate X and Z coordinates,
while Y is stored in a separate array which is then used to modify heights of cells. Such array is called <em>heightmap</em>.</p>
<p><img src="scene/./terrain_mesh.png" alt="terrain mesh" /></p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>Layer is a material + mask applied to terrain's mesh. Mask is a separate, greyscale texture that defines in which parts
of the terrain the material should be visible or not. White pixels in the mask makes the material to be visible, black -
completely transparent, everything between helps you to create smooth transitions between layers. Here's a simple
example of multiple layers:</p>
<p><img src="scene/./terrain_layers_layout.png" alt="terrain layers layout" /></p>
<p>There are 3 layers: 1 - dirt, 2 - grass, 3 - rocks and grass. As you can see, there are smooth transitions between each
layer, it is achieved by layer's mask.</p>
<p>Each layer uses separate material, which can be edited from respective property editor in the Inspector:</p>
<p><img src="scene/./terrain_layer_material.png" alt="terrain layer material" /></p>
<h2 id="creating-terrain-in-the-editor"><a class="header" href="#creating-terrain-in-the-editor">Creating terrain in the editor</a></h2>
<p>You can create a terrain node by clicking <code>Create -&gt; Terrain</code>. It will create a terrain with fixed width, height,
and resolution (see <a href="scene/./terrain_node.html#limitations-and-known-issues">limitations</a>). Once the terrain is created, select
it in the World Viewer and click on Hill icon on the toolbar. This will enable terrain editing, brush options panel
should also appear. See the picture below with all the steps:</p>
<p><img src="scene/./terrain_editing.png" alt="terrain editing" /></p>
<p>The green rectangle on the terrain under the cursor represents current brush. You can edit brush options in the
<code>Brush Options</code> window:</p>
<p><img src="scene/./brush_options.png" alt="brush options" /></p>
<ul>
<li><em>Shape:</em> Select a circular brush or a rectangular brush. When a circular brush is selected, a control to adjust its
radius appears. When a rectangular brush is select, controls for its width and length appear. The size of the green
rectangle changes to reflect the size of the brush based on these controls.</li>
<li><em>Mode:</em> Select the terrain editing operation that the brush should perform.
<ul>
<li><em>Raise or Lower:</em> Modifies the existing value by a fixed amount. When the number is positive, the value is
increased. When the number is negative, the value is decreased. When the brush target is "Height Map", this can be
to raise or lower the terrain. When the <code>Shift</code> key is held at the start of a brush stroke, the number of raising or lowering
is negated, so a raise operation becomes a lowering operation.</li>
<li><em>Assign Value:</em> Replaces the existing value with a given value. For example, if you want to create a plateau
with land of a specific height, you can select this mode and type in the height you want as the brush value.</li>
<li><em>Flatten:</em> Levels terrain by spreading the value of the terrain from point where you click across wherever
you drag the brush. It works just like <em>Assign Value</em> except you do not need to specify the desired value because it
is taken automatically from the value of the terrain where the brush stroke starts.</li>
<li><em>Smooth:</em> For each point of the terrain touched by the brush, replace that value with an average of the nearby values.
This tends to diminish sharp transitions in terrain value.</li>
</ul>
</li>
<li><em>Target:</em> There are multiple aspects of terrain that can be edited by a brush, and this control allows you to select which
one you will be editing. Setting it to "Height Map" causes the brush to change the terrain elevation.
Setting it to "Layer Mask" causes it to change the transparency of the layer with a chosen index.
Masks are always clamped to be between 0 and 1, regardless of what brush mode is selected, since 0 represents fully transparent
and 1 represents the layer being fully opaque.</li>
<li><em>Transform:</em> This is a 2x2 matrix that is applied to the brush's shape, allowing linear transformations such as rotating
a rectangular brush, or skewing, or stretching.
For most purposes the identity matrix of \(\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix}\) works well, since that is the default that applies no modification to the brush's shape.
If the matrix is not invertable, then it will be ignored.</li>
<li><em>Hardness:</em> The effect of a brush does not need to be applied equally across its entire area. The <em>hardness</em>
of a brush controls how much of a brush gets its full effect.
When hardness is 0, only the exact center of the brush receives the full effect, while the rest of the brush fades from
full effect to no effect at the edges.
When hardness is 1 or greater, the entire brush gets the full effect.
If the value is less than 0, then even the center of the brush does not receive the full effect.</li>
<li><em>Alpha:</em> The \(\alpha\) value linearlly interpolates between the current value of the terrain and the value that would be
produced by the full effect of the brush.
If \(v_0\) is the current value of a point on the terrain and and \(v_1\) is the full effect of the brush, then the actual
effect that the brush will apply will be \((1 - \alpha) * v_0 + \alpha * v_1\).
There is no requirement that \(\alpha\) must be between 0 and 1. Values less than 0 will invert the effect of the brush,
while values greater than 1 will exaggerate the effect of the brush.
Values close to 0 can be used to make fine adjustments by applying an effect incrementally across multiple brush strokes.</li>
</ul>
<p>Each brush stroke is treated as an independent operation starting from when the mouse button is pressed and ending when
the mouse button is released. Repeatedly dragging the mouse across the same area of terrain will not increase the effect
of the brush as it is all part of the same brush stroke, but repeatedly pressing and releasing the mouse button will
cause the brush's effect to be applied repeatedly since that is counted as multiple brush strokes.</p>
<h2 id="creating-terrain-from-code"><a class="header" href="#creating-terrain-from-code">Creating terrain from code</a></h2>
<p>Terrain brushes can also be used to edit terrain from code by using <code>fyrox::scene:terrain::Brush</code> and <code>fyrox::scene::terrain::BrushContext</code>.</p>
<p>The <code>Brush</code> structure has fields for each of the brush options, and the <code>BrushContext</code> structure has methods for accepting a <code>Brush</code> and
applying it to a terrain. BrushContext allows you to start a new stroke, perform stamps and smears during the stroke, then end the stroke
to write the constructed brush stroke to the terrain. It is also possible to <code>flush</code> a partially finished stroke to the terrain, so that
a brush stroke may be animated across multiple frames instead of appearing on the terrain all at once.</p>
<p>Here is a list of methods provided by <code>BrushContext</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn start_stroke(&amp;mut self, terrain: &amp;Terrain, brush: Brush)
<span class="boring">}</span></code></pre></pre>
<p>Call this to choose the brush that will be used for the rest of the stroke. At this point the <code>BrushContext</code> records which textures the
terrain is using to represent the data for the given brush's target. and those textures are the ones that will finally be modified
when <code>end_stroke</code> is eventually called.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn stamp(&amp;mut self, terrain: &amp;Terrain, position: Vector3&lt;f32&gt;)
<span class="boring">}</span></code></pre></pre>
<p>Call this to stamp the brush at a single point on the terrain. A stroke should already have been started, as this is potentially just
one operation out of many that could make up a stroke.</p>
<p>The terrain is not modified; it is only being used to translate the the given position from world space to terrain texture space.
In order to actually see the results of this stamp in the terrain, <code>flush</code> or <code>end_stroke</code> must be called.</p>
<p>The y-coordinate of the position is ignored as the position is projected onto the terrain.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn smear(&amp;mut self, terrain: &amp;Terrain, start: Vector3&lt;f32&gt;, end: Vector3&lt;f32&gt;)
<span class="boring">}</span></code></pre></pre>
<p>A smear is just like a stamp, except it continuously paints with the brush along a line from <code>start</code> to <code>end</code>.
Again, a stroke should already have been started in order to select the brush to paint with, and the results will not
appear immediately on the terrain.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn flush(&amp;mut self)
<span class="boring">}</span></code></pre></pre>
<p>Call this to force the terrain to update to include the modifications due to a partially completed brush stroke.
If a stroke is being drawn across multiple frames, it would make sense to call <code>flush</code> at the end of each frame.
The <code>flush</code> method does not require the terrain to be passed in because <code>BrushContext</code> already knows which textures
need to be modified in order to update the terrain.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn end_stroke(&amp;mut self)
<span class="boring">}</span></code></pre></pre>
<p>Call this to update the terrain to include the modifications due to the stroke, and clear all data for that stroke
so that the context is ready to begin a new stroke.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shape(&amp;mut self) -&gt; &amp;mut BrushShape
<span class="boring">}</span></code></pre></pre>
<p>This provides mutable access to the brush's shape, making it possible to change the shape without starting a new stroke.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hardness(&amp;mut self) -&gt; &amp;mut f32
<span class="boring">}</span></code></pre></pre>
<p>This provides mutable access to the brush's hardness, making it possible to change the hardness without starting a new stroke.</p>
<p>There are also similiar methods for changing the brush's alpha and mode in the middle of a stroke, but these are unlikely to serve
any practical use as brush strokes do not tend to react well to such changes. It is best to start a new stroke if a new brush mode
is needed. It is particularly not possible to change the brush's target in the middle of a stroke, because that would require
updating other details of the internal state of the <code>BrushContext</code>.</p>
<p>Here is an example of <code>BrushContext</code> in use:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_layer_material(
    material: &amp;mut Material,
    resource_manager: ResourceManager,
    diffuse_texture: &amp;str,
    normal_texture: &amp;str,
) {
    material.bind(
        "diffuseTexture",
        Some(resource_manager.request::&lt;Texture&gt;(diffuse_texture)),
    );
    material.bind(
        "normalTexture",
        Some(resource_manager.request::&lt;Texture&gt;(normal_texture)),
    );
    material.set_property("texCoordScale", Vector2::new(10.0, 10.0));
}

pub fn create_random_two_layer_terrain(
    graph: &amp;mut Graph,
    resource_manager: &amp;ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    let terrain = TerrainBuilder::new(BaseBuilder::new())
        .with_layers(vec![
            Layer {
                material: {
                    let mut material = Material::standard_terrain();
                    setup_layer_material(
                        &amp;mut material,
                        resource_manager.clone(),
                        "examples/data/Grass_DiffuseColor.jpg",
                        "examples/data/Grass_NormalColor.jpg",
                    );
                    MaterialResource::new_ok(ResourceKind::Embedded, material)
                },
                ..Default::default()
            },
            Layer {
                material: {
                    let mut material = Material::standard_terrain();
                    setup_layer_material(
                        &amp;mut material,
                        resource_manager.clone(),
                        "examples/data/Rock_DiffuseColor.jpg",
                        "examples/data/Rock_Normal.jpg",
                    );
                    MaterialResource::new_ok(ResourceKind::Embedded, material)
                },
                ..Default::default()
            },
        ])
        .build(graph);

    let terrain_ref = graph[terrain].as_terrain_mut();
    let mut context = BrushContext::default();

    // Draw something on the terrain.
    for _ in 0..60 {
        let x = thread_rng().gen_range(4.0..60.00);
        let z = thread_rng().gen_range(4.0..60.00);
        let radius = thread_rng().gen_range(2.0..4.0);
        let height = thread_rng().gen_range(1.0..3.0);
        let tail_x = thread_rng().gen_range(-5.0..=5.0);
        let tail_z = thread_rng().gen_range(-5.0..=5.0);

        // Pull terrain.
        context.start_stroke(
            terrain_ref,
            Brush {
                shape: BrushShape::Circle { radius },
                mode: BrushMode::Raise { amount: height },
                target: BrushTarget::HeightMap,
                hardness: 0.0,
                ..Brush::default()
            },
        );
        context.stamp(terrain_ref, Vector3::new(x, 0.0, z));
        *context.shape() = BrushShape::Circle {
            radius: radius * 0.5,
        };
        context.smear(
            terrain_ref,
            Vector3::new(x, 0.0, z),
            Vector3::new(x + tail_x, 0.0, z + tail_z),
        );
        context.end_stroke();

        // Draw rock texture on top.
        context.start_stroke(
            terrain_ref,
            Brush {
                shape: BrushShape::Circle { radius },
                mode: BrushMode::Assign { value: 1.0 },
                target: BrushTarget::LayerMask { layer: 1 },
                hardness: 0.0,
                ..Brush::default()
            },
        );
        context.stamp(terrain_ref, Vector3::new(x, 0.0, z));
        *context.shape() = BrushShape::Circle {
            radius: radius * 0.5,
        };
        context.smear(
            terrain_ref,
            Vector3::new(x, 0.0, z),
            Vector3::new(x + tail_x, 0.0, z + tail_z),
        );
        context.end_stroke();
    }

    terrain
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see there is quite a lot of code, ideally you should use editor all the times, because handling everything
from code could be very tedious. The result of its execution (if all textures are set correctly) could be something
like this (keep in mind that terrain will be random everytime you run the code):</p>
<p><img src="scene/./terrain_random.png" alt="terrain from code" /></p>
<h2 id="physics-1"><a class="header" href="#physics-1">Physics</a></h2>
<p>By default, terrains does not have respective physical body and shape, it should be added manually. Create a static
rigid body node with a collider with Heightmap shape (<a href="scene/../physics/collider.html">learn more about colliders</a>). Then attach
the terrain to the rigid body. Keep in mind that terrain's origin differs from Heightmap rigid body, so you need to offset
the terrain to match its physical representation. Enable physics visualization in editor settings to see physical shapes
and move terrain. Now to move the terrain you should move the body, instead of the terrain (because of parent-child
<a href="scene/../beginning/scene_and_scene_graph.html#local-and-global-coordinates">relations</a>).</p>
<h2 id="performance-5"><a class="header" href="#performance-5">Performance</a></h2>
<p>Terrain rendering complexity have linear dependency with the number of layers terrain have. Each layer forces the engine
to re-render terrain's geometry with different textures and mask. Typical number of layers is from 4 to 8. For example,
a terrain could have the following layers: dirt, grass, rock, snow. This is a relatively lightweight scheme. In any case,
you should measure frame time to understand how each new layer affects performance in your case.</p>
<h2 id="chunking"><a class="header" href="#chunking">Chunking</a></h2>
<p>Terrain itself does not define any geometry or rendering data, instead it uses one or more chunks for that purpose. Each
chunk could be considered as a "sub-terrain". You can "stack" any number of chunks from any side of the terrain. To do
that, you define a range of chunks along each axis. This is very useful if you need to extend your terrain in a particular
direction. Imagine that you've created a terrain with just one chunk (<code>0..1</code> range on both axes), but suddenly you found
that you need to extend the terrain to add some new game locations. In this case you can change the range of chunks at
the desired axis. For instance, if you want to add a new location to the right from your single chunk, then you should
change <code>width_chunks</code> range to <code>0..2</code> and leave <code>length_chunks</code> as is (<code>0..1</code>). This way terrain will be extended, and
you can start shaping the new location.</p>
<h2 id="level-of-detail"><a class="header" href="#level-of-detail">Level-of-detail</a></h2>
<p>Terrain has automatic LOD system, which means that the closest portions of it will be rendered with the highest
possible quality (defined by the resolution of height map and masks), while the furthest portions will be
rendered with the lowest quality. This effectively balances GPU load and allows you to render huge terrains with
low overhead.</p>
<p>The main parameter that affects LOD system is <code>block_size</code> (<code>Terrain::set_block_size</code>), which defines size of the patch
that will be used for rendering. It is used to divide the size of the height map into a fixed set of blocks using
quad-tree algorithm.</p>
<p>Current implementation uses modified version of CDLOD algorithm without patch morphing. Apparently it is not needed,
since bilinear filtration in vertex shader prevents seams to occur.</p>
<p>Current implementation makes it possible to render huge terrains (64x64 km) with 4096x4096 heightmap resolution in about a
millisecond on average low-to-middle-end GPU.</p>
<h2 id="limitations-and-known-issues"><a class="header" href="#limitations-and-known-issues">Limitations and known issues</a></h2>
<p>There is no way to cut holes in the terrain yet, it makes impossible to create caves. There is also no way to create
ledges, use separate meshes to imitate this. See <a href="https://github.com/FyroxEngine/Fyrox/issues/351">tracking issue</a> for
more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="camera-node"><a class="header" href="#camera-node">Camera node</a></h1>
<p>Camera is a special scene node that allows you to "look" at your scene from any point and with any orientation.
Currently, the engine supports only <em>perspective</em> cameras, which could be represented as a frustum volume. Everything
that "intersects" with the frustum will be rendered.</p>
<p><img src="scene/./frustum.svg" alt="Frustum" /></p>
<h2 id="how-to-create-6"><a class="header" href="#how-to-create-6">How to create</a></h2>
<p>An instance of camera node could be created using <code>CameraBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_camera(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        // Set some properties.
        .with_fov(80.0f32.to_radians())
        .with_z_far(256.0)
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Orientation and position should be set in <code>BaseBuilder</code> as usual.</p>
<h2 id="projection-modes"><a class="header" href="#projection-modes">Projection modes</a></h2>
<p>Projection mode defines how your scene will look like after rendering, there are two projection modes available.</p>
<h3 id="perspective"><a class="header" href="#perspective">Perspective</a></h3>
<p>Perspective projection makes distant objects smaller and parallel lines converging when using it, it is the most
common projection type for 3D games. By default, each camera uses perspective projection. It's defined by three
parameters that describes frustum volume:</p>
<ul>
<li>Field of view angle</li>
<li>Near clipping plane location</li>
<li>Far clipping plane location</li>
</ul>
<p>Here is a simple example of how to create a camera with perspective projection:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_perspective_camera(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_projection(Projection::Perspective(PerspectiveProjection {
            // Keep in mind that field of view expressed in radians!
            fov: 60.0f32.to_radians(),
            z_near: 0.025,
            z_far: 1024.0,
        }))
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="orthographic"><a class="header" href="#orthographic">Orthographic</a></h3>
<p>Orthographic projection prevents parallel lines from converging, it does not affect object size with distance.
If you're making 2D games or isometric 3D games, this is the projection mode you're looking for. Orthographic
projection defined by three parameters:</p>
<ul>
<li>Vertical Size</li>
<li>Near Clipping Plane</li>
<li>Far Clipping Plane</li>
</ul>
<p>Vertical size defines how large the "box" will be in vertical axis, horizontal size is derived from vertical
size by multiplying vertical size with aspect ratio.</p>
<p>Here is a simple example of how to create a camera with orthographic projection:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_orthographic_camera(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_projection(Projection::Orthographic(OrthographicProjection {
            vertical_size: 5.0,
            z_near: 0.025,
            z_far: 1024.0,
        }))
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-6"><a class="header" href="#performance-6">Performance</a></h2>
<p>Each camera forces engine to re-render scene one more time, which can be very resource-intensive (both CPU and GPU)
operation.</p>
<p>To reduce GPU load, try to keep the Far Clipping Plane at lowest possible values. For example, if you're making a game
with closed environment (lots of corridors, small rooms, etc.) set the Far clipping Plane to max possible distance that
can be "seen" in your game - if the largest thing is a corridor, then set the Far clipping Plane to slightly exceed the
length. This will force the engine to clip everything that is out of bounds and do not draw such objects.</p>
<h2 id="skybox"><a class="header" href="#skybox">Skybox</a></h2>
<p>Outdoor scenes usually have distant objects that can't be reached, these can be mountains, sky, distant forest, etc.
such objects can be pre-rendered and then applied to a huge cube around camera, it will always be rendered first and will
be the background of your scene. To create a Skybox and set it to a camera, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<h2 id="color-grading-look-up-tables"><a class="header" href="#color-grading-look-up-tables">Color grading look-up tables</a></h2>
<p>Color grading Look-Up Tables (LUT) allows you to transform color space of your frame. Probably everyone saw the
famous "mexican" movie effect when everything becomes yellow-ish when action takes place in Mexico, this is done
via color grading LUT effect. When used wisely, it can significantly improve perception of your scene.</p>
<p>Here is the same scene having no color correction along with another case that has "mexico" color correction:</p>
<div class="table-wrapper"><table><thead><tr><th>Scene</th><th>Look-up-table</th></tr></thead><tbody>
<tr><td><img src="scene/./no_color_correction.PNG" alt="No Color Correction" /></td><td><img src="scene/./lut_neutral.jpg" alt="Neutral LUT" /></td></tr>
<tr><td><img src="scene/./with_color_correction.PNG" alt="With Color Correction" /></td><td><img src="scene/./lut_mexico.jpg" alt="Neutral LUT" /></td></tr>
</tbody></table>
</div>
<p>To use color grading LUT you could do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_camera_with_lut(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_color_grading_enabled(true)
        .with_color_grading_lut(
            block_on(ColorGradingLut::new(
                resource_manager.request::&lt;Texture&gt;("path/to/lut.jpg"),
            ))
            .unwrap(),
        )
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="picking"><a class="header" href="#picking">Picking</a></h2>
<p>In some games you may need to do mouse picking of objects in your scene. To do that, at first you need to somehow convert
a point on the screen to ray in the world. <code>Camera</code> has <code>make_ray</code> method exactly for that purpose:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_picking_ray(camera: &amp;Camera, point: Vector2&lt;f32&gt;, renderer: &amp;Renderer) -&gt; Ray {
    camera.make_ray(point, renderer.get_frame_bounds())
}
<span class="boring">}</span></code></pre></pre>
<p>The ray then can be used to <a href="scene/../physics/ray.html">perform a ray cast over physics entities</a>. This is the simplest way
of camera picking, and you should prefer it most of the time.</p>
<h3 id="advanced-picking"><a class="header" href="#advanced-picking">Advanced picking</a></h3>
<p><strong>Important</strong>: The following picking method is for advanced engine users only, if you don't know the math you should not
use it.</p>
<p>If you know the math and don't want to create physical entities, you can use this ray to perform manual
ray intersection check:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_vertex_position(data: &amp;SurfaceData, i: u32) -&gt; Option&lt;Vector3&lt;f32&gt;&gt; {
    data.vertex_buffer
        .get(i as usize)
        .and_then(|v| v.read_3_f32(VertexAttributeUsage::Position).ok())
}

fn transform_vertex(vertex: Vector3&lt;f32&gt;, transform: &amp;Matrix4&lt;f32&gt;) -&gt; Vector3&lt;f32&gt; {
    transform.transform_point(&amp;Point3::from(vertex)).coords
}

fn read_triangle(
    data: &amp;SurfaceData,
    triangle: &amp;TriangleDefinition,
    transform: &amp;Matrix4&lt;f32&gt;,
) -&gt; Option&lt;[Vector3&lt;f32&gt;; 3]&gt; {
    let a = transform_vertex(read_vertex_position(data, triangle[0])?, transform);
    let b = transform_vertex(read_vertex_position(data, triangle[1])?, transform);
    let c = transform_vertex(read_vertex_position(data, triangle[2])?, transform);
    Some([a, b, c])
}

pub fn precise_ray_test(
    node: &amp;Node,
    ray: &amp;Ray,
    ignore_back_faces: bool,
) -&gt; Option&lt;(f32, Vector3&lt;f32&gt;)&gt; {
    let mut closest_distance = f32::MAX;
    let mut closest_point = None;

    if let Some(mesh) = node.component_ref::&lt;Mesh&gt;() {
        let transform = mesh.global_transform();

        for surface in mesh.surfaces().iter() {
            let data = surface.data();
            let data = data.data_ref();

            for triangle in data
                .geometry_buffer
                .iter()
                .filter_map(|t| read_triangle(&amp;data, t, &amp;transform))
            {
                if ignore_back_faces {
                    // If normal of the triangle is facing in the same direction as ray's direction,
                    // then we skip such triangle.
                    let normal = (triangle[1] - triangle[0]).cross(&amp;(triangle[2] - triangle[0]));
                    if normal.dot(&amp;ray.dir) &gt;= 0.0 {
                        continue;
                    }
                }

                if let Some(pt) = ray.triangle_intersection_point(&amp;triangle) {
                    let distance = ray.origin.sqr_distance(&amp;pt);

                    if distance &lt; closest_distance {
                        closest_distance = distance;
                        closest_point = Some(pt);
                    }
                }
            }
        }
    }

    closest_point.map(|pt| (closest_distance, pt))
}
<span class="boring">}</span></code></pre></pre>
<p><code>precise_ray_test</code> is what you need, it performs precise intersection check with geometry of a mesh node. It returns a
tuple of the closest distance and the closest intersection point.</p>
<h2 id="exposure-and-hdr"><a class="header" href="#exposure-and-hdr">Exposure and HDR</a></h2>
<p>(WIP)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decal-node"><a class="header" href="#decal-node">Decal node</a></h1>
<p>Decal nodes allow you to "project" a texture onto your scene within some specific bounds. It is widely used for
bullet holes, blood splatter, dirt, cracks and so on. Here is the example of the decal applied to the scene:</p>
<p><img src="scene/./decal.PNG" alt="Decal" /></p>
<p>The rust marks are applied on existing geometry of the scene by projecting a rust texture in specific direction.</p>
<h2 id="how-to-create-7"><a class="header" href="#how-to-create-7">How to create</a></h2>
<p>A decal instance can be created using DecalBuilder:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_decal(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    DecalBuilder::new(BaseBuilder::new())
        .with_diffuse_texture(resource_manager.request::&lt;Texture&gt;("path/to/your/decal.png"))
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="textures"><a class="header" href="#textures">Textures</a></h2>
<p>You can specify which textures the decal will be projecting, currently there is only diffuse and normal maps
supported.</p>
<h2 id="rendering-1"><a class="header" href="#rendering-1">Rendering</a></h2>
<p>Currently, the engine supports only <em>deferred decals</em>, which means that decals modify the information stored in
G-Buffer. This fact means that decals will be lit correctly with other geometry in the scene. However, if you
have some objects in your scene that uses forward rendering path, your decals won't be applied to them.</p>
<h2 id="bounds"><a class="header" href="#bounds">Bounds</a></h2>
<p>Decal uses Object-Oriented Bounding Box (OOB) to determine pixels on which decal's textures will be projected,
everything that got into OOB will be covered. Exact bounds can be set by tweaking local transform of a decal.
If you want your decal to be larger, set its scale to some large value. To position a decal - use local position,
to rotate - local rotation.</p>
<p>A decal defines a cube that projects a texture on every pixel of a scene that got into the cube. Exact cube size
is defined by decal's local scale. For example, if you have a decal with scale of (1.0, 2.0, 0.1) then the size of
the cube (in local coordinates) will be width = 1.0, height = 2.0 and depth = 0.1. The decal can be rotated as any
other scene node. Its final size and orientation are defined by the chain of transformations of parent nodes.</p>
<h2 id="layers-1"><a class="header" href="#layers-1">Layers</a></h2>
<p>There are situations when you want to prevent some geometry from being covered with a decal, to do that the engine
offers a concept of layers. A decal will be applied to a geometry if and only if they have matching layer index. This
allows you to create environment damage decals, and they won't affect dynamic objects since they're located on
different layers.</p>
<h2 id="performance-7"><a class="header" href="#performance-7">Performance</a></h2>
<p>Current implementation of decals is relatively cheap, this allows you to create many decals on scene. However, you
should keep the number of decals at a reasonable level.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rectangle-node"><a class="header" href="#rectangle-node">Rectangle node</a></h1>
<p>Rectangle is the simplest "2D" node, it can be used to create "2D" graphics. 2D is in quotes here because the node
is actually a 3D node, like everything else in the engine. Here is an example scene made with the rectangle nodes and
an orthographic camera:</p>
<p><img src="scene/2d_scene.PNG" alt="2d scene" /></p>
<p>As you can see it is a good basis for 2D games.</p>
<h2 id="how-to-create-8"><a class="header" href="#how-to-create-8">How to create</a></h2>
<p>Use the RectangleBuilder to create Rectangle nodes:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_rect(graph: &amp;mut Graph, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    let mut material = Material::standard_2d();
    material.bind(
        "diffuseTexture",
        Some(resource_manager.request::&lt;Texture&gt;("path/to/your_texture.jpg")),
    );

    // Material resources can be shared across multiple rectangles (via simple `clone`).
    // This significantly improves performance if you have multiple rectangles with the
    // same material.
    let material_resource = MaterialResource::new_ok(ResourceKind::Embedded, material);

    RectangleBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                // Size of the rectangle is defined only by scale.
                .with_local_scale(Vector3::new(0.4, 0.2, 1.0))
                .build(),
        ),
    )
    .with_color(Color::RED)
    .with_material(material_resource)
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="specifying-image-portion-for-rendering"><a class="header" href="#specifying-image-portion-for-rendering">Specifying image portion for rendering</a></h2>
<p>By default, Rectangle node uses entire image for rendering, but for some applications it is not enough. For example,
you may want to use sprite sheets to animate your 2D entities. In this case you need to be able to use only portion
of an image. It is possible to do by using <code>set_uv_rect</code> method of the Rectangle node. Here's an example of setting
right-top quarter of an image to be used by a Rectangle node:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_2nd_quarter_image_portion(rectangle: &amp;mut Rectangle) {
    rectangle.set_uv_rect(Rect::new(
        0.5, // Offset by 50% to the right
        0.0, // No need to offset to bottom.
        0.5, // Use half (50%) of width and height
        0.5,
    ));
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind that every part of uv rectangle is proportional. For example 0.5 means 50%, 1.5 = 150% and so on. If width
or height is exceeding 1.0 and the texture being used is set to Wrapping mode at respective axis, the image will tile
across axes.</p>
<h2 id="animation-3"><a class="header" href="#animation-3">Animation</a></h2>
<p>See <a href="scene/../animation/spritesheet/spritesheet.html">Sprite Animation</a> chapter for more info.</p>
<h2 id="performance-8"><a class="header" href="#performance-8">Performance</a></h2>
<p>Rectangles use specialized renderer that is heavily optimized to render tons of rectangles at once, so you can use
rectangles almost for everything in 2D games.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tile-map"><a class="header" href="#tile-map">Tile Map</a></h1>
<p>Tile map is a 2D "image", made out of a small blocks called tiles. Tile maps used in 2D games to build game worlds
quickly and easily. An example of a tile map could be something like this:</p>
<p><img src="scene/tile_map.png" alt="tile map" /></p>
<h2 id="how-to-create-9"><a class="header" href="#how-to-create-9">How to Create</a></h2>
<p>A tile map comes in two pieces: A <code>TileMap</code> node that can be added to a scene, and a <code>TileSet</code> resource that holds the
data required to render each tile.</p>
<p>Tiles in a tile set are organized into pages. Each page has a position on a 2D grid along with all the other pages in the
tile set, and each page contains another 2D grid where the tiles are arranged. Pages and tiles can be positioned anywhere
on their grids according to whatever organizational principles you please. The chosen position for each tile becomes its
handle, called a <code>TileDefinitionHandle</code>, and this handle is what will be stored in the tile map to determine how to render
the tiles.</p>
<p>Here is an example handle: <code>(0,2):(-3,5)</code>. This handle means that the tile is on the page at coordinates
(0,2) and the tile data is at (-3,5) within that page's grid. Once a handle like this has been put into a tile map cell,
the tile map rendering process will look for a page at that position and a tile at that position within the page.
If it fails to find a page at that position, or the tile position is empty in the page, then a pink texture will be
rendered to indicate a missing tile texture. Be aware of this if you are considering changing the position of
pages or tiles in the tile set.</p>
<p><strong>Warning:</strong> If you change the position of a page, tile maps <em>will not be automatically updated to find the
page at its new position.</em> It may be best to choose the positions of pages carefully and never change them.</p>
<p>Tile set pages come in multiple varieties depending on what data will be stored in each grid cell of the page.</p>
<ul>
<li>
<p><strong>Atlas:</strong> An atlas page renders all of its tiles using a single shared material that acts as a sprite sheet.
The material starts at the upper-left corner of tile (0,-1) and extends down into negative-y cells and right
into positive-x cells. Any tiles that you add to an atlas page will be rendered with their UV-coordinates based
on their position on the page
relative to the material.</p>
</li>
<li>
<p><strong>Freeform:</strong> A freeform page is a collection of tiles with their own independent materials and UV-coordinate positions.
Unlike an atlas page, the positions of tiles in a freeform page does not matter, but each tile needs to have its
material and UV-coordinates specified manually. Tile UV-coordinates are measured in pixels of the texture, not
from 0.0 to 1.0.</p>
</li>
<li>
<p><strong>Transform:</strong> A transform set page stores handles to tiles on other pages and represents how tiles may be flipped
or rotated. The page is divided into 2x4 sets of cells. Within each set, the left 2x2 cells hold tiles that may be
transformed into each other by 90-degree rotations. The right 2x2 cells represent same tiles horizontally mirrored.
The tile set resource can search its transform pages to convert any handle into the handle of a flipped or rotated
version of the tile.</p>
</li>
<li>
<p><strong>Animation:</strong> An animation page stores handles to tiles on other pages and represents how tiles change their appearance
over time. Each animation on the page is represented by a horizontal sequence of tile handles. Any tile whose handle
is on an animation page becomes an animated tile, and its appearance will cycle from left-to-right along its row
until it comes to an empty cell, then it will will start again from the first non-empty cell to its left.
When tiles animate through an animation page, the tile map data does not actually change over time; only the rendering changes.</p>
<p>If the same handle appears in more than one cell on an animation page, then the animation starts at the first occurrence
of the handle, when reading the page from left-to-right and top-to-bottom, as one would read a book.</p>
</li>
</ul>
<p>Once we have a tile set resource, we can create a tile map node and set its <code>tile_set</code> field to point to our resource.
Then we can fill the tile map node with the handles for whatever tiles we want to render.</p>
<p>As usual, there are two major ways of creating a tile map - via code or via the editor. Code-based approach is ideal for
procedural worlds, while the editor-based approach is good for hand-crafted worlds.</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>The following example creates a simple tile map with two tile types - grass and stone. It creates stone foundation and
lays grass on top of it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_tile_map(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    // Each tile could have its own material, for simplicity it is just a standard 2D material.
    let material = MaterialResource::new_ok(ResourceKind::Embedded, Material::standard_tile());

    // Create a tile set - it is a data source for the tile map. Tile map will reference the tiles
    // stored in the tile set by handles. We'll create two tile types with different colors.
    // In order to create a tile set, we must first create a tile set page.
    let mut tiles = TileGridMap::default();
    // Now we decide where we want our tiles to live on that page by creating TileDefinitionHandles for our tiles.
    // Each tile definition handle has four numbers: the (x,y) of the page, and the (x,y) of the tile within the page.
    let stone_tile = TileDefinitionHandle::new(0, 0, 0, 0);
    let grass_tile = TileDefinitionHandle::new(0, 0, 1, 0);
    // Now we insert tile data for each tile in our new page.
    tiles.insert(
        stone_tile.tile(),
        TileDefinition {
            material_bounds: TileMaterialBounds {
                material: material.clone(),
                bounds: TileBounds {
                    left_top_corner: Vector2::new(0, 0),
                    right_top_corner: Vector2::new(16, 0),
                    left_bottom_corner: Vector2::new(0, 16),
                    right_bottom_corner: Vector2::new(16, 16),
                },
            },
            data: TileData {
                color: Color::BROWN,
                properties: FxHashMap::default(),
                colliders: FxHashMap::default(),
            },
        },
    );
    tiles.insert(
        grass_tile.tile(),
        TileDefinition {
            material_bounds: TileMaterialBounds {
                material: material.clone(),
                bounds: TileBounds {
                    left_top_corner: Vector2::new(0, 0),
                    right_top_corner: Vector2::new(16, 0),
                    left_bottom_corner: Vector2::new(0, 16),
                    right_bottom_corner: Vector2::new(16, 16),
                },
            },
            data: TileData {
                color: Color::GREEN,
                properties: FxHashMap::default(),
                colliders: FxHashMap::default(),
            },
        },
    );
    // Finish creating the page.
    let source = TileSetPageSource::Freeform(tiles);
    let page = TileSetPage {
        // The icon is the handle of a tile that would represent the page in the editor.
        icon: stone_tile,
        // The tiles that we've created.
        source,
    };
    // Finally we create our tile set and add our page to it at position (0,0).
    let mut tile_set = TileSet::default();
    tile_set.insert_page(Vector2::new(0, 0), page);
    let tile_set = TileSetResource::new_ok(ResourceKind::Embedded, tile_set);

    // This positions of all the tiles in our tile map using their TileDefinitionHandle
    // to find the tiles in the tile set.
    let mut tiles = Tiles::default();

    // Create stone foundation.
    for x in 0..10 {
        for y in 0..2 {
            tiles.insert(Vector2::new(x, y), stone_tile);
        }
    }

    // Add grass on top of it.
    for x in 0..10 {
        tiles.insert(Vector2::new(x, 2), grass_tile);
    }

    // Finally create the tile map.
    TileMapBuilder::new(BaseBuilder::new())
        .with_tile_set(tile_set)
        .with_tiles(&amp;tiles)
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Please refer to the API docs for more info about each method.</p>
<h3 id="editor-1"><a class="header" href="#editor-1">Editor</a></h3>
<p>Editor-based approach requires a bit of preparation, yet it is still simple. First you need a tile set, something like this:</p>
<p><img src="scene/tileset.png" alt="tile set" /></p>
<p>It is a 11x11 sprite sheet for a top-down game. Now you need to create a tile set resource from this tile set. Navigate
the asset browser and click on <code>+</code> button near the search bar. Select <code>TileSet</code> resource and click <code>OK</code>. Find the resource
you've just created in the asset browser, then double-click on it to open the tile set editor.</p>
<p><img src="scene/tile_set_editor.png" alt="tile set editor" /></p>
<h4 id="creating-an-atlas-page"><a class="header" href="#creating-an-atlas-page">Creating an Atlas Page</a></h4>
<p>Now it is time to create the first page for our new tile set. Click anywhere in the upper grid to select the position for
the page, then click the "Tile Atlas" button under "Create New Page" on the right side of the editor.</p>
<p>Because the selected page position is no longer empty, the "Create New Page" menu is replaced by an inspector for the
properties of the new atlas page. Here you can edit the material for the tiles and change the size of the tiles as measured
in texture pixels. These properties can be changed at any time, and the resulting changes will affect all the tiles of the page.</p>
<p>Once you have set your sprite sheet as the texture for the material, the texture will become visible in the lower grid of the
editor. Use the scroll wheel to zoom and pan if necessary to see all of it. This is only a <em>preview</em> of what the tiles might
look like; the tiles have not yet been created, and the texture is faded to distinguish it from actual tiles.
You can adjust the fade using the "Material Tint" color field in the top-right of the editor. This has no affect on the tile
set resource; it is purely cosmetic within the editor.</p>
<p>To actually create some tiles, left-click and drag on the lower grid to select whatever areas of the material should have
tiles. Holding shift will allow you to select multiple areas at once. Once you are satisfied with your selection,
press the "Create Tile" button on the right side of the editor. This will fill any empty selected cells with new tiles,
covering the faded material preview with the full-color of actual tiles.</p>
<h4 id="creating-a-freeform-page"><a class="header" href="#creating-a-freeform-page">Creating a Freeform Page</a></h4>
<p>Select any empty cell in the upper grid to cause the "Create New Page" menu to appear. Click "Free Tiles" button to
start creating freeform tiles on your tile set's new page. Unlike the atlas page, a freeform page has very few properties
to edit in the inspector. This is because each tile has its own material and size fields.</p>
<p><img src="scene/freeform_tile_edit.png" alt="Freeform tile edit" /></p>
<p>Select any empty cell in the lower grid and click "Create Tile" to begin editing the properties for a new freeform tile.
At the top is a field for choosing the material for the tile. It will initially be a blank material with the
standard tile shader. Below that are four pairs of coordinates that represent for points on the material's texture as
measured in texture pixels. The left-top point represents the left-top corner of the tile, and so on around all four
corners of the tile.</p>
<p>Below the tile corners are four buttons for performing flips and rotations on the corner coordinates. By changing the
coordinates of the corners of the tile, the tile can be rotated by 90 degrees and flipped horizontally and vertically.</p>
<p>Next there is the tile's color which can be used to apply tinting or transparency to the tile.</p>
<p>It is also possible to add tiles to a freeform page by painting them with tools on the Tile Map Control Panel which will
be discussed later.</p>
<h4 id="creating-a-transform-page"><a class="header" href="#creating-a-transform-page">Creating a Transform Page</a></h4>
<p>Once you have prepared a library of tiles with your tile set, you may want to specify which tiles are mirrored or rotated
versions of other tiles. This will allow the tile set to produce a flipped or rotated version of a tile just by giving it
the handle of the tile and the desired transformation. Start by selecting an empty page cell and clicking "Transform"
under "Create New Page."</p>
<p>In the lower grid area you should see that the cells have been divided into 2x4 groups. Each cell of these groups can store
a <code>TileDefinitionHandle</code> and the eight handles together will specify all possible combinations of flips and 90-degree rotations
that may be needed for a tile. The left 2x2 tiles are supposed to be a horizontal reflection of the right 2x2 tiles,
and within each 2x2 the tiles are supposed to rotate as you look clockwise or counter-clockwise around the square, as illustrated below.</p>
<p><img src="scene/tile_map_rotate.png" alt="Transform page" /></p>
<p>In order to fill this page with tile handles, click the "Palette" button in the upper-right to open the "Tile Map Control Panel" window,
if it is not already open. This is the same window that you will use to edit a tile map, and so it has tools designed for selecting
tile handles and putting them wherever you want them. The panel should already be showing the grid of pages from your tile set.
If the panel is showing something else, then find your tile set in the asset browser and drag it onto the panel.</p>
<p>Use the panel to select a page from your tile set, and then select a tile that you want to put into your transform page.
Click the button with the paint brush icon to activate the brush tool, then click in the tile set editor to paint the handle
for the selected tile into a cell of the transform page. The tools available for painting, moving, copying, and deleting
tile handles will be discussed in more detail later.</p>
<h4 id="creating-an-animation-page"><a class="header" href="#creating-an-animation-page">Creating an Animation Page</a></h4>
<p>In order to make your tiles move over time, first create a sequence of animation frames for your tile, and make a tile
for each from using an atlas page or a freeform page. Now we are ready to create an animation page.</p>
<p><img src="scene/tile_map_animation.png" alt="Animation page" /></p>
<p>While the animation page is selected, choose the frame rate for animations on this page, measured in frames per second.
All animations on the same page share the same frame rate.</p>
<p>Editing an animation page is just like editing a transform page, but instead of organizing the tile handles in groups of eight,
we are creating horizontal sequences of tiles. These sequences can start and end anywhere on the page, so long as there is an
empty cell immediately to the left and right of the sequence to indicate where the sequence begins and ends. The editor will
draw a mark in the empty cells to confirm where the animation starts and ends. When an animation reaches the end of the sequence
it automatically repeats.</p>
<p>As soon as you have finished making your animation page, your tile set will already be animating. The editor may not draw frames
as smoothly as a running game, so put some animated tiles in your tile map and then run your game to see the full effect of the animation.</p>
<h4 id="creating-the-tile-map-node"><a class="header" href="#creating-the-tile-map-node">Creating the Tile Map Node</a></h4>
<p>Now we have the tile set, and we can start creating a tile map using it. Click <code>Create -&gt; 2D -&gt; Tile Map</code> and you should
see something like this:</p>
<p><img src="scene/empty_tile_map.png" alt="empty tile map" /></p>
<p>If you look closely, the editor warns us about a missing tile set. Find the tile set you've just made and drag'n'drop it
from the asset browser to the <code>Tile Set</code> field in the inspector.</p>
<h2 id="tile-map-brush"><a class="header" href="#tile-map-brush">Tile Map Brush</a></h2>
<p>There's one more step before we start editing the tile map—we may want a brush to paint on the tile map.
Click <code>+</code> button in the asset browser and select <code>TileMapBrush</code>, set a name for it and click <code>OK</code>.
Now select the tile map scene node and drag'n'drop the brush you've just created to "Active Brush" property.
This will make it the default brush whenever you edit this tile map node.</p>
<p>Double-click the brush asset in the asset browser to open the tile set editor again. This time the editor will be
in brush-editing mode, which is simpler because a brush has only one kind of page and it has no tabs for properties
or collision. The purpose of a brush is just to create convenient arrangements of tile handles from some tile set
to streamline the process of tile map editing.</p>
<p>Drag the tile set asset from the asset browser into the "Tile Set" field in the upper-right of the tile set editor to
store a reference to the tile set in the brush asset. The brush needs to know which tile set its tile handles refer to.</p>
<p>Click some empty cell in the upper grid of the editor and then click "Add Page" to add your first page to the brush.</p>
<p>Next, press the "Palette" button to open the Tile Map Control Panel so that you can paint some tile handles into the
new brush. Initially the control panel will show the tiles and pages of the brush you are currently editing, which
is no help when the brush is empty, so click the "Tile Set" button in the control panel to switch to showing the pages
and tiles of the tile set. Select some tiles and paint them into the brush in whatever arrangement is most convenient
for editing.</p>
<p>Unlike a tile set resource, the content of a brush resource is only used in the editor, so you can re-arrange the pages
and tiles of your brush or even delete your brush without any consequences for your tile map or for the running game.
While you can draw tiles to the tile map directly from the tile set, using a brush offers far more flexibility in
how you arrange your tiles, allowing you to create multiple copies of tiles and arrange tiles in convient groups that
gather your most-often-used tiles.</p>
<p>At this point everything is ready for painting. Select the tile map node and click tile map interaction mode button
at the top of the Scene Preview window. You should now see the tile map grid in the Scene Preview. The Tile Map Control Panel
should automatically open if it is not already open, and it should be showing the pages and tiles of your brush.</p>
<p><img src="scene/grid.png" alt="grid" /></p>
<p>Select some tiles on the control panel and start drawing:</p>
<p><img src="scene/drawing.png" alt="drawing" /></p>
<h2 id="drawing-tools"><a class="header" href="#drawing-tools">Drawing Tools</a></h2>
<p>There are number of tools that could be useful while editing tile maps when in the tile map interaction mode.</p>
<h3 id="brush-tool"><a class="header" href="#brush-tool">Brush Tool</a></h3>
<p><img src="scene/tile_map_tools/brush_tool.png" alt="Brush tool" /></p>
<p>The brush tool takes whatever tiles are selected and puts the handles for those tiles wherever you click on the selected tile map.
The selected tiles are called the stamp, and the stamp will be used in one way or another by each of the drawing tools.
You can select any number of tiles and their handles will be drawn in the same relative positions where you click, or you can use
the flip and rotation buttons to flip and rotate the stamp before drawing it. The preview area of the Tile Map Control Panel
shows approximately what the tiles should look like when they are drawn.</p>
<h3 id="erase-tool"><a class="header" href="#erase-tool">Erase Tool</a></h3>
<p><img src="scene/tile_map_tools/erase_tool.png" alt="Erase tool" /></p>
<p>Erases tiles using the shape of the current stamp. Activate it using the <code>2</code> key or by clicking on the
button with eraser icon.</p>
<p><img src="scene/erase.gif" alt="erase" /></p>
<h3 id="flood-fill-tool"><a class="header" href="#flood-fill-tool">Flood Fill Tool</a></h3>
<p><img src="scene/tile_map_tools/flood_tool.png" alt="Flood fill tool" /></p>
<p>Fills a region with the same tile kind (or empty space) using the tiles of the current stamp.
Activate it using the button with paint bucket icon.</p>
<p>Unlike the other tools, the flood fill tool is not implemented for use in the Tile Set Editor,
so in the Tile Set Editor the flood tool will just act like the brush tool.</p>
<p><img src="scene/flood_fill.gif" alt="flood fill" /></p>
<h3 id="pick-tool"><a class="header" href="#pick-tool">Pick Tool</a></h3>
<p><img src="scene/tile_map_tools/pick_tool.png" alt="Pick tool" /></p>
<p>Picks a rectangular region of tiles from the tile map itself and turns them into the current stamp.
Hold shift to add additional rectangular regions to the stamp.
Activate it using the <code>1</code> key or by clicking the button with pipette icon.</p>
<p>Hold alt to drag the currently selected tiles and move them to a different location in the tile map,
or tile set editor page. You can also use this to change the position of a page in the tile set editor,
but beware that the position of a tile set page is part of a tile's handle, so moving a page can invalidate
any handle that refers to a tile on that page. Handles are not destroyed when they are invalidated this way;
they merely fail to render correctly until a page is added to the tile set with a tile where the handle
is expecting to find tile data.</p>
<h3 id="rectangular-fill-tool"><a class="header" href="#rectangular-fill-tool">Rectangular Fill Tool</a></h3>
<p><img src="scene/tile_map_tools/rect_tool.png" alt="Rect fill tool" /></p>
<p>Fills a rectangular region with the tiles from the current stamp. It tiles the given region using the
tiles from current stamp. Could be activated using <code>3</code> key or by clicking on the button with the tiles icon.</p>
<p>To randomize the order of the tiles within the rectangle, toggle the on the dice button.</p>
<p><img src="scene/rect_fill.gif" alt="rect fill" /></p>
<h3 id="nine-slice-tool"><a class="header" href="#nine-slice-tool">Nine Slice Tool</a></h3>
<p><img src="scene/tile_map_tools/nine_tool.png" alt="Nine slice tool" /></p>
<p>Fills a rectangular region using a rectangluer stamp divided into nine sections: four corners, four sides, and the center.
The corners of the stamp will be placed at the corners of the selected region. The sides of the stamp will fill the sides
of the selected reation, and the center of the stamp will fill the center of the selected region.</p>
<p>To randomize the order of the tiles within the rectangle, toggle the on the dice button.</p>
<p><img src="scene/nine_slice.gif" alt="nine slice" /></p>
<h3 id="line-tool"><a class="header" href="#line-tool">Line Tool</a></h3>
<p><img src="scene/tile_map_tools/line_tool.png" alt="Nine slice tool" /></p>
<p>Drag the mouse from one cell to another to draw a line of tiles between the two cells using the tiles of the current brush.</p>
<h2 id="physics-2"><a class="header" href="#physics-2">Physics</a></h2>
<p>Tile maps support physics for tiles, if collision shape data is included in the tile set. Start by opening the
tile set editor, then click on the "Collison" tab at the top of the window. This will allow you to edit
the list of collision layers of the tile set. Each layer allows a collision shape to be added to the tiles,
so with multiple layers a tile may have multiple collison shapes.</p>
<p>Each layer has a name and a color, and in code it can be identified by a UUID. The color is cosmetic, and
controls how the shapes on that layer appear when they are visible. The name is used to identify the layer
for a 2D rigid body.</p>
<p>There are currently three different ways to set the collision shape for each tile:</p>
<ul>
<li>
<p><strong>None:</strong> The tile has no collision shape, the default.</p>
</li>
<li>
<p><strong>Full:</strong> The tile's full square is covered by a collision shape.</p>
</li>
<li>
<p><strong>Custom:</strong> The user supplies a list of triangles to construct a collision shape.</p>
</li>
</ul>
<p>In code, custom collision shapes are created using a <code>fyrox::scene::tilemap::CustomTileCollider</code> which is a simple struct like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomTileCollider {
    /// The vertices of the triangles, with the boundaries of the tile being between (0,0) and (1,1).
    pub vertices: Vec&lt;Vector2&lt;f32&gt;&gt;,
    /// The indices of the vertices of each triangle
    pub triangles: Vec&lt;TriangleDefinition&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>To create a custom tile collider in the editor, it is currently required that the user manually types in the information
as a list of vertices and triangle indices, such as "(0,0) (1,1) (1,0) [0,1,2]". This would create a triangle covering the
bottom right half of the tile. The parentheses and brackets are optional and are ignored; only the numbers and commas are parsed
to understand the user's intended triangles.</p>
<p><img src="scene/tile_collider_edit.png" alt="Tile with custom collision shape" /></p>
<p>Click the eye button next to the collision layer to toggle visibility of collision shapes for that layer.
Collisions shapes will be drawn over the tiles in the color you have chosen for that collision layer,
so it is best to choose an alpha value with some transparency.</p>
<h3 id="adding-a-2d-rigid-body"><a class="header" href="#adding-a-2d-rigid-body">Adding a 2D Rigid Body</a></h3>
<p>Enable physics for a tile map by using the collider shape called <code>TileMap</code> and specifying the name of the layer.
In code it could be done something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_tile_map_physics(tile_map: Handle&lt;Node&gt;, graph: &amp;mut Graph) {
    // Create a new collider with tile map shape.
    let collider = ColliderBuilder::new(BaseBuilder::new())
        .with_shape(ColliderShape::TileMap(TileMapShape {
            tile_map: GeometrySource(tile_map),
            layer_name: "MainColliders".into(),
        }))
        .build(graph);

    // Create a static rigid body with the tile map collider.
    let rigid_body = RigidBodyBuilder::new(BaseBuilder::new().with_children(&amp;[collider]))
        .with_body_type(RigidBodyType::Static)
        .build(graph);
}
<span class="boring">}</span></code></pre></pre>
<p>In the editor it could be done by creating a static 2D rigid body with a 2D collider that has the <code>TileMap</code> shape.
Give the shape the tile map and the name of the collision layer that the rigid body is supposed to represent.</p>
<p><img src="scene/tile_map_physics.png" alt="tile map physics" /></p>
<h2 id="layers-2"><a class="header" href="#layers-2">Layers</a></h2>
<p>Tile map does not support any layers on its own, but layers can be added very easily by simply creating another tile
map with its own tile set and shifting this new layer by Z axis towards camera by some small value.</p>
<h2 id="tile-properties"><a class="header" href="#tile-properties">Tile Properties</a></h2>
<p>Tile set could contain custom properties for each tile, these properties could be used to attach additional information
to the tiles in your game. This could include surface type (water, lava, dirt, etc.), physics properties (friction,
restitution, etc.) and any other you need.</p>
<p>In the tile set editor, create properties using the "Properties" tab which gives you access to a list of property layers.
Each property layer has a data type, and the type must be chosen when the layer is created, since changing the type of
an already existing layer could cause tiles to have the wrong type of value for the property.</p>
<p><img src="scene/tile_map_properties.png" alt="Tile map properties editor" /></p>
<p>Each property may also have a list of pre-defined values. Each pre-defined value has a name and a color to help the user
visualize which tiles have that value for the property and to help keep track of the meaning of that value.
Once a property has been created in the Properties tab, the value for that property can be set for each tile in the
Tiles tab.</p>
<p>In code, properties can be created, set, and accessed like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SOIL: i32 = 1;
const SLIME: i32 = 2;
const SURFACE_TYPE_UUID: Uuid = uuid!("a70a754b-eed5-4e60-bf8a-3239f0b6004b");

fn create_tile_map_with_props(graph: &amp;mut Graph) {
    let material = MaterialResource::new_ok(ResourceKind::Embedded, Material::standard_2d());

    let mut tiles = TileGridMap::default();
    let stone_tile = TileDefinitionHandle::new(0, 0, 0, 0);
    let grass_tile = TileDefinitionHandle::new(0, 0, 1, 0);
    tiles.insert(
        stone_tile.tile(),
        TileDefinition {
            material_bounds: TileMaterialBounds {
                material: material.clone(),
                bounds: TileBounds {
                    left_top_corner: Vector2::new(0, 0),
                    right_top_corner: Vector2::new(16, 0),
                    left_bottom_corner: Vector2::new(0, 16),
                    right_bottom_corner: Vector2::new(16, 16),
                },
            },
            data: TileData {
                color: Color::BROWN,
                properties: [(SURFACE_TYPE_UUID, TileSetPropertyValue::I32(SLIME))]
                    .into_iter()
                    .collect(),
                colliders: FxHashMap::default(),
            },
        },
    );
    tiles.insert(
        grass_tile.tile(),
        TileDefinition {
            material_bounds: TileMaterialBounds {
                material: material.clone(),
                bounds: TileBounds {
                    left_top_corner: Vector2::new(0, 0),
                    right_top_corner: Vector2::new(16, 0),
                    left_bottom_corner: Vector2::new(0, 16),
                    right_bottom_corner: Vector2::new(16, 16),
                },
            },
            data: TileData {
                color: Color::GREEN,
                properties: [(SURFACE_TYPE_UUID, TileSetPropertyValue::I32(SOIL))]
                    .into_iter()
                    .collect(),
                colliders: FxHashMap::default(),
            },
        },
    );
    let source = TileSetPageSource::Freeform(tiles);
    let page = TileSetPage {
        icon: TileDefinitionHandle::new(0, 0, 0, 0),
        source,
    };
    let mut tile_set = TileSet::default();
    tile_set.insert_page(Vector2::new(0, 0), page);
    tile_set.properties.push(TileSetPropertyLayer {
        name: "SurfaceType".into(),
        uuid: SURFACE_TYPE_UUID,
        prop_type: TileSetPropertyType::F32,
        named_values: Vec::default(),
    });
    let tile_set = TileSetResource::new_ok(ResourceKind::Embedded, tile_set);

    // ..
}

fn calculate_speed_factor(tile_map: &amp;TileMap, player_position: Vector3&lt;f32&gt;) -&gt; f32 {
    let grid_position = tile_map.world_to_grid(player_position);

    match tile_map.tile_property_value(grid_position, SURFACE_TYPE_UUID) {
        Ok(SOIL) =&gt; 1.0,
        Ok(SLIME) =&gt; 0.7,
        Ok(_) =&gt; {
            Log::err("Unknown surface type");
            1.0
        }
        // See fyrox::scene::tilemap::TilePropertyError for a list of possible errors.
        Err(err) =&gt; {
            Log::err(err.to_string());
            1.0
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>Here we have two types of tiles - soil and slime, soil does not have any effect on player's movement speed, while the
slime slows down the player by 30%. This code does not actually use any physical contact information and just uses tile
position, but it could be fixed pretty easily - supply physical contact position to it, and it will return correct results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autotiling"><a class="header" href="#autotiling">Autotiling</a></h1>
<p>An advanced feature of tile map brushes is the ability to create macros that can automate some aspects of tile map editing. These macros include <em>Autotile</em> and <em>Wave Function Collapse</em>.</p>
<h2 id="the-autotile-macro"><a class="header" href="#the-autotile-macro">The Autotile Macro</a></h2>
<p>To make a tile map look more natural, there will often be tiles that seamlessly blend with their neighboring tiles, and many versions of a tile may be created depending on its which neighbors it is to be used with. A set of tiles that represent various versions of the same tile for this purpose is sometimes called a <em>terrain</em>, and each tile in a terrain will have a pattern which specifies which other tiles it may be adjacent to when creating a seamless tile map.</p>
<p>A simple case is when a tile set has just two terrains, such as land and water. In this case each land tile may have a water along its edges depending on whether there is a water tile in each of the eight directions. If there is no water in a direction, then the land tile can smoothly blend with the land tile in that direction. In order to have land tiles that account for both possibilities in all eight directions, 47 land tiles are required.</p>
<p>Here is a template that illustrates the 47 required tiles:</p>
<p><img src="scene/autotile_template.png" alt="Template" /></p>
<p>And here is an example tile set created using the above template:</p>
<p><img src="scene/autotile_tiles.png" alt="Tile Set" /></p>
<p>Even more tiles are required if three or more different terrains are involved. Selecting the right tile from such large tile sets can be time-consuming for an artist while editing a tile map unless we automate the task.</p>
<p>The Autotile macro can search the tile set to automatically find the right tile for any terrain, but first we must specify the pattern for every tile in the terrain. To do this we need a nine-slice property in the tile set. A nine-slice property gives every tile a 3x3 array of 8-bit values, and this array will be the tile's pattern that determines which other tiles it may be adjacent to.</p>
<p>The center of the 3x3 array is a number that represents the tile's terrain. Every tile with the same center value is considered to be part of the same terrain. The default value of 0 is treated specially and any tile with a 0 value is not part of any terrain and will be ignored by the autotiler.</p>
<p>The surrounding eight values in the 3x3 array are called <em>peering bits</em> because they specify which neighbors this tile may be adjancent to. Only neighbors with the same peering bits along the matching edge may be adjacent to this tile.</p>
<p>The 3x3 pattern with zeroes in every cell is reserved to represent the empty tile. When a peering bit is 0, that indicates that this tile may be adjacent to an empty tile in that that direction.</p>
<p><img src="scene/autotile_setup1.gif" alt="Creating a tile property to represent the pattern" /></p>
<p>Named values can be used to make it easier to remember the meaning of each value in the 3x3 grid.</p>
<p>Even though the center value is not part of the process of determining whether to two tiles may be adjacent, it is important that the center value matches the peering bits when appropriate because the autotiler compares the center value against the surrounding peering bits in its heuristic to decide which tile it will choose. The autotiler prioritizes choosing tiles where more peering bits are equal to the center value.</p>
<p>This heuristic is important because tiles like this technically match along their shared edge:</p>
<p><img src="scene/autotile_match.png" alt="Unfortunately matching tiles" /></p>
<p>Because the right side of the left pattern is all 2s and the left side of the right pattern is all 2s, the autotiler might choose these two tiles to be adjacent to each other, but since these tiles are in the 1 terrain, the heuristic will cause the autotiler to prefer patterns with more 1s and avoid creating unnecessary seams.</p>
<p>Now that we have a nine-slice property to store our patterns and we understand what values should go in each tile's pattern, we can use the tile set editor to fill in the patterns for each tile.</p>
<p><img src="scene/autotile_setup2.gif" alt="Drawing the patterns for each tile" /></p>
<p>Select one of the tiles in the terrain, then go to the property and click the brush tool beside the property. This puts the tile set editor into property drawing mode and allows you to paint property values onto tile tiles. Enter the number you wish to draw in the property field, then click and drag the mouse on the tiles to apply that value to any cell of any tile.</p>
<p>If you do not already have a float property to represent the frequency of each tile, you may want to add one because the autotiler can optionally use that property when it is forced to randomly choose a tile. The autotiler is intended to deterministically choose the best tile in any situation, but when two tiles share exactly the same pattern, the autotiler will use randomness to pick between the tiles.</p>
<p>Once the tile set is ready, all that remains is to add an autotile macro to the tile map's brush. Open the brush in the tile set editor and switch to the "Macros" tab.</p>
<p><img src="scene/autotile_create_macro.gif" alt="Adding an autotile macro" /></p>
<p>Click the "Autotile" button to add an autotile macro to the brush's list of macros. On the right side you will see the macro's name field and the settings that control how the macro will modify your tile map drawing operations. Choose a name for the macro, as this may help later.</p>
<p>Set the pattern property to whichever nine-slice property you used to store the patterns using the dropdown list. If the dropdown list is empty, go back to the "Tiles" tab and ensure that the brush is set to use the correct tile set.</p>
<p>You may choose to leave the frequency property as "None." In that case, all tiles will be assumed to have equal frequency, just as if you gave them all a frequency of 1.0.</p>
<p>Finally, return to the "Tiles" tab and add some terrain tiles alongside whatever normal tiles you may be using. Add a tile from the tile set or select an existing tile, then find the name of the autotile macro that you created in the tile properties on the right. Click the "+" button to add this tile to the macro.</p>
<p>Once the tile is added to the macro, the macro will know to activate whenever you attempt to draw this tile into the tile map. As soon as the "+" is pressed, additional settings will appear for the tile: "Terrain", "Adjacent", and "Diagonal".</p>
<p>"Terrain" is the center value of the pattern of the tiles you wish to draw. Whenever you draw with this tile, the autotile macro will attempt to replace the tile with the best available tile from the tile set with this center value. If no appropriate tile is available, then the autotiler will not replace the tile. If "Terrain" is set to 0, the autotiler will attempt to replace the tile you draw with the empty tile.</p>
<p>The "Adjacent" toggle indicates that the autotiler should also try to replace the four orthogonally adjacent tiles surrounding the tile you drew. This allows nearby tiles to dynamically adapt as you draw. The "Diagonal" toggle is similar, but for the four tiles that surround the tile diagonally.</p>
<p>Turning "Adjacent" and "Diagonal" on makes the autotiler more aggressive in that it will modify tiles even if you have not explicitly drawn on them, which is often desired, but turning "Adjacent" and "Diagonal" off can give the artist more control.</p>
<p>Once you have added all the terrains you will need to the brush, close the tile set editor and select the tile map you want to edit. Activate the tile map interaction mode and open the brush in the tile map control panel, then select one of the terrain tiles you created and draw something.</p>
<p><img src="scene/autotile_in_use.gif" alt="Autotile being used" /></p>
<h2 id="the-wave-function-collapse-macro"><a class="header" href="#the-wave-function-collapse-macro">The Wave Function Collapse Macro</a></h2>
<p>Wave function collapse is much like autotiling, but instead of always trying to choose the best tile for the artist's chosen terrain, wave function collapse randomly chooses the terrain for each cell and randomly chooses the tile for each terrain. In this way wave function collapse is a tool for randomly generating tile maps.</p>
<p>Start by creating a pattern property and filling in its values for every tile you want to use, just as for the Autotile macro.</p>
<p>Next, open the brush in the tile set editor and open the "Macros" tab. Click the "Wave Function Collapse" button to add a wave function collapse macro to the list of macros and give the macro a name.</p>
<p>The wave function collapse macro has far more settings than autotile:</p>
<ul>
<li>
<p><strong>Pattern Property:</strong> Just like for autotile, the wave function collapse macro needs a pattern for each tile so that it knows which tiles may be placed adjacent to which other tiles.</p>
</li>
<li>
<p><strong>Frequency Property:</strong> This float property lets the wave function collapse know how often it should use each tile. Higher numbers mean that the tile will be chosen more often. 0 or less will cause a tile to never be chosen. If this property is set to "None" then all tiles will be given a frequency of 1.0.</p>
</li>
<li>
<p><strong>Contrain Edges:</strong> This toggle indicates that the macro will ensure that the tiles it is placing will match the surrounding tiles that were already in the tile map. For example, if you were to draw a filled rectangle using a wave function collapse tile, the macro would be forced to choose tiles that match the existing tiles around the edges of the rectangle. If this toggle is off, then the wave function collapse will ignore surrounding tiles.</p>
</li>
<li>
<p><strong>Max Attempts:</strong> Due to the random nature of the algorithm, wave function collapse can create situations where it becomes impossible to find a tile that satisfies all the requirements. Simply starting again and repeating the algorithm from the beginning can resolve this issue. This field determines the maximum number of tiles the macro will run the wave function collapse algorithm before giving up.</p>
</li>
<li>
<p><strong>Terrain:</strong> This lets you add terrains to the list of terrains that wave function collapse may randomly choose. Any terrain that is not on this list will never be chosen. If 0 is on the list, then the empty tile may sometimes be chosen. Each terrain on the list has a weight value that lets you control how often that terrain is chosen.</p>
</li>
</ul>
<p>Once you have configured the wave function collapse, go to the "Tiles" tab to add a wave function collapse tile to the brush. When you draw with this tile, the wave function collapse macro will wait until you have finished drawing, then attempt to replace everything you have drawn with random tiles from your chosen terrains.</p>
<p><img src="scene/autotile_wfc.gif" alt="Using Wave Function Collapse" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-scene-node"><a class="header" href="#custom-scene-node">Custom Scene Node</a></h1>
<p>Sometimes there is a need to have custom scene nodes, it is possible to do, but it requires quite a lot of boilerplate
code.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone, Reflect, Visit, Debug, ComponentProvider)]
pub struct CustomNode {
    base: Base,
}

impl Deref for CustomNode {
    type Target = Base;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.base
    }
}

impl DerefMut for CustomNode {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.base
    }
}

impl NodeTrait for CustomNode {
    fn local_bounding_box(&amp;self) -&gt; AxisAlignedBoundingBox {
        self.base.local_bounding_box()
    }

    fn world_bounding_box(&amp;self) -&gt; AxisAlignedBoundingBox {
        self.base.world_bounding_box()
    }

    fn id(&amp;self) -&gt; Uuid {
        // Provide unique id for serialization needs. It must be unique, use https://www.uuidgenerator.net/
        // to generate one.
        uuid!("f592e7f7-5e34-4043-9226-407c7457bb48")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Once the node is defined, you can create is as usual and put in the graph:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_custom_node(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    graph.add_node(Node::new(CustomNode::default()))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<p>Scene nodes have no access to outer context, this means that you cannot reference any data that is located outside
graph easily. You still can define a global variable that <strong>will</strong> be accessible, but it is considered as a hack and
should be avoided. If you want to add custom logic to scene nodes, then you should use scripts instead. Custom nodes
are intended for very specific use cases, such as adding "data sources" for renderer, etc.</p>
<h2 id="editor-support"><a class="header" href="#editor-support">Editor support</a></h2>
<p>For now, you cannot create custom nodes from the editor. This will be available in future versions of the engine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-3"><a class="header" href="#physics-3">Physics</a></h1>
<p>The engine have full-featured physics engine under the hood (Rapier), it helps you to simulate physics in your games.
There is first-class support for both 2D and 3D physics. There are three main physics entities in the engine:</p>
<ul>
<li>Rigid Body - responsible for rigid body dynamics simulation, must have at least one collider to be able to interact with
other rigid bodies in the world.</li>
<li>Collider - responsible for collision detection.</li>
<li>Joint - responsible for motion restriction between two rigid bodies.</li>
</ul>
<p>All these entities are ordinary scene nodes, so they can be arranged into any hierarchy in the scene. However there some
rules that have to be followed to make physics simulation work as intended:</p>
<ul>
<li>Rigid body node must have at least one <em>direct child</em> Collider node, otherwise rigid body won't interact with other
rigid bodies in the world.</li>
<li>Joint node must have two <em>direct child</em> rigid bodies, otherwise joint will have no effect.</li>
</ul>
<h2 id="differences-between-3d-and-2d"><a class="header" href="#differences-between-3d-and-2d">Differences between 3D and 2D</a></h2>
<p>There is a very few differences between 3D and 2D physics, the most obvious is that 2D physics does simulation only in
oXY plane (the plane of the screen). 2D physics has less collider shapes available since some 3D shapes degenerate in
2D, for example cylinder 3D shape in 2D is just a rectangle. There is also lesser number of joints available in 2D,
there is no revolute joint for example. Unlike 3D physics entities, 2D physics entities exist in the separate
<code>scene::dim2</code> module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rigid-body-node"><a class="header" href="#rigid-body-node">Rigid body node</a></h1>
<p>Rigid body node is the one of main physical entities in the engine. Rigid body nodes can be affected by gravity,
external forces and other rigid bodies. Use rigid body node everywhere you need natural physical behaviour for
your objects.</p>
<h2 id="how-to-create-10"><a class="header" href="#how-to-create-10">How to create</a></h2>
<p>Use RigidBodyBuilder to create a rigid body instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_cube_rigid_body(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    RigidBodyBuilder::new(
        BaseBuilder::new().with_children(&amp;[
            // Rigid body must have at least one collider
            ColliderBuilder::new(BaseBuilder::new())
                .with_shape(ColliderShape::cuboid(0.5, 0.5, 0.5))
                .build(graph),
        ]),
    )
    .with_mass(2.0)
    .with_lin_vel(Vector3::new(0.0, 3.0, 1.0))
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="colliders"><a class="header" href="#colliders">Colliders</a></h2>
<p>Rigid body must have at least one collider to participate in simulation properly, multiple colliders can be used to
create complex shapes from simple shapes, you can create concave objects this way. Every collider <strong>must</strong> be a direct
child node of a rigid body. In the editor it could look like this:</p>
<p><img src="physics/./colliders.png" alt="colliders" /></p>
<p>Note that, <code>Box</code> node here is an instance of <code>Rigid Body 2D</code>, and it has <code>Collider 2D</code> as a child and some sprite. This
structure (when a rigid body has a collider as a child) is mandatory for physics engine to work correctly! Collider
won't work (participate in physical simulation) without a rigid body and a rigid body won't work without a collider.
This applied to both 2D and 3D.</p>
<p>Keep in mind, that your graphical representation of an object (some node like <code>Mesh</code>, <code>Sprite</code>, etc.) must be attached
to a rigid body. Otherwise, the rigid body will move, but the graphical representation won't. You can also arrange
it other way around: a graphical node can have rigid body with a collider, but that requires the rigid body to be
kinematic. This is used to create <a href="physics/./collider.html#using-colliders-for-hit-boxes">hit boxes</a>, or any other things
that should have physical representation, but move together with graphical node.</p>
<h2 id="force-and-torque"><a class="header" href="#force-and-torque">Force and torque</a></h2>
<p>You can apply forces and torque to any rigid body, but only dynamic bodies will be affected. There is two ways of
applying force to a rigid body: at center of mass or at particular point at the body:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_force_and_torque(rigid_body: &amp;mut RigidBody) {
    // Push rigid body forward at the center of mass.
    rigid_body.apply_force(Vector3::new(0.0, 0.0, 1.0));

    // Kick rigid body at the side (this will also make it rotate)
    rigid_body.apply_force_at_point(Vector3::new(0.0, 0.0, 1.0), Vector3::new(1.0, 0.0, 0.0));

    // Turn rigid body around center of mass.
    rigid_body.apply_torque(Vector3::new(0.0, 3.0, 0.0));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="kinematic-rigid-bodies"><a class="header" href="#kinematic-rigid-bodies">Kinematic rigid bodies</a></h2>
<p>Sometimes you may want to have direct control over position/rotation of a rigid body and tell the physics engine to not
do simulation for the body. This can be achieved by making the rigid body <em>kinematic</em>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_kinematic_rigid_body(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    RigidBodyBuilder::new(
        BaseBuilder::new().with_children(&amp;[
            // Rigid body must have at least one collider
            ColliderBuilder::new(BaseBuilder::new())
                .with_shape(ColliderShape::cuboid(0.5, 0.5, 0.5))
                .build(graph),
        ]),
    )
    .with_body_type(RigidBodyType::KinematicPositionBased)
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="continuous-collision-detection"><a class="header" href="#continuous-collision-detection">Continuous collision detection</a></h2>
<p>Fast-moving rigid bodies can "fly through" other objects (for example a bullet can completely ignore walls if it is
moving too fast), this happens because of discrete calculation. This can be fixed by using continuous collision detection,
to enable it use either <code>.with_ccd_enabled(state)</code> of <code>RigidBodyBuilder</code> or <code>.set_ccd_enabled(state)</code> of <code>RigidBody</code>.</p>
<h2 id="dominance"><a class="header" href="#dominance">Dominance</a></h2>
<p>Dominance allows you to set a priority of forces applied to rigid bodies. It defines which rigid body can affect what rigid
body, for example you can set the highest dominance for actors and leave dominance of  everything else at zero, this way
actors will be able to push any other dynamic bodies, but dynamic bodies won't affect actors. This is useful when you don't
want your actors be pushed by surrounding objects (like if someone throws a box at an actor, it will stay still if it has
higher dominance)</p>
<h2 id="2d-rigid-bodies"><a class="header" href="#2d-rigid-bodies">2D rigid bodies</a></h2>
<p>2D rigid bodies have no difference with 3D, except the simulation happens in oXY plane and Z coordinate is ignored.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collider-node"><a class="header" href="#collider-node">Collider node</a></h1>
<p>Collider is a geometrical shape that is used for collision detection, contact manifold generation, etc. Colliders are used
in pair with rigid bodies, they make rigid body participate in collisions.</p>
<p><strong>Important:</strong> Colliders only works in pair with rigid bodies! Colliders won't be used by the engine, unless they're
direct children of a rigid body. Read <a href="physics/./rigid_body.html#colliders">this chapter</a> for more info.</p>
<h2 id="shapes"><a class="header" href="#shapes">Shapes</a></h2>
<p>Collider can have almost any shape, the engine offers the following shapes for 3D:</p>
<ul>
<li>Ball - dynamic sphere shape.</li>
<li>Cylinder - dynamic cylinder shape.</li>
<li>Cone - dynamic cone shape.</li>
<li>Cuboid - dynamic box shape.</li>
<li>Capsule - dynamic capsule shape.</li>
<li>Segment - dynamic segment ("line") shape</li>
<li>Triangle - simple dynamic triangle shape</li>
<li>Triangle mesh - static concave shape, can be used together with any static level geometry (wall, floors, ceilings,
anything else)</li>
<li>Height field - static height field shape, can be used together with terrains.</li>
<li>Polyhedron - dynamic concave shape.</li>
</ul>
<p>Also, there is a similar, but smaller set for 2D (because some shapes degenerate in 2D):</p>
<ul>
<li>Ball - dynamic circle shape.</li>
<li>Cuboid - dynamic rectangle shape.</li>
<li>Capsule - dynamic capsule shape.</li>
<li>Segment - dynamic segment ("line") shape.</li>
<li>Triangle - dynamic triangle shape.</li>
<li>Trimesh - static triangle mesh shape.</li>
<li>Heightfield - static height field shape.</li>
</ul>
<p><em>Dynamic</em> in both lists means that such shapes can be used together with <em>dynamic</em> rigid bodies, they'll correctly handle
all collisions and simulation will look as it should. <em>Static</em> means that such shape should be used only with <em>static</em>
rigid bodies.</p>
<h2 id="how-to-create-11"><a class="header" href="#how-to-create-11">How to create</a></h2>
<p>Use ColliderBuilder to create an instance of collider from code with any shape you want.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_capsule_collider(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    ColliderBuilder::new(BaseBuilder::new())
        .with_shape(ColliderShape::capsule_y(0.5, 0.2))
        .with_friction(1.0)
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>In the editor you can use <code>MainMenu -&gt; Create -&gt; Physics -&gt; Collider</code>, or right-click on a node in <code>World Viewer</code> and
select <code>Add Child -&gt; Physics -&gt; Collider</code>. Collider must be direct child of a rigid body, colliders do nothing on
their own!</p>
<h2 id="collision-filtering"><a class="header" href="#collision-filtering">Collision filtering</a></h2>
<p>Sometimes there's a need to prevent collision between various groups of colliders. Fyrox supports bit-wise collision
filtering exactly for this purpose. For instance, you may have two groups of colliders: actors and powerups, and you
want the actors to completely ignore collisions with powerups (and vice versa). In this case you can set collision
groups for actors like so:</p>
<p><img src="physics/./collision_groups_a.png" alt="actors collision groups" /></p>
<p>And set the collision groups for powerups like so:</p>
<p><img src="physics/./collision_groups_b.png" alt="powerups collision groups" /></p>
<p>As you can see, actors and powerups now have separate <code>memberships</code> (read - groups) and filters. This way, the actors
will collide with everything, but powerups and vice versa.</p>
<h2 id="using-colliders-for-hit-boxes"><a class="header" href="#using-colliders-for-hit-boxes">Using colliders for hit boxes</a></h2>
<p>You can use colliders to simulate hit boxes for your game characters. It can be done by creating a rigid body with
<code>KinematicPositionBased</code> type and an appropriate collider as a child node. As the last step you need to attach the body
to a bone in your character's model. Here's a quick example from the editor:</p>
<p><img src="physics/./hitbox.png" alt="hitbox" /></p>
<p>As you can see, the rigid body has a capsule collider as a child and the body is attached to the neck bone. The body
has <code>KinematicPositionBased</code> type, which will ensure that the body won't be simulated, instead its position will be
synchronized with the position of the parent bone.</p>
<p>To actually use the hit boxes in your game, you can either use a ray-casting to perform a hit scan or you can use
contacts information to fetch the stuff with which a hit box was contacted. See <a href="physics/./ray.html">Ray casting</a> chapter of the
section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="joint"><a class="header" href="#joint">Joint</a></h1>
<p>Joint is a configurable link between two rigid bodies, it restricts relative motion of two bodies. Fyrox provides a
fixed set of joints that are suitable for various applications.</p>
<ul>
<li>Fixed Joint - hard link between two bodies, it is the same is if two rigid bodies were "welded" to each other with
a metal rod.</li>
<li>Revolute Joint - restricts all translational movement and any rotations around Y and Z axes, but leaves rotation
around local X axis free. An example of the joint from real world is a door hinge, it allows the door to rotate around
single axis, but not move.</li>
<li>Prismatic Joint - restricts all rotations, movement is allowed along single axis (local X of the joint). An example
of the joint from real world could be a slider that supports drawers on a table.</li>
<li>Ball Joint - restricts all movement, but leaves rotations unrestricted. An example of a ball joint from real world
could be human shoulder.</li>
</ul>
<p>2D joints does not have revolute joints, because it degenerates into ball joint.</p>
<h2 id="bodies-binding"><a class="header" href="#bodies-binding">Bodies Binding</a></h2>
<p>When the joint is created and all bodies are set to it, it uses self global transform and bodies global transforms to
calculate local frames for bodies. This process is called <em>binding</em>, it happens once when the joint is created, but
can be initiated by moving the joint to some other position by changing local transform of the joint.</p>
<h2 id="how-to-create-12"><a class="header" href="#how-to-create-12">How to create</a></h2>
<p>To create a joint from code use <code>JointBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_joint(graph: &amp;mut Graph, body1: Handle&lt;Node&gt;, body2: Handle&lt;Node&gt;) -&gt; Handle&lt;Node&gt; {
    JointBuilder::new(BaseBuilder::new())
        .with_body1(body1)
        .with_body2(body2)
        .with_params(JointParams::BallJoint(BallJoint {
            x_limits_enabled: false,
            x_limits_angles: Default::default(),
            y_limits_enabled: false,
            y_limits_angles: Default::default(),
            z_limits_enabled: false,
            z_limits_angles: Default::default(),
        }))
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Once the joint is created, it will bind given bodies, using the process describe in the above section.</p>
<p>To create a joint from editor, use  <code>MainMenu -&gt; Create -&gt; Physics -&gt; Joint</code>, select the new joint and find <code>Body1</code> and
<code>Body2</code> properties. Assign the fields by holding <code>Alt</code> key and drag'n'drop a rigid body to a field. Move the joint to
correct position to ensure the binding will happen as intended.</p>
<h2 id="limits"><a class="header" href="#limits">Limits</a></h2>
<p>You can restrict motion on primary joint axis (rotational and translational) by setting a limit to desired axis.</p>
<ul>
<li>Ball Joint have three angular limits, one per rotation around an axis. The angle range is given in radians.</li>
<li>Prismatic Joint have only one limit it is maximum linear distance between two bodies along primary joint axis.</li>
<li>Revolute Joint have a single angular limit around primary axis. The angle range is given in radians.</li>
<li>Fixed Joint does not have any limit setting, because it locks all degrees of freedom.</li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>Joints can be used to create many game entities, such as doors, chains and rag dolls. The most interesting here is
rag doll. It is used to create realistic behaviour for humans and creatures in games. In general, it is a set of
rigid bodies, colliders and joints. Where each joint configured to match joints of a creature, for example ball joint
could be used for shoulders, revolute joints for knees and elbows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ray-casting"><a class="header" href="#ray-casting">Ray Casting</a></h1>
<p>Ray casting allows you to query intersections of a ray with rigid bodies in a scene. Typical usage for ray casting is
hit-scan weapons (weapons that shoots high-speed projectiles), AI collision avoidance, etc. To query intersections,
use physics world instance of a scene graph:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_ray_cast(graph: &amp;mut Graph, begin: Vector3&lt;f32&gt;, end: Vector3&lt;f32&gt;) -&gt; Vec&lt;Intersection&gt; {
    let mut buffer = Vec::new();

    let ray_direction = end - begin;

    graph.physics.cast_ray(
        RayCastOptions {
            ray_origin: Point3::from(begin),
            ray_direction,
            max_len: ray_direction.norm(),
            groups: Default::default(),
            sort_results: true,
        },
        &amp;mut buffer,
    );

    buffer
}
<span class="boring">}</span></code></pre></pre>
<p>The function above will return a collection of intersections that are sorted by intersection distance (a distance from
beginning of the ray to an intersection point). Each intersection is represented by the following structure:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Intersection {
    pub collider: Handle&lt;Node&gt;,
    pub normal: Vector3&lt;f32&gt;,
    pub position: Point3&lt;f32&gt;,
    pub feature: FeatureId,
    pub toi: f32,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>collider</code> - a handle of the collider with which intersection was detected. To obtain a handle to rigid body, borrow
the <code>collider</code> and fetch its <code>parent</code> field: <code>graph[collider].parent()</code>.</li>
<li><code>normal</code> - a normal at the intersection position in world coordinates.</li>
<li><code>position</code> - a position of the intersection in world coordinates.</li>
<li><code>feature</code> - additional data that contains a kind of the feature with which intersection was detected as well as its
index. FeatureId::Face might have index that is greater than number of triangles in a triangle mesh, this means that
intersection was detected from "back" side of a face. To "fix" that index, simply subtract number of triangles of a
triangle mesh from the value.</li>
<li><code>toi</code> - (<code>time of impact</code>) a distance from ray's origin to <code>position</code>.</li>
</ul>
<h2 id="avoiding-unnecessary-allocations"><a class="header" href="#avoiding-unnecessary-allocations">Avoiding unnecessary allocations</a></h2>
<p>As you might've noticed, the function above return <code>Vec&lt;Intersection&gt;</code> which allocates intersections on heap. This is
relatively slow and could be sped up a lot by using static array on stack:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_static_ray_cast&lt;const N: usize&gt;(
    graph: &amp;mut Graph,
    begin: Vector3&lt;f32&gt;,
    end: Vector3&lt;f32&gt;,
) -&gt; ArrayVec&lt;Intersection, N&gt; {
    let mut buffer = ArrayVec::&lt;Intersection, N&gt;::new();

    let ray_direction = end - begin;

    graph.physics.cast_ray(
        RayCastOptions {
            ray_origin: Point3::from(begin),
            ray_direction,
            max_len: ray_direction.norm(),
            groups: Default::default(),
            sort_results: true,
        },
        &amp;mut buffer,
    );

    buffer
}

fn usage_example(graph: &amp;mut Graph, begin: Vector3&lt;f32&gt;, end: Vector3&lt;f32&gt;) {
    // Fetch first 32 intersections.
    dbg!(do_static_ray_cast::&lt;32&gt;(graph, begin, end));
}
<span class="boring">}</span></code></pre></pre>
<p><code>usage_example</code> shows how to use the <code>do_static_ray_cast</code> function - all you need to do is to specify maximum number of
intersections you're interested in as a generic parameter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ragdoll"><a class="header" href="#ragdoll">Ragdoll</a></h1>
<p>Ragdoll physics is a sort of procedural animation, that allows you to create naturally looking death animations and
body physics in general. Ragdoll is just an arbitrary combination of rigid bodies, colliders, joints. Rigid bodies and
colliders define physical "boundaries" for limbs of your character, while joints restrict relative motion (linear and
rotational).</p>
<h2 id="how-to-create-13"><a class="header" href="#how-to-create-13">How To Create</a></h2>
<p>Creating a ragdoll manually is a very tedious procedure, you need to create rigid bodies and colliders for every body
part of your character, place them correctly, adjust their size, etc. Then you need to create a set of joints, that
connects body parts, and then setup linear and angular limits. To save time, Fyrox has a special tool called
<code>Ragdoll Wizard</code>:</p>
<p><img src="physics/ragdoll.png" alt="ragdoll wizard" /></p>
<p>It can be opened from <code>Utils</code> menu and contains quite a lot of node handle fields that needs to be filled. Thankfully,
there's an <code>Autofill</code> button, by pressing which, the wizard will try to find respective bones of the skeleton and put their
handles in the respective fields in the wizard. For now, it is configured to work with <a href="https://www.mixamo.com">mixamo</a>
skeletons.</p>
<p>Other parameters are listed below:</p>
<ul>
<li><code>Total Mass</code> - total mass of the ragdoll, it will be used to configure masses of rigid bodies of body parts.</li>
<li><code>Use CCD</code> - a flag, that defines whether the continuous collision detection (CCD) for body parts should be used or not.
It is advised to keep this flag on, otherwise body parts might get stuck or fall through the floor, leading to "explosive"
ragdoll behaviour.</li>
<li><code>Can Sleep</code> - a flag, that defines whether the body parts can "sleep" or not. Sleep in this case means, that a body
part can be excluded from physical simulation if it is not moving for some time.</li>
<li><code>Collision Groups</code> and <code>Solver Groups</code> could be used to configure <a href="physics/collider.html#collision-filtering">collision filtering</a>.
It is very important in case if your character has a physical capsule, that is used to "standard" character physics. In
this case body parts must ignore physical capsule (and vice versa), otherwise your ragdoll will "explode".</li>
</ul>
<p>After everything is filled in, you can click <code>OK</code> button and if everything is correct, you should see a bunch of new
scene nodes in the world viewer, located under a <code>Ragdoll</code> scene node:</p>
<p><img src="physics/ragdoll2.png" alt="ragdoll result" /></p>
<p>As you can see, the number of entities you'd have to create and configure manually is quite high. Keep in mind, that
ragdoll wizard can't generate perfect ragdoll, because of lack of information. The generated ragdoll will most likely
require some minor tweaks (mostly joint angular limits).</p>
<h2 id="video-tutorials"><a class="header" href="#video-tutorials">Video Tutorials</a></h2>
<p>There's one video tutorial about ragdoll wizard, it also shows the final results in game:</p>
<iframe width="560" height="315" src="https://youtube.com/embed/TxSlqGhCxYc" title="YouTube video player" frameborder="0" 
allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-system"><a class="header" href="#sound-system">Sound System</a></h1>
<p>Fyrox has quite powerful and flexible audio system which will be covered in this chapter. Basic "building blocks" are
sound sources, sound buffers, audio processing buses with various sound effects, sound context. Read the next chapters
to learn more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-bus"><a class="header" href="#audio-bus">Audio Bus</a></h1>
<iframe width="750" height="410" src="https://youtube.com/embed/6-M3LUv9Jto" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Audio bus is an audio processing unit that takes audio samples from any number of sound sources and passes them through
a chain of effects (zero or more). Processed samples then can be either sent to an audio playback device (speakers,
headphones, etc.) or to some other audio bus. There's always one audio bus (primary) that sends its data to an audio playback
device, every other audio buses are considered secondary.</p>
<h2 id="graph-1"><a class="header" href="#graph-1">Graph</a></h2>
<p>As stated above, any audio bus (except primary), can output its audio samples to some other audio bus (primary or secondary).
Such relationship forms an audio bus graph:</p>
<p><img src="sound/data_flow_diagram.png" alt="data flow diagram" /></p>
<p>As you can see, there can be any number of sound sources which attached to the respective audio buses. Each audio bus
can have any number of effects (such as lowpass, highpass, etc. filtering; reverb effect and more). Finally, each audio
bus is connected to some other audio bus.</p>
<p>Such complex audio processing structure allows you to create pretty much any sound environment. For example, you can
create an audio bus with a reverb effect, that will represent a huge hangar with lots of echoes. Then you attach all
sound sources located in this "hangar" to the audio bus and your sound sources will sound more naturally, according
to environment.</p>
<h2 id="effects"><a class="header" href="#effects">Effects</a></h2>
<p>Audio bus can have zero or more audio processing effects. The effects applied one after another (see the arrows on the
picture above). You can set any of the following effects:</p>
<ul>
<li><strong>Attenuation</strong> - changes "volume" of input sound samples.</li>
<li><strong>Reverb</strong> - adds echoes, early and late reflections. Could be used to simulate environment with high reflectivity (hangars,
parking lots, etc.)</li>
<li><strong>Low Pass Filter</strong> - passes all frequencies below the specified cut-off frequency.</li>
<li><strong>High Pass Filter</strong> - passes all frequencies above the specified cut-off frequency.</li>
<li><strong>Band Pass Filter</strong> - passes all frequencies in a given range around the specified cut-off frequency.</li>
<li><strong>All Pass Filter</strong> - shifts phase of the signal by 90 degrees at the specified cut-off frequency.</li>
<li><strong>Low Shelf Filter</strong> - reduces amplitude of frequencies in a shape like this ̅ _ at the cutoff frequency.</li>
<li><strong>High Shelf Filter</strong> - reduces amplitude of frequencies in a shape like this _/̅  at the cutoff frequency.</li>
</ul>
<h2 id="editor-2"><a class="header" href="#editor-2">Editor</a></h2>
<p>In the editor, audio bus graph is located in the Audio Context panel:</p>
<p><img src="sound/audio_context.png" alt="audio context" /></p>
<p>Primary audio bus is located at the left of the panel, every other audio bus is located to the right. Each audio bus
(except primary) has a dropdown list (at the bottom), that specifies output audio bus. The list of effect is located
in the center; it can be edited in the Inspector (right side of the image).</p>
<p>To attach a sound source to an audio bus, select in the scene and find <code>Audio Bus</code> property in the Inspector and set it
to the name of desired audio bus.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-1"><a class="header" href="#sound-1">Sound</a></h1>
<p>In Fyrox, sounds are nodes of type <code>Sound</code>, with all the consequent properties and workflows.</p>
<h2 id="how-to-create-14"><a class="header" href="#how-to-create-14">How to create</a></h2>
<p>There are two major ways to create sound sources: from the editor and from code.</p>
<h3 id="from-editor"><a class="header" href="#from-editor">From Editor</a></h3>
<p>A sound source could be created from <code>Create</code> menu (or from the same menu by right-clicking on a node in the world viewer):</p>
<p><img src="sound/create.png" alt="create" /></p>
<p>After the source is created, you can select it and start editing its properties:</p>
<p><img src="sound/sound.png" alt="sound" /></p>
<ul>
<li><code>Buffer</code> - a sound buffer resource, that will be used as a source of samples. If it is empty, then no sound will be
played. Drag'n'drop a sound resource from the Asset Browser here to assign it to the source.</li>
<li><code>Play Once</code> - a flag, that defines whether the engine should automatically delete the sound source node from the scene
when it is finished playing. Could be useful for one-shot sounds.</li>
<li><code>Gain</code> - a numeric value in <code>[0..1]</code> range, that defines total volume of the sound source. Keep in mind, that this
value sets the volume in <em>linear</em> scale, while physically-correct approach would be to use logarithmic scale. This
will be fixed in future versions.</li>
<li><code>Panning</code> - a numeric value in <code>[-1..1]</code> range, that defines how loud audio channels will be. <code>-1</code> - all the sound
will be routed to the left channel, <code>1</code> - to the right channel. This option works only with 2D sounds (whose spatial
blend factor is <code>0.0</code>)</li>
<li><code>Status</code> - a switch with three possible states: <code>Stopped</code>, <code>Playing</code>, <code>Paused</code>. By default, every sound source is
in stopped state, do not forget to switch it to the <code>Playing</code> state, otherwise you won't hear anything.</li>
<li><code>Looping</code> - a flag, that defines whether the sound source should be playing infinitely, or not. Looping sound source
will never switch their status to <code>Stopped</code>.</li>
<li><code>Pitch</code> - playback speed multiplier. By default, it is <code>1.0</code> which means default speed.</li>
<li><code>Max Distance</code> - maximum distance, at which the sound source is affected by distance attenuation (for 3D sounds).
By default, it set to max possible value. Lower values could be used to prevent sound source from be silent at certain
distance.</li>
<li><code>Rolloff Factor</code> - a numeric value, that defines how fast the volume of the sound source will decay with increasing
distance to a listener.</li>
<li><code>Playback Time</code> - desired time from which the playback should start (in seconds).</li>
<li><code>Spatial Blend</code> - a numeric value, that defines blending factor between 2D and 3D sound, where <code>0.0</code> - the sound is
fully 2D, <code>1.0</code> - the sound is fully 3D. By default, the value is <code>1.0</code>.</li>
<li><code>Audio Bus</code> - a name of an audio bus, that will be used to process the samples from the sound source. By default, it
is set to <code>Primary</code>. It should match the name of some audio bus, that will be used in your scene. More info about
audio processing could found <a href="sound/bus.html">here</a>.</li>
</ul>
<h3 id="from-code"><a class="header" href="#from-code">From Code</a></h3>
<p>Audio files are loaded using the resource manager:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_sound(path: &amp;Path, resource_manager: &amp;ResourceManager) -&gt; SoundBufferResource {
    resource_manager.request::&lt;SoundBuffer&gt;(path)
}
<span class="boring">}</span></code></pre></pre>
<p>Then, the node is built using the standard builder pattern:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_sound_node(resource_manager: &amp;ResourceManager, scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    let sound = resource_manager.request::&lt;SoundBuffer&gt;("/path/to/resource.ogg");

    SoundBuilder::new(BaseBuilder::new())
        .with_buffer(Some(sound))
        .with_status(Status::Playing)
        .with_play_once(true)
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>There are a few notable things in the example above.</p>
<p>The first is that sounds don't play automatically; in order to do so, we need to invoke <code>.with_status(Status::Playing)</code>.</p>
<p>The second is that sound nodes are not dropped automatically after playback; dropping it can be performed in two ways.
One way is to use the convenient builder API <code>.with_play_once(true)</code>; another is to use the graph APIs:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_sound(sound_handle: Handle&lt;Node&gt;, scene: &amp;mut Scene) {
    let sound = scene.graph[sound_handle].as_sound();

    if sound.status() == Status::Stopped {
        scene.graph.remove_node(sound_handle);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If we want to play background music (or anyway a repeated sound), we just set the <code>looping</code> property when building the node:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_looping_sound(scene: &amp;mut Scene) {
    SoundBuilder::new(BaseBuilder::new())
        .with_looping(true)
        // ...
        .build(&amp;mut scene.graph);
}
<span class="boring">}</span></code></pre></pre>
<p>In order to stream large audio files, instead of loading them entirely in memory, the simplest strategy is to create a
corresponding <code>.options</code> file, with the following content:</p>
<pre><code class="language-json">(
  stream: true
)
</code></pre>
<p>If the audio file is called, for example, <code>/path/to/background.ogg</code>, call this <code>/path/to/background.ogg.options</code>.</p>
<h2 id="2d-and-3d"><a class="header" href="#2d-and-3d">2D and 3D</a></h2>
<p>There's no strict separation between 2D and 3D sound sources. The same source could be switched from 2D to 3D (and vice
versa) at runtime, by just adjusting <code>Spatial Blend</code> property. Spatial blend factor is a numeric value, that defines
blending factor between 2D and 3D sound, where <code>0.0</code> - the sound is fully 2D, <code>1.0</code> - the sound is fully 3D. By default,
the value is <code>1.0</code> which makes it 3D. Intermediate values could be used to create "ambisonic" sound sources - when the
source sounds like it is placed at some position in the world, but some part of it is just 2D and does not depend on
positioning.</p>
<h2 id="audio-bus-1"><a class="header" href="#audio-bus-1">Audio bus</a></h2>
<p>It is possible to specify target audio bus to which the sound will output its audio samples. Audio bus is responsible
for various audio processing, such as filtering, reverb, etc. To specify output audio bus, just use the <code>set_audio_bus</code>
method and set the name of an audio bus.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listener"><a class="header" href="#listener">Listener</a></h1>
<p>An audio receiver that captures the sound at a particular point in your scene and sends it to an audio context for
processing and outputting to an audio playback device. Every game scene has only one listener. There's nothing specific
in listener's API, in general it is just an oriented point in 3D space. "Ear" axis is the local X axis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="head-related-transfer-function"><a class="header" href="#head-related-transfer-function">Head Related Transfer Function</a></h1>
<p>Head Related Transfer Function (HRTF for short) is special audio processing technique that improves audio spatialization.
By default, sound spatialization is very simple - volume of each audio channel (left and right) changes accordingly to
orientation of the listener. While this simple and fast, it does not provide good audio spatialization - sometimes
it is hard to tell from which direction the actual sound is coming from. To solve this issue, we can use head-related
transfer function. Despite its scary, mathematical name, it is easy to understand what it's doing. Instead of uniformly
changing volume of all frequencies of the signal (as the naive spatialization does), it changes them separately for
each channel. The exact "gains" of each frequency of each channel is depends on the contents of head-related transfer
function. This is done for each azimuth and elevation angles, which gives full picture of how audio signal from each
direction travels to each ear.</p>
<p>HRTF is usually recorded using a head model with ears with a microphone inside each ear. To capture head-related impulse
response (time domain) at a fixed distance and angle pair (azimuth and elevation), a very short impulse of sound is produced.
Microphones inside each ear records the signal, and then HRIR (time domain) can be converted in HRTF (frequency domain).</p>
<h2 id="hrtf-on-practice"><a class="header" href="#hrtf-on-practice">HRTF on practice</a></h2>
<p>The theory above could be boring, however it is very simple to use HRTF on practice. Pick a HRIR sphere from the
<a href="https://github.com/mrDIMAS/hrir_sphere_builder/tree/master/hrtf_base/IRCAM">database</a> (any of *.bin files) and load
it in the Audio Context panel:</p>
<p><img src="sound/hrtf.png" alt="hrtf" /></p>
<p>Once it is loaded, all sounds in the scene will use the HRTF for rendering. The same can be achieved by code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{
</span><span class="boring">    graph::Graph,
</span><span class="boring">    sound::{self, HrirSphere, HrirSphereResource, HrirSphereResourceExt, HrtfRenderer, Renderer},
</span><span class="boring">};
</span><span class="boring">
</span>fn use_hrtf(graph: &amp;mut Graph) {
    let hrir_sphere = HrirSphereResource::from_hrir_sphere(
        HrirSphere::from_file("path/to/hrir.bin", sound::SAMPLE_RATE).unwrap(), "path/to/hrir.bin".into());
    graph
        .sound_context
        .state()
        .set_renderer(Renderer::HrtfRenderer(HrtfRenderer::new(hrir_sphere)));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-9"><a class="header" href="#performance-9">Performance</a></h2>
<p>HRTF is heavy. It is 5-6 times slower than the simple spatialization, so use it only on middle-end or high-end hardware.
HRTF performance is linearly dependent on the number of sound sources: the more sound sources use HRTF, the worse performance
will be and vice versa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-4"><a class="header" href="#animation-4">Animation</a></h1>
<p>Animation allows you to change properties of scene nodes at runtime using a set of key frames. Animation
consists of multiple tracks, where each track is bound to a property of a scene node. A track can animate
any numeric properties, starting from numbers (including <code>bool</code>) end ending by 2/3/4 dimensional vectors.
Each component (number, x/y/z/w vector components) is stored in a <em>parametric curve</em>. Every parametric curve contains zero or more <em>key frames</em>.
Graphically this could be represented like so:</p>
<pre><code class="language-text">                                         Timeline
                                            v
  Time   &gt; |---------------|------------------------------------&gt;
           |               |
  Track1 &gt; | node.position |                                     
           |   X curve     |..1..........5...........10..........
           |   Y curve     |..2.........-2..................1....  &lt; Curve key frames
           |   Z curve     |..1..........9......................4
           |_______________|  
  Track2   | node.property |                                  
           | ............  |.....................................
           | ............  |.....................................
           | ............  |.....................................
</code></pre>
<p>Each key frame is just a real number with interpolation mode. Interpolation mode tells the engine how to
calculate intermediate values between key frames. There are three kinds of interpolation used in animations
(you can skip "boring math" if you want):</p>
<ul>
<li><strong>Constant</strong> - intermediate value will be calculated using leftmost value of two. Constant "interpolation" is
usually used to create step-like behaviour, the most common case is to "interpolate" two boolean values.</li>
<li><strong>Linear</strong> - intermediate value will be calculated using linear interpolation <code>i = left + (right - left) / t</code>,
where <code>t = (time_position - left) / (right - left)</code>. <code>t</code> is always in <code>0..1</code> range. Linear interpolation is usually
used to create "straight" transitions between two values.</li>
<li><strong>Cubic</strong> - intermediate value will be calculated using Hermite cubic spline:
<code>i = (2t^3 - 3t^2 + 1) * left + (t^3 - 2t^2 + t) * left_tangent + (-2t^3 + 3t^2) * right + (t^3 - t^2) * right_tangent</code>,
where <code>t = (time_position - left) / (right - left)</code> (<code>t</code> is always in <code>0..1</code> range), <code>left_tangent</code> and <code>right_tangent</code>
is usually a <code>tan(angle)</code>. Cubic interpolation is usually used to create "smooth" transitions between two values.</li>
</ul>
<h2 id="web-demo"><a class="header" href="#web-demo">Web Demo</a></h2>
<p>You can explore animation system capabilities in this <a href="https://fyrox.rs/assets/demo/animation/index.html">web demo</a>. Keep
in mind, that it was designed to run on PC and wasn't tested on mobile devices.</p>
<h2 id="track-binding"><a class="header" href="#track-binding">Track binding</a></h2>
<p>Each track is always bound to a property in a node, either by its name or by a special binding. The name is used to fetch the
property using reflection, the special binding is a faster way of fetching built-in properties. It is usually used to animate
position, scale and rotation (these are the most common properties available in every scene node).</p>
<h2 id="time-slice-and-looping"><a class="header" href="#time-slice-and-looping">Time slice and looping</a></h2>
<p>While key frames on the curves can be located at arbitrary position in time, animations usually plays a specific time slice.
By default, each animation will play on a given time slice infinitely - it is called <em>animation looping</em>, it works in both
playback directions.</p>
<h2 id="speed"><a class="header" href="#speed">Speed</a></h2>
<p>You can vary playback speed in wide range, by default every animation has playback speed multiplier set to 1.0. The multiplier
tells how faster (&gt;1) or slower (&lt;1) the animation needs to be played. Negative speed multiplier values will reverse playback.</p>
<h2 id="enabling-or-disabling-animations"><a class="header" href="#enabling-or-disabling-animations">Enabling or disabling animations</a></h2>
<p>Sometimes there's a need to disable/enable an animation or check if it is enabled or not, you can do this by using the pair
of respective methods - <code>Animation::set_enabled</code> and <code>Animation::is_enabled</code>.</p>
<h2 id="signals"><a class="header" href="#signals">Signals</a></h2>
<p>Signal is a named marker on specific time position on the animation timeline. Signal will emit an event if the animation playback
time passes signal's position from left-to-right (or vice versa depending on playback direction). Signals are usually used to
attach some specific actions to a position in time. For example, you can have a walking animation and you want to emit sounds
when character's feet touch ground. In this case you need to add a few signals at times when each foot touches the ground.
After that all you need to do is to fetch animation events one-by-one and emit respective sounds. See respective
<a href="animation/signal.html">chapter</a> for more info.</p>
<h2 id="creating-from-code"><a class="header" href="#creating-from-code">Creating From Code</a></h2>
<p>Usually, animations are created from the editor or some external tool and then imported in the engine. Before trying the example
below, please read the docs for <code>AnimationPlayer</code> node, it is much more convenient way of animating
other nodes. The node can be created from the editor, and you don't even need to write any code.
Use the following example code as a guide <strong>only</strong> if you need to create procedural animations:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_animation(node: Handle&lt;Node&gt;) -&gt; Animation {
    let mut frames_container = TrackDataContainer::new(TrackValueKind::Vector3);
    // We'll animate only X coordinate (at index 0).
    frames_container.curves_mut()[0] = Curve::from(vec![
        CurveKey::new(0.5, 2.0, CurveKeyKind::Linear),
        CurveKey::new(0.75, 1.0, CurveKeyKind::Linear),
        CurveKey::new(1.0, 3.0, CurveKeyKind::Linear),
    ]);
    // Create a track that will animated the node using the curve above.
    let track = Track::new(frames_container, ValueBinding::Position);
    // Finally create an animation and set its time slice and turn it on.
    let mut animation = Animation::default();
    animation.add_track_with_binding(TrackBinding::new(node), track);
    animation.set_time_slice(0.0..1.0);
    animation.set_enabled(true);
    animation
}

fn use_animation() {
    // Create a graph with a node.
    let mut graph = Graph::new();
    let some_node = PivotBuilder::new(BaseBuilder::new()).build(&amp;mut graph);
    // Create the animation.
    let mut animation = create_animation(some_node);
    // Emulate some ticks (like it was updated from the main loop of your game).
    for _ in 0..10 {
        animation.tick(1.0 / 60.0);
        animation.pose().apply(&amp;mut graph);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The code above creates a simple animation that moves a node along X axis in various ways. The usage of the animation
is only for the sake of completeness of the example. In the real games you need to add the animation to an animation
player scene node, and it will do the job for you.</p>
<h2 id="importing"><a class="header" href="#importing">Importing</a></h2>
<p>It is also possible to import an animation from external source (such as FBX files). You can do this in two major
ways: from code or from the editor. The following sections shows how to use both ways.</p>
<h3 id="from-editor-1"><a class="header" href="#from-editor-1">From Editor</a></h3>
<p>At first, make sure that you have your 3D model instantiated in the scene. The following example has <code>agent.fbx</code>
instance in the scene (to do that, just drag'n'drop your 3D model in the scene from the Asset Browser). To import
an animation you need to create an <code>Animation Player</code> scene node, open the <a href="animation/anim_editor.html">Animation Editor</a> and
click the button with arrow-down icon:</p>
<p><img src="animation/import_animation_1.png" alt="Step 1" /></p>
<p>Now you need to pick the root node of your 3D model to which you'll import your animation. Usually it will be called
the same as your 3D model (<code>agent.fbx</code> on the screenshot below):</p>
<p><img src="animation/import_animation_2.png" alt="Step 2" /></p>
<p>The last thing you need to do is to pick the animation you want to import:</p>
<p><img src="animation/import_animation_3.png" alt="Step 3" /></p>
<p>If everything is correct, you can preview your animation by clicking <code>Preview</code> checkbox:</p>
<p><img src="animation/import_animation_4.png" alt="Step 4" /></p>
<h3 id="from-code-1"><a class="header" href="#from-code-1">From Code</a></h3>
<p>You can do the same as in the previous section, but from code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_animated_character(
    scene: &amp;mut Scene,
    resource_manager: &amp;ResourceManager,
) -&gt; (Handle&lt;Node&gt;, Handle&lt;Node&gt;) {
    // Load a character model first.
    let character_resource = resource_manager
        .request::&lt;Model&gt;("path/to/my/character.fbx")
        .await
        .unwrap();

    // Create its instance.
    let character_instance = character_resource.instantiate(scene);

    // Create a new animation player.
    let animation_player = AnimationPlayerBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

    // Load an animation.
    let animation_resource = resource_manager
        .request::&lt;Model&gt;("path/to/my/animation.fbx")
        .await
        .unwrap();

    // "Instantiate" an animation from the animation resource to the animation player.
    // You can call this method multiple times with different animations, each time it
    // will create a new animation instance and put it in the animation player.
    let _animations = animation_resource.retarget_animations_to_player(
        character_instance,
        animation_player,
        &amp;mut scene.graph,
    );

    (character_instance, animation_player)
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, at first this code creates an instance of a 3D model. Then it loads an animation and creates its
instance in the animation player. Please note, that this code uses <code>async</code>, which produces a future which should
be driven by some executor. You can use <code>block_on</code> method to execute it at call site (this won't work on WebAssembly).</p>
<p>It is advised to prefer the editor to code approach, because it hides all this tedious code and properly handles
asynchronous loading on all platforms.</p>
<h2 id="playing-an-animation"><a class="header" href="#playing-an-animation">Playing an Animation</a></h2>
<p>Animations will be played automatically if the respective animation player is has the property <code>Auto Apply</code> set to
<code>true</code>. Since the animation player can contain multiple animations, all of them will be played at once. You can
enable/disable animations when needed by finding them by name from code and switching <code>Enabled</code> property:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn enable_animation(animation_player: Handle&lt;Node&gt;, graph: &amp;mut Graph, name: &amp;str, enabled: bool) {
    if let Some(animation_player) = graph.try_get_mut_of_type::&lt;AnimationPlayer&gt;(animation_player) {
        // `get_value_mut_silent` prevents marking the variable as modified (see Property Inheritance
        // chapter for more info).
        let animations = animation_player.animations_mut().get_value_mut_silent();

        // Find an animation with the given name.
        if let Some((_animation_handle, animation)) = animations.find_by_name_mut(name) {
            // You could also store _animation_handle somewhere and use  animations.get_mut/get(handle)
            // to fetch an animation faster.

            // Turn the animation on/off.
            animation.set_enabled(enabled);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code could also be used to change animation properties at runtime. To do that, replace <code>set_enabled</code> with some
other methods, such as <code>set_speed</code>, <code>set_loop</code>, <code>set_root_motion_settings</code> etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-editor"><a class="header" href="#animation-editor">Animation Editor</a></h1>
<p><img src="animation/./anim_editor.png" alt="anim editor" /></p>
<p>Animation Editor is a tool that helps you to create and preview animations. This is a powerful tool that can be used
to animate pretty much any numeric property. It has three main parts:</p>
<ol>
<li><code>Toolbar</code> - contains a set of tools that changes a particular part of an animation (name, length, speed, etc.)</li>
<li><code>Track List</code> - contains a list of tracks of nodes that will be animated.</li>
<li><code>Curve Editor</code> - curve editor allows you to edit behaviour of a numeric parameter over the time.</li>
</ol>
<p>The editor can be opened in two ways - using <code>Utils -&gt; Animation Editor</code> or by selecting an animation player node and
clicking <code>Open Animation Editor</code> button in the inspector.</p>
<p><img src="animation/./ae_open1.png" alt="open1" /></p>
<p><img src="animation/./ae_open2.png" alt="open2" /></p>
<p>In both ways you still need to select an animation player for editing.</p>
<h2 id="typical-workflow"><a class="header" href="#typical-workflow">Typical Workflow</a></h2>
<p>At first, you need to create or <a href="animation/anim_editor.html#animation-importing">import</a> an animation, then you need to set its time slice to
desired range (see <a href="animation/anim_editor.html#toolbar">Time Slice</a> in the section below), then you need to add a few tracks for desired
properties and finally add some keys. You can <a href="animation/anim_editor.html#preview-mode">preview</a> the results at any time, keep in
mind that any attempt to change an animation while it is the preview mode, will revert every change from the
preview mode and only then apply your change.</p>
<h2 id="toolbar"><a class="header" href="#toolbar">Toolbar</a></h2>
<p>The toolbar contains a set of tools that changes a particular part of an animation (name, length, speed, etc.). It looks
like this:</p>
<p><img src="animation/./ae_toolbar.png" alt="toolbar" /></p>
<ol>
<li><code>Animation Name</code> - name of a currently selected animation.</li>
<li><code>Add Animation</code> - adds a new empty animation with the name from the text box at the left to the animation player.</li>
<li><code>Import Animation</code> - starts animation importing process. See <a href="animation/anim_editor.html#animation-importing">Animation Importing</a> section
for more info.</li>
<li><code>Reimport Animation</code> - re-imports the animation from an external file, it is useful if you need to change animation's
content, while keep references to it valid.</li>
<li><code>Rename Animation</code> - renames a currently selected animation using the name from the text box at the left.</li>
<li><code>Animation Selector</code> - allows you to switch currently edited animation.</li>
<li><code>Delete Animation</code> - deletes a currently selected animation, tries to select last animation from the list if possible.</li>
<li><code>Duplicate Animation</code> - clones a currently selected animation.</li>
<li><code>Loop Animation</code> - enables or disables looping of a currently selected animation.</li>
<li><code>Enable Animation</code> - enables or disables a currently selected animation.</li>
<li><code>Animation Speed</code> - sets a new playback speed of a currently selected animation.</li>
<li><code>Time Slice</code> - a time range (in seconds) which defines start and end time of a currently selected animation. The range
is highlighted in the curve editor.</li>
<li><code>Root Motion</code> - open root motion settings. See <a href="animation/anim_editor.html#root-motion">Root Motion</a> section for more info.</li>
<li><code>Preview Switch</code> - enables or disables animation preview. See <a href="animation/anim_editor.html#preview-mode"><code>Preview Mode</code></a> section for more info.</li>
<li><code>Play/Pause</code> - plays or pauses a currently selected animation (allowed only in the preview mode).</li>
<li><code>Stop</code> - stops a currently selected animation (allowed only in the preview mode).</li>
</ol>
<h2 id="track-list"><a class="header" href="#track-list">Track List</a></h2>
<p>The track list contains a list of tracks of nodes that will be animated. It looks like this:</p>
<p><img src="animation/./ae_track_list.png" alt="track list" /></p>
<ol>
<li><code>Filter Bar</code> - filters the track list by finding tracks whose names matching the filter. You can use this to find
tracks that belong to a particular scene node.</li>
<li><code>Clear Filter</code> - clears the filter, the track list will show all the tracks after this.</li>
<li><code>Collapse All</code> - collapses all the tracks in the list.</li>
<li><code>Expand All</code> - expands all the tracks in the list.</li>
<li><code>Track</code> - a track with some number of children parametric curves.</li>
<li><code>Track Component Curve</code> - parametric curve that serves a data source for the animation for a particular track.</li>
<li><code>Track Switch</code> - enables or disables a track; disabled tracks won't "touch" their properties.</li>
<li><code>Add Track</code> - starts property binding process, see <a href="animation/anim_editor.html#property-binding">Property Binding</a> section for more info.</li>
</ol>
<h3 id="track-context-menu"><a class="header" href="#track-context-menu">Track Context Menu</a></h3>
<p><img src="animation/./ae_track_context_menu.png" alt="context menu" /></p>
<ul>
<li><code>Remove Selected Tracks</code> - removes selected tracks; you can remove multiple tracks at a time by selecting them while
holding <code>Ctrl</code>.</li>
</ul>
<h2 id="curve-editor"><a class="header" href="#curve-editor">Curve Editor</a></h2>
<p>Curve editor allows you to edit parametric curves (one at a time). A curve consists of zero or more key frames with
various transition rules between current and the next. The editor looks like this:</p>
<p><img src="animation/./ae_curve_editor.png" alt="curve editor" /></p>
<ol>
<li><code>Time Ruler</code> - shows time values and every signal of a currently selected animation. A click on the time ruler will
move the playback cursor at the click position. You can move it by clicking at the cursor and moving the mouse while
holding the left mouse button. Animation signals can be moved in the same fashion.</li>
<li><code>Parametric Curve</code> - a curve that defines how a value changes over time.</li>
<li><code>Time Thumb</code> - animation playback cursor, useful only for preview.</li>
<li><code>Animation Signal</code> - some animation signal that will produce animation events when the playback cursor passes it.</li>
</ol>
<h3 id="time-ruler-context-menu"><a class="header" href="#time-ruler-context-menu">Time Ruler Context Menu</a></h3>
<p><img src="animation/./ae_time_ruler_context_menu.png" alt="time ruler context menu" /></p>
<ul>
<li><code>Remove Signal</code> - removes an animation signal under the mouse cursor.</li>
<li><code>Add Signal</code> - adds a new animation signal at the mouse cursor position.</li>
</ul>
<h3 id="key-frame-context-menu"><a class="header" href="#key-frame-context-menu">Key Frame Context Menu</a></h3>
<p><img src="animation/./ae_key_frame_context_menu.png" alt="key frame context menu" /></p>
<ul>
<li><code>Location</code> - shows a key location and allows you to change it. Useful for setting precise values.</li>
<li><code>Value</code> - shows a key value and allows you to change it. Useful for setting precise values.</li>
<li><code>Add Key</code> - adds a new key to the curve.</li>
<li><code>Remove</code> - removes all selected keys. You can select multiple keys either by box selection (click and drag the mouse
to active box selection) or by clicking on separate keys while holding <code>Ctrl</code>.</li>
<li><code>Key...</code> - allows you to change the interpolation type of key. It could be one of the following values: Constant, Linear,
Cubic.</li>
<li><code>Zoom To Fit</code> - tries to find zooming values (for both axes) and the view position with which the entire curve fits in
the viewport.</li>
</ul>
<h2 id="property-binding"><a class="header" href="#property-binding">Property Binding</a></h2>
<p>To animate a property all you need to do is to click on <code>Add Track...</code> button at the bottom of the track list, select
a node to animate and then select a property that will be animated. There are two windows that will be shown one after
another:</p>
<p><img src="animation/./ae_add_track_select_node.png" alt="step1" /></p>
<p><img src="animation/./ae_add_track_select_property.png" alt="step2" /></p>
<p>You can cancel property binding at any time by clicking <code>Cancel</code> in any of the windows. Keep in mind that you can animate
only numeric properties, so not every property is shown in the window.</p>
<h2 id="animation-importing"><a class="header" href="#animation-importing">Animation Importing</a></h2>
<p>Animations can be stored in separate files, but the engine requires all of them to be in a single Animation Player. To
put an animation from an external resource (an FBX, for instance) in the animation player you can use animation
importing. To do that, click on animation import icon and then select a root node of the hierarchy that is animated in
the external animation file, then select the animation file and click <code>Ok</code>. The engine will try to import the animation
and map it to the given hierarchy, mapping is done using node names, so animated node names must match in both your
scene and your external animation file.</p>
<p><img src="animation/./ae_import_select_target_node.png" alt="step1" /></p>
<p><img src="animation/./ae_import_select_animation.png" alt="step2" /></p>
<p>Content of existing animations can be replaced by reimporting. Click on a button with two circular arrows to reimport
your animation. It could be useful if you changed your animation in some external editor (Blender for example) and want
to apply changes in your game.</p>
<h2 id="preview-mode"><a class="header" href="#preview-mode">Preview Mode</a></h2>
<p>Preview mode helps you to see and debug your animation. After activating the mode, you need to play the animation by
clicking the <code>Play/Pause</code> button:</p>
<p><img src="animation/./anim_editor.gif" alt="anim editor" /></p>
<p>Any significant change made in the scene will automatically deactivate the preview mode reverting all the changes made
by playing animation.</p>
<h2 id="root-motion"><a class="header" href="#root-motion">Root Motion</a></h2>
<p>See <a href="animation/root_motion/root_motion.html">Root Motion chapter</a> for more info.</p>
<h2 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h2>
<p>For now there's no dopesheet mode in the editor, you can edit only one numeric parameter at a time. Also, there's no
capture mode - this is a special mode in which the editor automatically adds your changes in the scene to the animation.
These limitations will be removed in the future versions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-blending"><a class="header" href="#animation-blending">Animation Blending</a></h1>
<p>Animation blending is a powerful feature that allows you to mix multiple animations into one. Each animation
is mixed with a various weights which in sum gives 1.0 (100%). By having opposite coefficients (k1 = 0 -&gt; 1, k2 = 1 -&gt; 0)
changing in time it is possible to create transition effect.</p>
<p>Handling transitions with all the coefficients is a routine job, the engine can handle it for you giving you some nice
features:</p>
<ul>
<li>Multiple states with smooth transitions between them</li>
<li>Ability to blend multiple animations in one and use it as pose source for blending</li>
<li>Ability to specify a set of variables that will be used as blending coefficients and transition rules.</li>
</ul>
<p>All these features consolidated in so-called animation blending state machine (ABSM). Machine is used to blend multiple
animation as well as perform automatic "smooth" transition between states. In general, ABSM could be represented like
this:</p>
<p><img src="animation/absm_structure.png" alt="ABSM Structure" /></p>
<p>At the first look it may seem very complicated, but in reality it uses quite simple techniques. Let's start from
the left side of the picture and go to the right. Yellow rectangle at the left depicts an animation player node
that contains a bunch of animations, that will be used for blending. Two center blocks (layer 0 and layer 1) depicts
separate layers (ABSM could have any number of layers in it). Each layer can contain an arbitrary nodes (green
shapes), states (blue shapes), transitions (thick yellow arrows).</p>
<p>Nodes serves as a source of poses, that can be blended in any desired way. States are the part of the inner state
machine, only one state could be active at the same time. Transitions are used to specify state transition rules.</p>
<p>At the "exit" of each layer there's a layer filter, it is responsible for filtering out values for specific
scene nodes and could be used to prevent some scene nodes from being animated by a certain layer. Please note
that despite the look of it, layer filter not necessarily be applied after all animations and states are blended -
it could be done at any moment and drawn like so only for simplicity reasons.</p>
<p>The last, but not the least, important thing on the picture is the parameters container on the right side of the
picture. Parameter either a transition rule, blending weight, or sampling point. If you look closely at the
transitions or animation blending nodes you'll see small text marks. This is the names of the respective parameters.</p>
<p>In general, any state machine works like this - ABSM nodes are used to blend or fetch animations and their resulting
poses are used by ABSM states. Active state provides final pose, which is then passes filtering and returned to
you. After the last stage, you can apply the pose to a scene graph to make the resulting animation to have effect.</p>
<h2 id="how-to-create-15"><a class="header" href="#how-to-create-15">How to create</a></h2>
<p>As always, there are two major ways of creating things in Fyrox - from the editor or from code. Take your pick.</p>
<h2 id="from-editor-2"><a class="header" href="#from-editor-2">From editor</a></h2>
<p>Use <a href="animation/absm_editor.html">ABSM Editor</a> for to create animation blending state machines.</p>
<h2 id="from-code-2"><a class="header" href="#from-code-2">From code</a></h2>
<p>You can always create an ABSM from code, a simple ABSM could be created like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_absm() -&gt; Machine {
    // Assume that these are correct handles.
    let idle_animation = Handle::default();
    let walk_animation = Handle::default();
    let aim_animation = Handle::default();

    let mut machine = Machine::new();

    let root_layer = machine.layers_mut().first_mut().unwrap();

    let aim = root_layer.add_node(PoseNode::PlayAnimation(PlayAnimation::new(aim_animation)));
    let walk = root_layer.add_node(PoseNode::PlayAnimation(PlayAnimation::new(walk_animation)));

    // Blend two animations together
    let blend_aim_walk =
        root_layer.add_node(PoseNode::BlendAnimations(BlendAnimations::new(vec![
            BlendPose::new(PoseWeight::Constant(0.75), aim),
            BlendPose::new(PoseWeight::Constant(0.25), walk),
        ])));

    let walk_state = root_layer.add_state(State::new("Walk", blend_aim_walk));

    let idle = root_layer.add_node(PoseNode::PlayAnimation(PlayAnimation::new(idle_animation)));
    let idle_state = root_layer.add_state(State::new("Idle", idle));

    root_layer.add_transition(Transition::new(
        "Walk-&gt;Idle",
        walk_state,
        idle_state,
        1.0,
        "WalkToIdle",
    ));
    root_layer.add_transition(Transition::new(
        "Idle-&gt;Walk",
        idle_state,
        walk_state,
        1.0,
        "IdleToWalk",
    ));

    machine
}
<span class="boring">}</span></code></pre></pre>
<p>Here we have Walk, Idle and Run states which use different sources of poses:</p>
<ul>
<li>Walk - is the most complicated here - it uses result of blending between <code>Aim</code> and <code>Walk</code> animations with different
weights. This is useful if your character can only walk or can walk <em>and</em> aim at the same time. Desired pose determined
by Walk Weight and Aim Weight parameters combination.</li>
<li>Run and idle both directly use animation as pose source.</li>
</ul>
<p>There are four transitions between three states each with its own rule. Rule is just a boolean parameter that indicates
that transition should be activated. Let's look at the code example of the above state graph:</p>
<p>As you can see, everything is quite straightforward. Even such simple state machine requires quite a lot of code, which
can be removed by using ABSM editor. Read the next chapter to learn about it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-blending-state-machine-absm-editor"><a class="header" href="#animation-blending-state-machine-absm-editor">Animation Blending State Machine (ABSM) Editor</a></h1>
<p>While it is possible to create and manage animation blending and state manually from code, it quickly becomes too
annoying and hardly manageable. To help you create and manage blending machines in easy way, the engine offers
an ABSM Editor tool. This chapter is an overview of the editor, it is quite complex, but the guide should help you
to figure out which part is made for what. Next chapter will help you to create your first animation blending state
machine.</p>
<p><img src="animation/./absm.png" alt="absm editor" /></p>
<p>The editor has four main parts (panels):</p>
<ol>
<li><code>Toolbar</code> - contains a set of tools to edit animation layers and enable/disable preview mode. See <a href="animation/absm_editor.html#toolbar">Toolbar</a>
section for more info.</li>
<li><code>Parameters</code> - allows you to edit various variables that are responsible for transitions, weight parameters for
blending, etc. See <a href="animation/./absm_parameters.png">Parameters</a> section for more info.</li>
<li><code>State Graph</code> - allows you to create, delete, edit states and transition between them. See <a href="animation/absm_editor.html#state-graph">State Graph</a>
section for more info.</li>
<li><code>State Viewer</code> - allows you to edit pose source for a state. Pose source can be represented either by a single
node that plays an animation, or a series of play animation nodes connected to blending nodes (which can be connected
to other blending nodes, etc.). See <a href="animation/absm_editor.html#state-viewer">State Viewer</a> section for more info.</li>
</ol>
<p>The editor can be opened in two ways - using <code>Utils -&gt; ABSM Editor</code> or by selecting an animation blending state machine
node and clicking <code>Open ABSM Editor...</code> button:</p>
<p><img src="animation/./absm_open1.png" alt="open1" /></p>
<p><img src="animation/./absm_open2.png" alt="open1" /></p>
<p>In both ways you still need to select an an animation blending state machine node for editing.</p>
<h2 id="toolbar-1"><a class="header" href="#toolbar-1">Toolbar</a></h2>
<p><img src="animation/./absm_toolbar.png" alt="toolbar" /></p>
<ol>
<li><code>Preview Switch</code> - enables or disables preview mode for the ABSM. See <a href="animation/absm_editor.html#preview-mode">Preview Mode</a> section for more
info.</li>
<li><code>Layer Name</code> - name of the selected layer. Type a new name here to rename currently selected layer (hit enter or just
click elsewhere to rename).</li>
<li><code>Add Layer</code> - adds a new layer with the name in the <code>Layer Name</code> text box to the ABSM. ABSM can have multiple layers
with the same name, but it strongly advised to set unique names here.</li>
<li><code>Remove Current Layer</code> - removes currently selected layer. You can delete all layers, but in this case your ABSM won't
have any effect.</li>
<li><code>Layer Selector</code> - allows you to select a layer for editing, default selection is none.</li>
<li><code>Layer Mask</code> - opens a <code>Layer Mask Editor</code> and helps you to edit the layer mask of the current layer. See
<a href="animation/absm_editor.html#layer-mask">Layer Mask</a> section for more info.</li>
</ol>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>Parameter is a named and typed variable that provides the animation system with some data required for it to work. There
are only three type of parameters:</p>
<ul>
<li><code>Rule</code> - boolean value that used as a trigger for transitions. When transition is using some rule, it checks the value
of the parameter and if it is <code>true</code> transition starts.</li>
<li><code>Weight</code> - real number (<code>f32</code>) that is used a weight when you're blending multiple animations into one.</li>
<li><code>Index</code> - natural number (<code>i32</code>) that is used as an animation selector.</li>
</ul>
<p><img src="animation/./absm_parameters.png" alt="parameters" /></p>
<ol>
<li><code>Add Parameters</code> - adds a new parameter to the parameters' container.</li>
<li><code>Remove a Parameter</code> - removes selected parameter from the parameters' container.</li>
<li><code>Parameter Name</code> - allows you to set a parameter name.</li>
<li><code>Parameter Type</code> - allows you to select the type of the parameter.</li>
<li><code>Parameter Value</code> - allows you to set parameter value.</li>
</ol>
<h2 id="state-graph"><a class="header" href="#state-graph">State Graph</a></h2>
<p>State Graph allows you to create states and transitions between them.</p>
<p><img src="animation/./absm_state_graph.png" alt="state graph" /></p>
<ol>
<li><code>State</code> - state is final animation for a set of scene nodes, only one state can be active at a time.</li>
<li><code>Transition</code> - is an <em>ordered</em> connection between two states, it defines how much time it needed to perform
blending of two states.</li>
<li><code>Root State</code> - is an entry state of the current layer.</li>
</ol>
<h3 id="state-context-menu"><a class="header" href="#state-context-menu">State Context Menu</a></h3>
<p><img src="animation/./absm_state_context_menu.png" alt="state context menu" /></p>
<ul>
<li><code>Create Transition</code> - starts transition creation from the current state to some other.</li>
<li><code>Remove</code> - removes the state.</li>
<li><code>Set As Entry State</code> - marks the state as an entry state (this state will be active at beginning).</li>
</ul>
<h3 id="transition-context-menu"><a class="header" href="#transition-context-menu">Transition Context Menu</a></h3>
<p><img src="animation/./absm_transition_context_menu.png" alt="transition context menu" /></p>
<ul>
<li><code>Remove Transition</code> - removes selected transition.</li>
</ul>
<h3 id="state-properties"><a class="header" href="#state-properties">State Properties</a></h3>
<p>Select a <code>State</code> node to edit the following properties:</p>
<p><img src="animation/./absm_state_properties.png" alt="state properties" /></p>
<ul>
<li><code>Position</code> - is a location of the state on the canvas.</li>
<li><code>Name</code> - name of the state.</li>
<li><code>Root</code> - handle of the backing animation node inside the state.</li>
</ul>
<h3 id="transition-properties"><a class="header" href="#transition-properties">Transition Properties</a></h3>
<p>Select a <code>Transition</code> node to edit the following properties:</p>
<p><img src="animation/./absm_transition_properties.png" alt="transition properties" /></p>
<ul>
<li><code>Name</code> - name of the state.</li>
<li><code>Transition Time</code> - amount of time for blending between two states (in seconds).</li>
<li><code>Elapsed Time</code> - starting amount of blending time.</li>
<li><code>Source</code> - handle of a source state.</li>
<li><code>Desc</code> - handle of a destination state.</li>
<li><code>Rule</code> - a name of <code>Rule</code> type parameter that defines whether the transition can be activated or not.</li>
<li><code>Invert Rule</code> - defines whether to invert the value of <code>Rule</code> or not.</li>
<li><code>Blend Factor</code> - defines a percentage (in <code>0..1</code> range) of how much transition was active.</li>
</ul>
<h2 id="state-viewer"><a class="header" href="#state-viewer">State Viewer</a></h2>
<p>State Viewer allows you to edit contents of states. You can create animation blending chains of any complexity, the
simplest content of a state is just a single <code>Play Animation</code> node. Currently, the engine supports just three animation
blending nodes:</p>
<ul>
<li><code>Play Animation</code> - takes animation pose directly from specified animation, does nothing to it.</li>
<li><code>Blend Animations</code> - takes multiple animation poses from respective animations and blends them together with
respective blend weights.</li>
<li><code>Blend Animations By Index</code> - takes multiple animation poses from respective animations and switches between them
with "smooth" transition using an index parameter.</li>
</ul>
<p><img src="animation/./absm_state_viewer.png" alt="state viewer" /></p>
<ol>
<li><code>Node</code> - is a source of animation for blending.</li>
<li><code>Connection</code> - defines how nodes are connected to each other. To create a new connection, click on a small dot on a
node, hold the button and start dragging to a dot on some other node.</li>
<li><code>Root Node</code> - root node is marked green; root node is a final source of animation for the parent state.</li>
</ol>
<h3 id="play-animation-properties"><a class="header" href="#play-animation-properties"><code>Play Animation</code> Properties</a></h3>
<p>Select a <code>Play Animation</code> node to edit the following properties:</p>
<p><img src="animation/./absm_play_animation_properties.png" alt="play animation properties" /></p>
<ul>
<li><code>Position</code> - is a location of the node on the canvas.</li>
<li><code>Animation</code> - an animation to fetch the pose from.</li>
</ul>
<h3 id="blend-animations-properties"><a class="header" href="#blend-animations-properties"><code>Blend Animations</code> Properties</a></h3>
<p>Select a <code>Blend Animations</code> node to edit the following properties:</p>
<p><img src="animation/./absm_blend_animations_properties.png" alt="blend animations properties" /></p>
<ul>
<li><code>Position</code> - is a location of the node on the canvas.</li>
<li><code>Pose Sources</code> - a set of input poses. To add a pose either click on <code>+</code> or <code>+Input</code> on the node itself. Don't forget
to connect some nodes to the new input poses.
<ul>
<li><code>Weight</code> - a weight of the pose; could be either a constant value or some parameter.</li>
</ul>
</li>
</ul>
<h3 id="blend-animations-by-index-properties"><a class="header" href="#blend-animations-by-index-properties"><code>Blend Animations By Index</code> Properties</a></h3>
<p>Select a <code>Blend Animations By Index</code> node to edit the following properties:</p>
<p><img src="animation/./absm_blend_animations_by_index_properties.png" alt="blend animations by index properties" /></p>
<ul>
<li><code>Position</code> - is a location of the node on the canvas.</li>
<li><code>Index Parameter</code> - a name of an indexing parameter (must be <code>Index</code> type).</li>
<li><code>Inputs</code> - a set of input poses. To add a pose either click on <code>+</code> or <code>+Input</code> on the node itself. Don't forget to
connect some nodes to the new input poses.
<ul>
<li><code>Blend Time</code> - defines how much time is needed to transition to the pose.</li>
</ul>
</li>
</ul>
<h3 id="connection-context-menu"><a class="header" href="#connection-context-menu">Connection Context Menu</a></h3>
<p>Every connection has a context menu that can be shown by a right-click on a connection.</p>
<p><img src="animation/./absm_connection_context_menu.png" alt="connection context menu" /></p>
<ul>
<li><code>Remove Connection</code> - removes the connection between parent nodes.</li>
</ul>
<h3 id="node-context-menu"><a class="header" href="#node-context-menu">Node Context Menu</a></h3>
<p>Every node has a context menu that can be shown by a right-click on a connection.</p>
<p><img src="animation/./absm_node_context_menu.png" alt="node context menu" /></p>
<ul>
<li><code>Set As Root</code> - sets the node as the final pose source of the parent state.</li>
<li><code>Remove</code> - removes the node from the state.</li>
</ul>
<h2 id="layer-mask"><a class="header" href="#layer-mask">Layer Mask</a></h2>
<p><img src="animation/./absm_layer_mask.png" alt="layer mask" /></p>
<p>Layer mask editor allows you to select which nodes <strong>won't</strong> be animated by the current animation layer. Selected nodes
are marked with dark color. To select multiple nodes at once, hold <code>Ctrl</code> and click on items. The text box at the top
of the window allows you to search for a particular scene node. To save edited layer mask click <code>OK</code>.</p>
<h2 id="preview-mode-1"><a class="header" href="#preview-mode-1">Preview Mode</a></h2>
<p>Preview mode turns on the animation blending state machine and its animation player and allows you to see the result
of the work of the machine. Any significant changes in the scene automatically disables the preview mode and any
changes done by the machine is discarded. While the preview mode is active, you can freely change the values of the
parameters to see how the machine will react to this. This helps you to debug your state machine, it is especially
useful for complex state machines with lots of layers. Here's how the preview mode works:</p>
<p><img src="animation/./absm.gif" alt="absm" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signals-1"><a class="header" href="#signals-1">Signals</a></h1>
<p>In some cases you may need to perform an action when at certain time of your animation. It could be a footstep sound,
when foot touches ground, grenade tossing, etc. This could be done via animation signals. Animation signal is just
a named marker that has time position at an animation timeline. It will be emitted when animation playback time passes
it (left-to-right or right-to-left depending on the actual speed of your animation). All you need to do, is to catch
these signals in your game code and do the desired actions.</p>
<h2 id="how-to-add"><a class="header" href="#how-to-add">How to add</a></h2>
<p>As usual, there are two possible ways of adding animation signals - from the animation editor and from code.</p>
<h3 id="from-animation-editor"><a class="header" href="#from-animation-editor">From animation editor</a></h3>
<p>To add a signal to some animation, select an animation player, open the animation editor, select some animation in
it. Now all you need to do is to right-click on the timeline and press <code>Add Signal</code>.</p>
<p><img src="animation/signal_add.png" alt="Add Signal" /></p>
<p>After the signal is added, you can select it and edit its properties in the inspector. Also, you can drag it on the
timeline to adjust its position.</p>
<p><img src="animation/signal_edit.png" alt="Edit Signal" /></p>
<p>Set a meaningful name to the signal, and it is pretty much done - all you need to do next is to write signal handling
code in your game. See <a href="animation/signal.html#reacting-to-signal-events">the next section</a> to learn how to do it.</p>
<h3 id="from-code-3"><a class="header" href="#from-code-3">From code</a></h3>
<p>A signal could also be added from code, this requires knowing a handle of your animation player and a name/handle of
your animation. Please note the comment about signal's uuid in the code below.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_signal(
    animation_player: Handle&lt;Node&gt;,
    animation_name: &amp;str,
    signal_name: &amp;str,
    graph: &amp;mut Graph,
) {
    if let Some(animation_player) = graph.try_get_mut_of_type::&lt;AnimationPlayer&gt;(animation_player) {
        let animations = animation_player.animations_mut().get_value_mut_silent();
        if let Some((_, animation)) = animations.find_by_name_mut(animation_name) {
            // This uuid should be unique, you could also use Uuid::new_v4() method, but it
            // will generate random uuid on every call. This uuid does not used by the engine,
            // it is used only for searching and useful when you have multiple signals with the
            // same name, but with different uuid.
            let uuid = uuid!("6d472c99-e1d3-44fd-81fd-5eb83bbafdf7");

            animation.add_signal(AnimationSignal::new(uuid, signal_name, 0.5));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="reacting-to-signal-events"><a class="header" href="#reacting-to-signal-events">Reacting to signal events</a></h2>
<p>When you have your signals ready for use, all you need to do is to react to the signals somehow. This is very simple:
just borrow your animation from the animation player and pop animation event one-by-one from internal queue:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn react_to_signal_events(
    animation_player: Handle&lt;Node&gt;,
    animation_name: &amp;str,
    signal_name: &amp;str,
    graph: &amp;mut Graph,
) {
    if let Some(animation_player) = graph.try_get_mut_of_type::&lt;AnimationPlayer&gt;(animation_player) {
        let animations = animation_player.animations_mut().get_value_mut_silent();

        // Ideally, animation fetching should be done via its handle (the first argument of the
        // tuple returned by find_by_name_mut/ref), but for the sake of simplicity we'll do
        // this by name.
        if let Some((_, animation)) = animations.find_by_name_mut(animation_name) {
            // Pop every event one-by-one and do something.
            while let Some(signal) = animation.pop_event() {
                // We're interested only in signals with specific name.
                if signal.name == signal_name {
                    println!("Signal event {} has occurred!", signal.name);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can do pretty much anything when reacting to signals. For example, this could be a prefab instantiation to
create smoke effect under the feet, playing a footstep sound, etc.</p>
<h2 id="events-from-absm"><a class="header" href="#events-from-absm">Events from ABSM</a></h2>
<p>Animation blending state machines are able to collect events from the currently playing animations using
different strategies. This ability prevents you from tedious manual animation events collection from a bunch
of animations manually.</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect_events_from_absm(
    absm: Handle&lt;Node&gt;,
    strategy: AnimationEventCollectionStrategy,
    ctx: &amp;mut ScriptContext,
) -&gt; LayerAnimationEventsCollection {
    if let Some(absm) = ctx
        .scene
        .graph
        .try_get_of_type::&lt;AnimationBlendingStateMachine&gt;(absm)
    {
        if let Some(animation_player) = ctx
            .scene
            .graph
            .try_get_of_type::&lt;AnimationPlayer&gt;(absm.animation_player())
        {
            // Fetch a layer first, it could be any layer of the ABMS, but for simplicity
            // we'll use the first layer.
            if let Some(layer) = absm.machine().layers().first() {
                return layer.collect_active_animations_events(
                    absm.machine().parameters(),
                    animation_player.animations(),
                    strategy,
                );
            }
        }
    }

    Default::default()
}
<span class="boring">}</span></code></pre></pre>
<p>This function collects all animation events from all active animations in the specified ABSM (in its first
layer). The arguments to it are the following:</p>
<ul>
<li><code>absm</code> - a handle to an animation blending state machine node.</li>
<li><code>strategy</code> - event collection strategy, which includes all events collection, max and min weight. The
last two may be used if you're getting a lot of events and want to get events from the animations with max or
min weights respectively.</li>
<li><code>ctx</code> - current script context, available in pretty much any script methods.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="root-motion-1"><a class="header" href="#root-motion-1">Root Motion</a></h1>
<p>Root motion is a special technique that transfers motion from some node in a hierarchy to a physical
capsule, which is then used to perform the actual motion. In action it looks like this:</p>
<iframe width="750" height="410" src="https://youtube.com/embed/0lG8Spzk128" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>As you can see in the first part of the video, the movement of the character looks more like floating above
the ground. This happens because the actual movement of the physical capsule is not synchronized with the
movement of the character. Root motion fixes exactly this issue by taking the motion of some root node of the
animated hierarchy (hips in case of this character) and transferring it to the physical capsule. This makes
the actual movement to be fully synchronized with the movement "baked" in the animation.</p>
<p>Root motion also have some nice effect - you can move your character solely by the movement from animation, and
it will work perfectly in 99% of cases. Animations can also contain some rotations which can also be extracted
and applied to the physical capsule. The next awesome property is that your character will never stand out of
its physical capsule, which will prevent phasing it into walls when playing animations with large movements.</p>
<p>In general, you should prefer root motion -driven movement for your characters whenever you can. Simply because
it eliminates a lot of common problems with character movement. It can also be applied to 2D world and will
work exactly the same.</p>
<h2 id="how-to-enable"><a class="header" href="#how-to-enable">How to enable</a></h2>
<p>You can enable/disable/setup it in the drop-down menu that opens by clicking <code>RM</code> button in the animation editor.
Keep in mind, that root motion should be configured on <em>per animation</em> basis. Most of the animations does not
need the root motion at all.</p>
<p><img src="animation/root_motion/../ae_rm.png" alt="root motion" /></p>
<p>The most important part here is the <code>Root</code> handle, it should be set to a root node that moves by your animation, usually
it is called like "hips" or similar:</p>
<p><img src="animation/root_motion/../ae_root_node.png" alt="root node" /></p>
<p>After that, you need to apply filters for axes - most of the locomotion animations "works" in oXZ plane, so Y axis should
be ignored. Also, if you don't have any turns in your animation, you can also filter out the rotation part.</p>
<p>Alternatively, you can do the same from code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_root_motion(
    animation_player: Handle&lt;Node&gt;,
    animation: Handle&lt;Animation&gt;,
    root_node: Handle&lt;Node&gt;,
    ctx: &amp;mut ScriptContext,
) {
    if let Some(animation_player) = ctx
        .scene
        .graph
        .try_get_mut_of_type::&lt;AnimationPlayer&gt;(animation_player)
    {
        if let Some(animation) = animation_player.animations_mut().try_get_mut(animation) {
            animation.set_root_motion_settings(Some(RootMotionSettings {
                node: root_node,
                ignore_x_movement: false,
                ignore_y_movement: true,
                ignore_z_movement: false,
                ignore_rotations: true,
            }))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code does pretty much the same as the editor on the screenshots above. The arguments of this function are
the following:</p>
<ul>
<li><code>animation_player</code> - a handle to the animation player in which all your animations are stored,</li>
<li><code>animation</code> - a handle of the animation in which you want to enable the root motion (you can obtain the handle
by using <a href="https://docs.rs/fyrox/latest/fyrox/animation/struct.AnimationContainer.html#method.find_by_name_ref">AnimationContainer::find_by_name_ref</a>
method).</li>
<li><code>root_node</code> - a handle to a root node of your character's hierarchy, usually it is called something like "Hips"
or "Pelvis".</li>
<li><code>ctx</code> - script context from your current script.</li>
</ul>
<h2 id="how-to-use-1"><a class="header" href="#how-to-use-1">How to use</a></h2>
<p>Direct root motion values extracted from animations are kind of useless by their own and in 99% of the cases you
should get the average root motion values from a <a href="animation/root_motion/../blending.html">state machine</a> that animates your character. This
is because animation blending state machine properly blends the root motion from all active animation sources.
In general, it could look something like this:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fetch_and_apply_root_motion(
    absm: Handle&lt;Node&gt;,
    rigid_body: Handle&lt;Node&gt;,
    character_model: Handle&lt;Node&gt;,
    ctx: &amp;mut ScriptContext,
) {
    // Step 1. Fetch the velocity vector from the animation blending state machine.
    let transform = ctx.scene.graph[character_model].global_transform();
    let mut velocity = Vector3::default();
    if let Some(state_machine) = ctx
        .scene
        .graph
        .try_get(absm)
        .and_then(|node| node.component_ref::&lt;AnimationBlendingStateMachine&gt;())
    {
        if let Some(root_motion) = state_machine.machine().pose().root_motion() {
            velocity = transform
                .transform_vector(&amp;root_motion.delta_position)
                .scale(1.0 / ctx.dt);
        }
    }

    // Step 2. Apply the velocity to the rigid body and lock rotations.
    if let Some(body) = ctx.scene.graph.try_get_mut_of_type::&lt;RigidBody&gt;(rigid_body) {
        body.set_ang_vel(Default::default());
        body.set_lin_vel(Vector3::new(velocity.x, body.lin_vel().y, velocity.z));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code extracts the current <strong>local-space offset</strong> for the current frame and then transforms the offset to
world-space coordinates. Finally, it reduces the offset by the current delta time (<code>1.0 / ctx.dt</code>) to obtain the
new velocity vector which is then applied to the rigid body (player's capsule).</p>
<p>The arguments in this function are following:</p>
<ul>
<li><code>absm</code> a handle to an instance of Animation Blending State Machine node</li>
<li><code>rigid_body</code> a handle to the rigid body that is used by your character</li>
<li><code>model</code> - a handle to the root node of your character's 3D model.</li>
</ul>
<h3 id="raw-root-motion-values"><a class="header" href="#raw-root-motion-values">Raw root motion values</a></h3>
<p>If for some reason you still need raw root motion values from animations, then you can extract them directly
from the desired animation by using <a href="https://docs.rs/fyrox/latest/fyrox/animation/struct.Animation.html#method.root_motion">Animation::root_motion</a>
method.</p>
<h2 id="combining-root-motion-with-procedural-motion"><a class="header" href="#combining-root-motion-with-procedural-motion">Combining root motion with procedural motion</a></h2>
<p>Sometimes there's a need to combine root motion with some procedural motion (for example - inertia after jumping).
This could be done pretty easily by adding two velocity vectors - one from the root motion, and one from the
procedural motion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite-animation"><a class="header" href="#sprite-animation">Sprite Animation</a></h1>
<p>Sprites can be animated using a series of pre-made images. For performance reasons they're usually packed
into a rectangular texture, where each individual image located in its own cell of a grid. Such texture is
called a sprite sheet, and it looks something like this:</p>
<p><img src="animation/spritesheet/sprite_sheet_example.png" alt="sprite sheet example" /></p>
<p>As you can see, there are multiple frames for each animation (idle, run, sword swing, etc.) packed into a
single image. To play an animation, all we need to do is to change frames with some desired frequency and...
that's pretty much all. That's the simplest animation technique one could imagine.</p>
<p>Sprite sheets usually made by artists, not programmers, so just search online for some sprite sheet or
order a new one from an artist. Programmer's art is pretty much always bad.</p>
<h2 id="how-to-use-2"><a class="header" href="#how-to-use-2">How to use</a></h2>
<p><img src="animation/spritesheet/sprite_animation_editor.png" alt="sprite animation editor" /></p>
<p>Fyrox offers a built-in sprite animation system which has its own editor. To be able to use sprite animation
all you need to do is to add a <code>SpriteSheetAnimation</code> field (or a bunch of them) to your script and put
the following code in its <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "aeebb95f-8e32-490e-971c-c22417bd19c5")]
#[visit(optional)]
struct Player {
    animation: SpriteSheetAnimation,
}

impl ScriptTrait for Player {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Update the animation first, it will switch current frame automatically if needed.
        self.animation.update(ctx.dt);

        if let Some(sprite) = ctx
            .scene
            .graph
            .try_get_mut(ctx.handle)
            .and_then(|n| n.cast_mut::&lt;Rectangle&gt;())
        {
            // Assign the texture from the animation to the sprite first.
            sprite
                .material()
                .data_ref()
                .bind("diffuseTexture", self.animation.texture());

            // Set the current animation's UV rect to the sprite.
            sprite.set_uv_rect(self.animation.current_frame_uv_rect().unwrap_or_default());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>This section of the book explains how to debug various aspects of scenes.</p>
<h2 id="debug-drawing"><a class="header" href="#debug-drawing">Debug Drawing</a></h2>
<p>Sometimes you may need to visualize some objects, that are normally invisible. The engine has built-in debug drawing
context exactly for this purpose. For example, to visualize a point use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Default, Reflect, Debug, Clone, ComponentProvider, TypeUuidProvider)]
#[type_uuid(id = "efc71c98-ecf1-4ec3-a08d-116e1656611b")]
struct MyScript {}

impl ScriptTrait for MyScript {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let self_position = ctx.scene.graph[ctx.handle].global_position();

        ctx.scene
            .drawing_context
            .draw_sphere(self_position, 16, 16, 0.1, Color::GREEN);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code will draw a wireframe sphere at the position of an object, to which the script is attached to.
Keep in mind, that all drawing is performed in world-space coordinates. It is important to note, that
the code above will just add the wireframe sphere line-by-line to internal list of lines, which you must
clear at least once per frame. This is not done automatically, because having a "ghosting" effect could
be useful for debugging to see trajectories and to trace short events. To clear the buffer call the
<code>clear_lines</code> method somewhere in your plugin's <code>update</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct Game {
    scene: Handle&lt;Scene&gt;,
}

impl Plugin for Game {
    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        context.scenes[self.scene].drawing_context.clear_lines();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Drawing context provides a wide variety of helper methods to draw various shapes, starting from lines and ending
by cones, cylinders, etc. The full list of methods is provided below:</p>
<ul>
<li><code>draw_frustum</code> - draws a frustum, which could be obtained, for instance, from a Camera node.</li>
<li><code>draw_aabb</code> - draws an axis-aligned bounding box.</li>
<li><code>draw_oob</code> - draws an object-oriented bounding box.</li>
<li><code>draw_transform</code> - draws three basis vectors of an arbitrary transformation 4x4 matrix.</li>
<li><code>draw_triangle</code> - draws a triangle by 3 vertices.</li>
<li><code>draw_pyramid</code> - draws a pyramid, using vertices for its top, and four vertices for the base.</li>
<li><code>draw_wire_sphere</code> - draws a wireframe sphere.</li>
<li><code>draw_circle</code> - draws a circle.</li>
<li><code>draw_circle_segment</code> - draws a circle segment using angles range.</li>
<li><code>draw_rectangle</code> - draws a rectangle.</li>
<li><code>draw_sphere</code> - draws a sphere.</li>
<li><code>draw_sphere_section</code> - draws a sphere section.</li>
<li><code>draw_cone</code> - draws a cone.</li>
<li><code>draw_cylinder</code> - draws a cylinder.</li>
<li><code>draw_flat_capsule</code> - draws a flat capsule (axial slice).</li>
<li><code>draw_capsule</code> - draws a volumetric capsule.</li>
<li><code>draw_segment_flat_capsule</code> - draws a segment of a flat capsule</li>
<li><code>draw_segment_capsule</code> - draws a segment of volumetric capsule.</li>
<li><code>draw_arrow</code> - draws an arrow.</li>
<li><code>add_line</code> - draws a single line from point to point.</li>
</ul>
<h2 id="nodes"><a class="header" href="#nodes">Nodes</a></h2>
<p>Scene nodes could draw their own debug info to the scene drawing context by overriding <code>debug_draw</code> method
provided by <code>NodeTrait</code>. For example, navigational meshes are normally invisible and only used to calculate
paths, however it could be very useful to actually see them when debugging game's AI:</p>
<p><img src="scene/navmesh_debugging.png" alt="img.png" /></p>
<p>You can debug draw either all scene nodes at once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct Game {
    scene: Handle&lt;Scene&gt;,
}

impl Plugin for Game {
    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        let scene = &amp;mut context.scenes[self.scene];
        for node in scene.graph.linear_iter() {
            node.debug_draw(&amp;mut scene.drawing_context);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Or filter out only specific ones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct Game {
    scene: Handle&lt;Scene&gt;,
}

impl Plugin for Game {
    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        let scene = &amp;mut context.scenes[self.scene];
        for node in scene.graph.linear_iter() {
            if let Some(navmesh) = node.component_ref::&lt;NavigationalMesh&gt;() {
                navmesh.debug_draw(&amp;mut scene.drawing_context);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-4"><a class="header" href="#physics-4">Physics</a></h2>
<p>You can enable debug visualization of physics using built-in drawing methods. All that is needed is to call the <code>draw()</code>
method of a physics world (2D or 3D) like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct Game {
    scene: Handle&lt;Scene&gt;,
}

impl Plugin for Game {
    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        let scene = &amp;mut context.scenes[self.scene];
        scene.graph.physics.draw(&amp;mut scene.drawing_context);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>2D physics can be drawn the same way, just replace <code>.physics</code> with <code>.physics2d</code>. The result should look like this:</p>
<p><img src="scene/physics_debug_draw.png" alt="physics debug draw" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input"><a class="header" href="#input">Input</a></h1>
<p>This chapter explains how the input handling in the engine works. The input system based on various events, that comes
to the window from the OS. It could be mouse events (such as mouse motion, button clicks), keyboard events, touchpad
events, etc.</p>
<p>There are two major points for event handling: <code>Plugin::on_os_event</code> and <code>Script::on_os_event</code>, the first one is used
to react to OS events on plugin scale and the latter - on script scale. Here's a list (not full) of the most common
events that could be used in your game (some rare events are omitted):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Reflect, Debug, Visit)]
struct MyGame {}

impl Plugin for MyGame {
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, _context: PluginContext) {
        match event {
            // This branch should be used for pre-processed events that comes from
            // the main window.
            Event::WindowEvent { event, .. } =&gt; match event {
                WindowEvent::Resized(_) =&gt; {}
                WindowEvent::Moved(_) =&gt; {}
                WindowEvent::CloseRequested =&gt; {}
                WindowEvent::Destroyed =&gt; {}
                WindowEvent::DroppedFile(_) =&gt; {}
                WindowEvent::HoveredFile(_) =&gt; {}
                WindowEvent::HoveredFileCancelled =&gt; {}
                WindowEvent::Focused(_) =&gt; {}
                WindowEvent::KeyboardInput { .. } =&gt; {}
                WindowEvent::ModifiersChanged(_) =&gt; {}
                WindowEvent::Ime(_) =&gt; {}
                WindowEvent::CursorMoved { .. } =&gt; {}
                WindowEvent::CursorEntered { .. } =&gt; {}
                WindowEvent::CursorLeft { .. } =&gt; {}
                WindowEvent::MouseWheel { .. } =&gt; {}
                WindowEvent::MouseInput { .. } =&gt; {}
                WindowEvent::TouchpadPressure { .. } =&gt; {}
                WindowEvent::AxisMotion { .. } =&gt; {}
                WindowEvent::Touch(_) =&gt; {}
                WindowEvent::ScaleFactorChanged { .. } =&gt; {}
                WindowEvent::RedrawRequested =&gt; {}
                _ =&gt; (),
            },
            // This branch should be used for raw input events from various devices.
            Event::DeviceEvent { event, .. } =&gt; match event {
                DeviceEvent::Added =&gt; {}
                DeviceEvent::Removed =&gt; {}
                DeviceEvent::MouseMotion { .. } =&gt; {}
                DeviceEvent::MouseWheel { .. } =&gt; {}
                DeviceEvent::Motion { .. } =&gt; {}
                DeviceEvent::Button { .. } =&gt; {}
                DeviceEvent::Key(_) =&gt; {}
            },
            _ =&gt; (),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, to do an action in response to an event, all you need to do is to write some code in a desired branch.
You can also put the handler code into a method of your plugin/script and call it instead.</p>
<h2 id="immediate-input-state-fetching"><a class="header" href="#immediate-input-state-fetching">Immediate input state fetching</a></h2>
<p>You may be used to much simpler approach of immediate input state fetching, such as <code>keyboard.is_key_pressed(..)</code> or
<code>mouse.position()</code> - Fyrox has this functionality as well. It is up to you which one to pick, but in general, the
event-based approach is much more predictable, consumes less CPU resources, and it leads to less convoluted code.
Read the next few chapters to learn about both approaches and find the one that suits you the most.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard-input"><a class="header" href="#keyboard-input">Keyboard Input</a></h1>
<p>There are two major ways to check the keyboard state - the simple and the event-based ones.</p>
<h2 id="simple-way"><a class="header" href="#simple-way">Simple way</a></h2>
<p>The simplest way to check if a key was pressed/released or if it is still down is three methods of <code>InputState</code>:</p>
<ul>
<li><code>is_key_down</code> - returns <code>true</code> if the specified key is pressed, <code>false</code> - otherwise.</li>
<li><code>is_key_pressed</code> - returns <code>true</code> if the specified key was pressed in the current frame, <code>false</code> - otherwise.
This method will return <code>false</code> if the key is still pressed in the next frame. This is useful to check if a key
was pressed and some action, but do not repeat the same action over and over until the key is released.</li>
<li><code>is_key_released</code> - returns <code>true</code> if the specified key was released in the current frame, <code>false</code> - otherwise.
This method will return <code>false</code> if the key is still released in the next frame. This is useful to check if a
key was released and some action, but do not repeat the same action over and over until the key is pressed.</li>
</ul>
<p>Typical usage of these methods is the following.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "abbad54c-e267-4d7e-a3cd-e125a7e87ff0")]
#[visit(optional)]
pub struct Player {}

impl ScriptTrait for Player {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let node = &amp;mut ctx.scene.graph[ctx.handle];
        let transform = node.local_transform_mut();

        // Check if the keys are down and move the player accordingly.
        if ctx.input_state.is_key_down(KeyCode::KeyA) {
            transform.offset(Vector3::new(-1.0, 0.0, 0.0));
        }
        if ctx.input_state.is_key_down(KeyCode::KeyD) {
            transform.offset(Vector3::new(1.0, 0.0, 0.0));
        }

        // It is also possible to check if a key was pressed or released on this frame. This
        // could be useful to do something only once per each press or release. For example,
        // jump could be performed on a key press.
        if ctx.input_state.is_key_pressed(KeyCode::Space) {
            transform.offset(Vector3::new(0.0, 1.0, 0.0));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="event-based-approach"><a class="header" href="#event-based-approach">Event-based approach</a></h2>
<p>The more advanced approach is to use keyboard events directly. This may seem harder to maintain than the simple
approach with functions like <code>is_key_down</code>, but in reality it is slightly more verbose. The main advantage is
that this approach allows you to carefully select which entity will receive an event.</p>
<p>Keyboard input events can be handled by listening to <code>WindowEvent::KeyboardInput</code>, for example you can check for A, D
keys and save their state in some variables in your script. These variables will tell the script that an entity, to
which the script was assigned, should move in a certain direction. This could be expressed like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "abbad54c-e267-4d7e-a3cd-e125a7e87ff0")]
#[visit(optional)]
pub struct Player {
    move_left: bool,
    move_right: bool,
}

impl ScriptTrait for Player {
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, _ctx: &amp;mut ScriptContext) {
        // Listen to keyboard events, that comes to the main window.
        if let Event::WindowEvent {
            event: WindowEvent::KeyboardInput { event, .. },
            ..
        } = event
        {
            let pressed = event.state == ElementState::Pressed;
            if let PhysicalKey::Code(code) = event.physical_key {
                // Check which key was pressed and remember this state for further usage.
                match code {
                    KeyCode::KeyA =&gt; {
                        self.move_left = pressed;
                    }
                    KeyCode::KeyD =&gt; {
                        self.move_right = pressed;
                    }
                    _ =&gt; (),
                }
            }
        }
    }

    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let node = &amp;mut ctx.scene.graph[ctx.handle];
        let transform = node.local_transform_mut();
        if self.move_left {
            transform.offset(Vector3::new(-1.0, 0.0, 0.0));
        }
        if self.move_right {
            transform.offset(Vector3::new(1.0, 0.0, 0.0));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The main method here is <code>on_os_event</code>, which listens for keyboard events and modifies script variables accordingly.
These two variables are then used in the <code>on_update</code> method to move the entity, to which the script is assigned to.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse-input"><a class="header" href="#mouse-input">Mouse Input</a></h1>
<p>Mouse input is usually used to control a camera rotation, to pick objects in game world, etc. There are two major
ways to get the mouse state - the simple and the event-based ones.</p>
<h2 id="mouse-motion"><a class="header" href="#mouse-motion">Mouse Motion</a></h2>
<p>The following example shows how to use raw mouse events to rotate an object. It could also be used to rotate a camera
in your game (with slight modifications).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "abbad54c-e267-4d7e-a3cd-e125a7e87ff0")]
#[visit(optional)]
pub struct Player {
    yaw: f32,
    pitch: f32,
}

impl ScriptTrait for Player {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let mouse_speed = ctx.input_state.mouse_speed();
        let limit = std::f32::consts::FRAC_PI_2;

        self.pitch = (self.pitch + mouse_speed.y).clamp(-limit, limit);
        self.yaw += mouse_speed.x;

        let node = &amp;mut ctx.scene.graph[ctx.handle];
        let transform = node.local_transform_mut();
        transform.set_rotation(
            UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.pitch)
                * UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.yaw),
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The same can be done with an event-based approach:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "abbad54c-e267-4d7e-a3cd-e125a7e87ff0")]
#[visit(optional)]
pub struct Player {
    yaw: f32,
    pitch: f32,
}

impl ScriptTrait for Player {
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, _ctx: &amp;mut ScriptContext) {
        // We'll listen to MouseMotion raw device event to rotate an object. It provides
        // offsets only.
        if let Event::DeviceEvent {
            event: DeviceEvent::MouseMotion {
                delta: (dx, dy), ..
            },
            ..
        } = event
        {
            let limit = std::f32::consts::FRAC_PI_2;
            self.pitch = (self.pitch + *dy as f32).clamp(-limit, limit);
            self.yaw += *dx as f32;
        }
    }

    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let node = &amp;mut ctx.scene.graph[ctx.handle];
        let transform = node.local_transform_mut();
        transform.set_rotation(
            UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.pitch)
                * UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.yaw),
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This example consists of two main parts - <code>on_os_event</code> and <code>on_update</code> methods. The first one is called when some
event comes to the main window, and we need to check if this event is <code>DeviceEvent::MouseMotion</code>. After that, we're taking
relative offsets (<code>dx</code>, <code>dy</code>) and modifying the <code>pitch</code>, <code>yaw</code> variables accordingly. <code>on_update</code> method is called
every frame and it is used to apply <code>pitch</code> and <code>yaw</code> values to the scene node the script is assigned to.</p>
<h2 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h2>
<p>The following example shows how to handle events from mouse buttons.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "abbad54c-e267-4d7e-a3cd-e125a7e87ff1")]
#[visit(optional)]
pub struct Clicker {
    counter: i32,
}

impl ScriptTrait for Clicker {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        if ctx.input_state.is_left_mouse_button_pressed() {
            self.counter += 1;
        } else if ctx.input_state.is_left_mouse_button_released() {
            self.counter -= 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The same can be done with an event-based approach:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "abbad54c-e267-4d7e-a3cd-e125a7e87ff1")]
#[visit(optional)]
pub struct Clicker {
    counter: i32,
}

impl ScriptTrait for Clicker {
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, _ctx: &amp;mut ScriptContext) {
        if let Event::WindowEvent {
            event: WindowEvent::MouseInput { button, state, .. },
            ..
        } = event
        {
            if *state == ElementState::Pressed {
                match *button {
                    MouseButton::Left =&gt; {
                        self.counter -= 1;
                    }
                    MouseButton::Right =&gt; {
                        self.counter += 1;
                    }
                    _ =&gt; (),
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>At first, we're checking for <code>WindowEvent::MouseInput</code> and creating respective bindings to its internals (<code>button</code>, <code>state</code>)
and then all we need to do, is to check if the button was pressed and if so, which one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-text-input-wip"><a class="header" href="#raw-text-input-wip">Raw Text Input (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artificial-intelligence-wip"><a class="header" href="#artificial-intelligence-wip">Artificial Intelligence (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behaviour-trees-wip"><a class="header" href="#behaviour-trees-wip">Behaviour Trees (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-finding"><a class="header" href="#path-finding">Path Finding</a></h1>
<p>Fyrox has built-in <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* (A-star)</a> algorithm for pathfinding. It can be
used to find a path on arbitrary graph without cycles. It could be a simple grid where each point knows about its
"neighbours", <a href="ai/./navmesh.html">navigational mesh</a>, or some other graph.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>The simplest examples could be a search of path on uniform grid. This could be useful for games with open worlds,
strategies, and any other types of games that uses uniform grid for pathfinding.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn astar_on_uniform_grid() {
    // Create vertices.
    let size = 40;
    let mut vertices = Vec::new();
    for y in 0..size {
        for x in 0..size {
            vertices.push(GraphVertex::new(Vector3::new(x as f32, y as f32, 0.0)));
        }
    }
    let mut pathfinder = Graph::new();
    pathfinder.set_vertices(vertices);

    // Link vertices to form a uniform grid.
    for y in 0..(size - 1) {
        for x in 0..(size - 1) {
            pathfinder.link_bidirect(y * size + x, y * size + x + 1);
            pathfinder.link_bidirect(y * size + x, (y + 1) * size + x);
        }
    }

    // Build a path from vertex 0 to vertex 100.
    let mut path = Vec::new();
    assert!(pathfinder.build_positional_path(0, 100, &amp;mut path).is_ok());
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that the returned path is always reversed (its first point corresponds to an <code>end</code> point). You need either
to reverse the path, or (which is much faster) just iterate in reverse over its points.</p>
<h2 id="what-to-use"><a class="header" href="#what-to-use">What to use</a></h2>
<p>A* is very simple, yet powerful algorithm. However, it is not always suitable, because it searches only on graph vertices
and cannot build paths that are lying on a surface of arbitrary meshes. Simple path finding on a uniform grid is ok
for some games (strategies for instance), but in FPS games it will look awful. In this case you should use
<a href="ai/./navmesh.html">navigational meshes</a> which can build path on a surface of arbitrary meshes.</p>
<h2 id="performance-10"><a class="header" href="#performance-10">Performance</a></h2>
<p>Current A* implementation is very well optimized, yet it still loses "some points" in comparison to other specialized
implementations of this algorithm.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigational-meshes"><a class="header" href="#navigational-meshes">Navigational Meshes</a></h1>
<p><img src="ai/./navmesh.gif" alt="navmesh" /></p>
<p>Navigational mesh (navmesh for short) is a surface which can be used for path finding. Unlike
<a href="ai/./pathfinding.html">A* Pathfinder</a>, it can build arbitrary paths on a surface of large polygons, making a path from
point A to point B linear (standard pathfinder builds path only from vertex to vertex). Navmeshes should be used when
you have an arbitrary "walkable" surface, for example, a game level with rooms, hallways, multiple floors and so on.
A* pathfinder should be used for strategies or any other types of games with uniform pathfinding grid.</p>
<h2 id="how-to-create-16"><a class="header" href="#how-to-create-16">How to create</a></h2>
<p>There are three major ways of creating navigational meshes: manual, automatic, from external data.</p>
<h3 id="using-the-editor-1"><a class="header" href="#using-the-editor-1">Using the editor</a></h3>
<p>Navigational meshes can be created and edited in the FyroxEd. At first, create a "Navigational Mesh" node, select it and
switch to "navmesh" interaction mode:</p>
<p><img src="ai/./navmesh.png" alt="navmesh" /></p>
<p>Now you can edit the navmesh. For now, editing capabilities are quite limited and the only way to edit the navmesh is
to Shift+Drag one if its edges:</p>
<p><img src="ai/./navmesh_edit.gif" alt="navmesh edit" /></p>
<p>You can also delete edges and vertices: select a vertex or an edge and press <code>Delete</code> key. If you need to create closed
loops, use "Connect Edges" button in the "Navmesh" floating panel:</p>
<p><img src="ai/./navmesh_connect.png" alt="navmesh connect" /></p>
<h3 id="using-automatic-generation"><a class="header" href="#using-automatic-generation">Using automatic generation</a></h3>
<p>Fyrox does not support automatic navigational mesh generation yet. You can help by adding such feature.</p>
<h3 id="using-external-data"><a class="header" href="#using-external-data">Using external data</a></h3>
<p>It is possible to create a navigational mesh from an arbitrary mesh, which could be made somewhere else (in Blender,
3Ds Max, or even generated by a navmesh generator). If you have a <code>Mesh</code> scene node in your scene then you could do
something like this to build a navmesh from it:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_navmesh(scene: &amp;Scene, navmesh_name: &amp;str) -&gt; Navmesh {
    // Find mesh node in existing scene and create navigation mesh from it.
    let navmesh_node_handle = scene.graph.find_by_name_from_root(navmesh_name).unwrap().0;
    Navmesh::from_mesh(scene.graph[navmesh_node_handle].as_mesh())
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, you can create a navmesh directly from code like so:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_navmesh_from_vertices() -&gt; Navmesh {
    Navmesh::new(
        vec![
            TriangleDefinition([0, 1, 3]),
            TriangleDefinition([1, 2, 3]),
            TriangleDefinition([2, 5, 3]),
            TriangleDefinition([2, 4, 5]),
            TriangleDefinition([4, 7, 5]),
            TriangleDefinition([4, 6, 7]),
        ],
        vec![
            Vector3::new(0.0, 0.0, 0.0),
            Vector3::new(0.0, 0.0, 1.0),
            Vector3::new(1.0, 0.0, 1.0),
            Vector3::new(1.0, 0.0, 0.0),
            Vector3::new(2.0, 0.0, 1.0),
            Vector3::new(2.0, 0.0, 0.0),
            Vector3::new(3.0, 0.0, 1.0),
            Vector3::new(3.0, 0.0, 0.0),
        ],
    )
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Navmesh::new</code> method accepts a list of triangles and vertices, where triangles is a set of three indices of
vertices forming a triangle.</p>
<h2 id="agents"><a class="header" href="#agents">Agents</a></h2>
<p>Navigational mesh agent helps you to build paths along the surface of a navigational mesh and follow it. Agents can be
used to drive the motion of your game characters. Every agent knows about its target and automatically rebuilds the path
if the target has moved. Navmesh agents are able to move along the path, providing you with their current position, so you
can use it to perform an actual motion of your game characters. Agents work together with navigational meshes, you need
to update their state every frame, so they can recalculate path if needed. A simple example could something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::utils::navmesh::NavmeshAgent;
</span><span class="boring">struct Foo { 
</span>// Add this to your script
agent: NavmeshAgent
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>After that, you need to update the agent every frame to make sure it will follow the target:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_agent(
    agent: &amp;mut NavmeshAgent,
    target: Vector3&lt;f32&gt;,
    dt: f32,
    navmesh: &amp;mut NavigationalMesh,
) {
    // Set the target to follow and the speed.
    agent.set_target(target);
    agent.set_speed(1.0);

    // Update the agent.
    let navmesh = navmesh.navmesh();
    agent.update(dt, &amp;navmesh.read()).unwrap();

    // Print its position - you can use this position as target point of your game character.
    println!("{}", agent.position());
}
<span class="boring">}</span></code></pre></pre>
<p>This method should be called in <code>on_update</code> of your script. It accepts four parameters: a reference to the agent, a
target which it will follow, a time step (<code>context.dt</code>), and a reference to navigational mesh node. You can fetch
navigational mesh from the scene graph by its name:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_navmesh&lt;'a&gt;(scene: &amp;'a mut Scene, name: &amp;str) -&gt; &amp;'a mut NavigationalMesh {
    let handle = scene.graph.find_by_name_from_root(name).unwrap().0;
    scene.graph[handle].as_navigational_mesh_mut()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="radius"><a class="header" href="#radius">Radius</a></h3>
<p>It is possible to specify a radius for navigation mesh agents, which could be used to walk around corners like so:</p>
<p><img src="ai/./agent_radius.gif" alt="agent radius" /></p>
<p>In some cases this behaviour is preferable, because it makes produced paths to look more natural. You can set agent's
radius using <code>set_radius</code> method. By default, it is set to 0.2 meters, which is an average radius that is suitable for
most of the cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-wip"><a class="header" href="#rendering-wip">Rendering (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shaders"><a class="header" href="#shaders">Shaders</a></h1>
<p>Shader is a set of programs that run directly on graphics adapter. Each program from the set is called
<em>sub-shader</em>. Sub-shaders linked with render pass, each render pass defines "where" to draw an object.
"where" means that you can set up your own render pass and the renderer will use the sub-shader with
your render pass. For the ease of use, there are a number of <a href="rendering/shaders.html#predefined-render-passes">predefined render passes</a>.</p>
<p>Shaders have properties of various types that can be used together with materials to draw an object.</p>
<h2 id="shaders-language"><a class="header" href="#shaders-language">Shaders language</a></h2>
<p>The engine uses GLSL shading language for every sub-shader. There are many GLSL guides over the
internet, so there is no need to "re-post" the well-documented info again.</p>
<p>There are very few differences:</p>
<ol>
<li>No need to define a version of the shader. Every shader source will be pre-processed, and it will
get the correct version automatically. Preprocessing is needed because the same shader could run on OpenGL
and WebGL (OpenGL ES) which have some differences.</li>
<li>There is a "standard" library of useful methods that is automatically included in every shader source
at preprocessing stage. The library source could be found
<a href="https://github.com/FyroxEngine/Fyrox/blob/1b886caf831b87fb17958bac7f38a6b2d305646c/fyrox-graphics/src/gl/shaders/shared.glsl">here</a>.
It is well documented, and you may find some functions useful for your job.</li>
<li>There's automatic generation of uniform buffers for property groups (see <a href="rendering/shaders.html#code-generation">this section</a> for
more info).</li>
</ol>
<h2 id="structure-1"><a class="header" href="#structure-1">Structure</a></h2>
<p>Shader has a rigid structure that could be described in this code snippet:</p>
<pre><code class="language-json">(
	name: "MyShader",

    // A set of resources, the maximum amount of resources is limited by your GPU. The engine
    // guarantees, that there could at least 16 textures and 16 resource groups per shader.
    resources: [
        (
            // Each resource binding must have a name.
            name: "diffuseTexture",

            // Value has limited set of possible variants.
            kind: Texture(kind: Sampler2D, fallback: White),

            binding: 0
        ),
		(
            name: "properties",
            kind: PropertyGroup([
                (
                    name: "diffuseColor",
                    kind: Color(r: 255, g: 255, b: 255, a: 255),
                ),
            ]),
            binding: 0
        ),
        // There are number of built-in property groups which provides useful data for each shader.
        // See the full list of built-in property groups below.
        (
            name: "fyrox_instanceData",
            kind: PropertyGroup([
                // Autogenerated
            ]),
            binding: 1
        ),
    ],

    // A set of passes that are intentionally missing in the shader.
    disabled_passes: ["GBuffer", "DirectionalShadow", "PointShadow", "SpotShadow"],
        
    // A set of render passes (see a section `Render pass` for more info)
    passes: [
        (
            // Name must match with the name of either standard render pass (see below) or
            // one of your passes.
            name: "Forward",

            // A set of parameters that regulate renderer pipeline state.
            // This is mandatory field of each render pass.
            draw_parameters: DrawParameters(
                // A face to cull. Either Front or Back.
                cull_face: Some(Back),

                // Color mask. Defines which colors should be written to render target.
                color_write: ColorMask(
                    red: true,
                    green: true,
                    blue: true,
                    alpha: true,
                ),

                // Whether to modify depth buffer or not.
                depth_write: true,

                // Whether to use stencil test or not.
                stencil_test: None,

                // Whether to perform depth test when drawing.
                depth_test: Some(Less),

                // Blending options.
                blend: Some(BlendParameters(
                    func: BlendFunc(
                        sfactor: SrcAlpha,
                        dfactor: OneMinusSrcAlpha,
                        alpha_sfactor: SrcAlpha,
                        alpha_dfactor: OneMinusSrcAlpha,
                    ),
                    equation: BlendEquation(
                        rgb: Add,
                        alpha: Add
                    )
                )),

                // Stencil options.
                stencil_op: StencilOp(
                    fail: Keep,
                    zfail: Keep,
                    zpass: Keep,
                    write_mask: 0xFFFF_FFFF,
                ),

                // Scissor box. Could be something like this:
				//
				// scissor_box: Some(ScissorBox(
                //    x: 10,
                //    y: 20,
                //    width: 100,
                //    height: 30
                // ))
                scissor_box: None
            ),

            // Vertex shader code.
            vertex_shader:
                r#"
                layout(location = 0) in vec3 vertexPosition;
                layout(location = 1) in vec2 vertexTexCoord;

                out vec2 texCoord;

                void main()
                {
                    texCoord = vertexTexCoord;
                    gl_Position = fyrox_instanceData.worldViewProjection * vec4(vertexPosition, 1.0);
                }
                "#,

            // Fragment shader code.
            fragment_shader:
                r#"
                out vec4 FragColor;

                in vec2 texCoord;

                void main()
                {
                    FragColor = properties.diffuseColor * texture(diffuseTexture, texCoord);
                }
                "#,
        )
    ],
)
</code></pre>
<p>Shader should contain at least one render pass to actually do some job. A shader could not have properties at all.
Currently only vertex and fragment programs are supported. Each program must be written in GLSL. Comprehensive
GLSL documentation can be found <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)">here</a></p>
<p>The engine can load such shaders if you save it in a file with <code>.shader</code> extension. After that, you can assign
the shader to your material in the Material Editor:</p>
<p><img src="rendering/./shader.png" alt="shader" /></p>
<p>Alternatively, you can load the shader from code. To do this, you can use this code:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_shader(resource_manager: &amp;ResourceManager) -&gt; ShaderResource {
    resource_manager.request::&lt;Shader&gt;("path/to/my/cool.shader")
}
<span class="boring">}</span></code></pre></pre>
<p>After that, you can use the shader to build a material from it:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_material(resource_manager: &amp;ResourceManager) -&gt; MaterialResource {
    let shader = resource_manager.request::&lt;Shader&gt;("path/to/my/cool.shader");
    MaterialResource::new(Material::from_shader(shader))
}
<span class="boring">}</span></code></pre></pre>
<p>This material instance can be used for rendering. For example, you can assign it a surface of some mesh.</p>
<h2 id="render-pass"><a class="header" href="#render-pass">Render pass</a></h2>
<p>Modern rendering is a very complex thing that requires drawing an object multiple times
with different "scripts". For example, to draw an object with shadows, you need to draw an
object twice: one directly in a render target, and one in a shadow map. Such stages called
render passes.</p>
<p>Binding of shaders to render passes is done via names, each render pass has a unique name.</p>
<h3 id="predefined-render-passes"><a class="header" href="#predefined-render-passes">Predefined render passes</a></h3>
<p>Predefined render passes helps you to create your own shader without a need to create your own render pass
and to quickly start writing your shaders.</p>
<ul>
<li><strong>GBuffer</strong> - A pass that fills a set with render target sized textures with various data about each rendered
object. These textures then are used for physically based lighting. Use this pass when you want the standard
lighting to work with your objects.</li>
<li><strong>Forward</strong> - A pass that draws an object directly in a render target. It could be used to render translucent objects.</li>
<li><strong>SpotShadow</strong> - A pass that emits depth values for an object, later this depth map will be used to render shadows.</li>
<li><strong>PointShadow</strong> - A pass that emits distance from a fragment to a point light, later this depth map will be used
to render shadows.</li>
<li><strong>DirectionalShadow</strong> - A pass that emits depth values for an object, later this depth map will be used to render
shadows for directional light sources using cascaded shadow mapping.</li>
</ul>
<h2 id="disables-passes"><a class="header" href="#disables-passes">Disables passes</a></h2>
<p>A render pass can be marked as "disabled" to prevent the renderer emitting errors when it tries
to use such render pass. This mechanism of explicit marking the pass disabled is here to ensure
correctness of shaders. To explicitly disable a pass, add its name to <code>disabled_passes</code> array:</p>
<pre><code class="language-ron">disabled_passes: ["GBuffer", "DirectionalShadow", "PointShadow", "SpotShadow"],
</code></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>Each shader requires a specific set of external resources that will be used during the rendering.
This set is defined in <code>resources</code> section of the shader and could contain the following resources:</p>
<ul>
<li><code>Texture</code> - a texture of arbitrary type</li>
<li><code>PropertyGroup</code> - a group of numeric properties.</li>
</ul>
<h3 id="binding-points"><a class="header" href="#binding-points">Binding points</a></h3>
<p>Shader resource must define a unique (over its type) binding index. The engine will use these
points to prepare appropriate resource descriptor sets for GPU. Keep in mind, that binding point
indices are <strong>unique</strong> per each type of resource. This means that a set of texture resources could
use the same indices as property groups. The binding points must be unique in its group. If
there is more than one resource of a certain type, that shares the same binding point, the
engine will refuse to use such a shader.</p>
<h3 id="built-in-resources"><a class="header" href="#built-in-resources">Built-in resources</a></h3>
<p>There are a number of built-in resources, that Fyrox will try to assign automatically if they're
defined in your shader, something like this:</p>
<pre><code class="language-ron">(
    name: "fyrox_instanceData",
    kind: PropertyGroup([
        // Autogenerated
    ]),
    binding: 1
),
</code></pre>
<p>The full list of built-in resources is defined below.</p>
<h4 id="fyrox_instancedata"><a class="header" href="#fyrox_instancedata"><code>fyrox_instanceData</code></a></h4>
<p>Property group. Provided for each rendered surface instance.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>worldMatrix</td><td><code>mat4</code></td><td>Local-to-world transformation.</td></tr>
<tr><td>worldViewProjection</td><td><code>mat4</code></td><td>Local-to-clip-space transform.</td></tr>
<tr><td>blendShapesCount</td><td><code>int</code></td><td>Total amount of blend shapes.</td></tr>
<tr><td>useSkeletalAnimation</td><td><code>bool</code></td><td>Whether skinned meshes is rendering or not.</td></tr>
<tr><td>blendShapesWeights</td><td><code>vec4[32]</code></td><td>Blend shape weights.</td></tr>
</tbody></table>
</div>
<h4 id="fyrox_bonematrices"><a class="header" href="#fyrox_bonematrices"><code>fyrox_boneMatrices</code></a></h4>
<p>Property group. Provided for each rendered surface, that has skeletal animation.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>matrices</td><td><code>mat4[256]</code></td><td>Bone matrices</td></tr>
</tbody></table>
</div>
<h4 id="fyrox_cameradata"><a class="header" href="#fyrox_cameradata"><code>fyrox_cameraData</code></a></h4>
<p>Property group. Contains camera properties. It contains info not only about scene camera,
but also observer info when rendering shadow maps. In other words - it is generic observer
properties.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>viewProjectionMatrix</td><td><code>mat4</code></td><td>World-to-clip-space transformation.</td></tr>
<tr><td>position</td><td><code>vec3</code></td><td>World-space position of the camera.</td></tr>
<tr><td>upVector</td><td><code>vec3</code></td><td>World-space up-vector of the camera.</td></tr>
<tr><td>sideVector</td><td><code>vec3</code></td><td>World-space side-vector of the camera.</td></tr>
<tr><td>zNear</td><td><code>float</code></td><td>Near clipping plane location.</td></tr>
<tr><td>zFar</td><td><code>float</code></td><td>Far clipping plane location.</td></tr>
<tr><td>zRange</td><td><code>float</code></td><td><code>zFar - zNear</code></td></tr>
</tbody></table>
</div>
<h4 id="fyrox_lightdata"><a class="header" href="#fyrox_lightdata"><code>fyrox_lightData</code></a></h4>
<p>Property group. Available only in shadow passes.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>lightPosition</td><td><code>vec3</code></td><td>World-space light source position. Only for shadow passes.</td></tr>
<tr><td>ambientLightColor</td><td><code>vec4</code></td><td>Ambient lighting color of the scene.</td></tr>
</tbody></table>
</div>
<h4 id="fyrox_lightsblock"><a class="header" href="#fyrox_lightsblock"><code>fyrox_lightsBlock</code></a></h4>
<p>Property group. Information about visible light sources</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>lightCount</td><td><code>int</code></td><td>Total amount of light sources visible on screen.</td></tr>
<tr><td>lightsColorRadius</td><td><code>vec4[16]</code></td><td>Color (xyz) and radius (w) of light source</td></tr>
<tr><td>lightsParameters</td><td><code>vec2[16]</code></td><td>Hot-spot cone angle cos (x) and half cone angle cos (y)</td></tr>
<tr><td>lightsPosition</td><td><code>vec3[16]</code></td><td>World-space light position.</td></tr>
<tr><td>lightsDirection</td><td><code>vec3[16]</code></td><td>World-space light direction</td></tr>
</tbody></table>
</div>
<h4 id="fyrox_graphicssettings"><a class="header" href="#fyrox_graphicssettings"><code>fyrox_graphicsSettings</code></a></h4>
<p>Property group. Contains graphics options of the renderer.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>usePom</td><td><code>bool</code></td><td>Whether to use parallax occlusion mapping or not.</td></tr>
</tbody></table>
</div>
<h4 id="fyrox_scenedepth"><a class="header" href="#fyrox_scenedepth"><code>fyrox_sceneDepth</code></a></h4>
<p>Texture. Contains depth values of a scene. Available <strong>only</strong> after opaque geometry is
rendered (read - G-Buffer is filled). Typical usage is something like this:</p>
<pre><code class="language-ron">(
    name: "fyrox_sceneDepth",
    kind: Texture(kind: Sampler2D, fallback: White),
    binding: 1
),
</code></pre>
<h3 id="fyrox_widgetdata"><a class="header" href="#fyrox_widgetdata"><code>fyrox_widgetData</code></a></h3>
<p>Property group. Contains UI widget-specific data, that can be used in UI shaders.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>worldViewProjection</td><td><code>mat4</code></td><td>World-to-clip-space transformation matrix.</td></tr>
<tr><td>solidColor</td><td><code>vec4</code></td><td>RGBA color.</td></tr>
<tr><td>gradientColors</td><td><code>vec4[16]</code></td><td>A set of gradient colors.</td></tr>
<tr><td>gradientStops</td><td><code>float[16]</code></td><td>A set of normalized (0.0-1.0) stops along the axis.</td></tr>
<tr><td>gradientOrigin</td><td><code>vec2</code></td><td>Origin position of the gradient (local coordinates).</td></tr>
<tr><td>gradientEnd</td><td><code>vec2</code></td><td>End position of the gradient (local coordinates).</td></tr>
<tr><td>gradientPointCount</td><td><code>int</code></td><td>Total number of gradient points.</td></tr>
<tr><td>resolution</td><td><code>vec2</code></td><td>Frame buffer size to which the widget is drawn to.</td></tr>
<tr><td>boundsMin</td><td><code>vec2</code></td><td>Top-left point of the screen space bounding rectangle.</td></tr>
<tr><td>boundsMax</td><td><code>vec2</code></td><td>Right-bottom point of the screen space bounding rectangle.</td></tr>
<tr><td>isFont</td><td><code>bool</code></td><td><code>true</code> if the widget is a text, <code>false</code> - otherwise.</td></tr>
<tr><td>opacity</td><td><code>float</code></td><td>Opacity (0.0-1.0 range).</td></tr>
<tr><td>brushType</td><td><code>int</code></td><td>Brush type (0 solid, 1-linear gradient, 2-radial gradient</td></tr>
</tbody></table>
</div>
<h2 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h2>
<p>Fyrox automatically generates code for resource bindings. This is made specifically to prevent
subtle mistakes. For example, when you define this set of resources:</p>
<pre><code class="language-ron">(
    name: "MyShader",
    resources: [
        (
            name: "diffuseTexture",
            kind: Texture(kind: Sampler2D, fallback: White),
            binding: 0
        ),
        (
            name: "normalTexture",
            kind: Texture(kind: Sampler2D, fallback: Normal),
            binding: 1
        ),
        (
            name: "properties",
            kind: PropertyGroup([
                (
                    name: "texCoordScale",
                    kind: Vector2((1.0, 1.0)),
                ),
                (
                    name: "diffuseColor",
                    kind: Color(r: 255, g: 255, b: 255, a: 255),
                ),
            ]),
            binding: 0
        ),
    ]
)
</code></pre>
<p>The engine generates the following code and adds it to source code of every shader in every render pass
automatically:</p>
<pre><code class="language-glsl">uniform sampler2D diffuseTexture;
uniform sampler2D normalTexture;
struct Tproperties {
    vec2 texCoordScale;
    vec4 diffuseColor;
};
layout(std140) uniform Uproperties { Tproperties properties; }
</code></pre>
<p>The most important thing is that the engine keeps properties in the <code>struct Tproperties</code> in
correct order and forces <code>std140</code> layout on the generated uniform block. Since the engine knows
the layout of the properties from their definition section, it could easily form a memory block
with all required alignments and paddings that could be uploaded to GPU. The next important thing
is that the engine batches all the data needed into large chunks of data and uploads them
all at once, which is much faster.</p>
<h2 id="drawing-parameters"><a class="header" href="#drawing-parameters">Drawing parameters</a></h2>
<p>Drawing parameters defines which GPU functions to use and at which state. For example, to render transparent
objects, you need to enable blending with specific blending rules. Or you need to disable culling to draw objects
from both sides. This is when draw parameters come in handy.</p>
<p>There is a relatively large list of drawing parameters, and it could confuse a person who didn't get
used to work with graphics. The following list should help you to use drawing parameters correctly.</p>
<ul>
<li><code>cull_face</code>:
<ul>
<li>Defines which side of polygon should be culled.</li>
<li><strong>Possible values:</strong> <code>None</code>, <code>Some(CullFace::Back)</code>, <code>Some(CullFace::Front)</code></li>
</ul>
</li>
<li><code>color_write</code>:
<ul>
<li>Defines which components of color should be written to a render target</li>
<li><strong>Possible values:</strong> <code>ColorMask { .. }</code></li>
</ul>
</li>
<li><code>depth_write</code>:
<ul>
<li>Whether to modify depth buffer or not.</li>
<li><strong>Possible values:</strong> <code>true/false</code></li>
</ul>
</li>
<li><code>stencil_test</code>:
<ul>
<li>Whether to use stencil test or not.</li>
<li><strong>Possible values:</strong>
<ul>
<li><code>None</code></li>
<li><code>Some(StencilFunc { .. })</code></li>
</ul>
</li>
</ul>
</li>
<li><code>depth_test</code>:
<ul>
<li>Whether to perform depth test when drawing.</li>
<li><strong>Possible values:</strong> <code>true/false</code></li>
</ul>
</li>
<li><code>blend</code>:
<ul>
<li>Blending options.</li>
<li><strong>Possible values:</strong>
<ul>
<li><code>None</code></li>
<li><code>Some(BlendFunc { .. } )</code></li>
</ul>
</li>
</ul>
</li>
<li><code>stencil_op</code>:
<ul>
<li>Stencil options.</li>
<li><strong>Possible values:</strong> <code>StencilOp { .. } </code></li>
</ul>
</li>
<li><code>scissor_box</code>:
<ul>
<li>A rectangle that is used for clipping (screen-space). This value can be redefined when issuing a drawing
command.</li>
<li><code>None</code></li>
<li><code>Some(ScissorBox(x: 10, y: 20, width: 100, height: 30))</code></li>
</ul>
</li>
</ul>
<h2 id="vertex-shader"><a class="header" href="#vertex-shader">Vertex shader</a></h2>
<p>Vertex shader operates on single vertices, it must provide at least the position of the vertex
in clipping space. In other words, it has to do at least this:</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 vertexPosition;

void main()
{
    gl_Position = fyrox_instanceData.worldViewProjection * vertexPosition;
}
</code></pre>
<p>This is the simplest vertex shader, using vertex shaders you can create various graphical effects that affect
vertices.</p>
<h2 id="pixel-shader"><a class="header" href="#pixel-shader">Pixel Shader</a></h2>
<p>Pixel shader (or more precisely - fragment shader), operates on a small fragment of your render target. In general,
pixel shaders write some color to a render target (or multiple targets) using some program.</p>
<pre><code class="language-glsl">out vec4 FragColor;

void main()
{
    FragColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>This is the simplest pixel shader, it just fills the render target with red color.</p>
<h2 id="compute-shaders"><a class="header" href="#compute-shaders">Compute Shaders</a></h2>
<p>Compute shaders aren't supported yet due to the platform limitations (WebGL2 on WebAssembly). However,
if you don't need to support such platforms, you can access the underlying graphics API directly and
use compute shaders as you want:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_gl_compute_shader(ctx: &amp;PluginContext) {
    let GraphicsContext::Initialized(initialized_context) = ctx.graphics_context else {
        return;
    };
    let Some(gl_server) = initialized_context
        .renderer
        .server
        .as_any()
        .downcast_ref::&lt;GlGraphicsServer&gt;()
    else {
        return;
    };

    use glow::HasContext;
    unsafe {
        // Create a compute shader program and use it.
        // ...
        gl_server.gl.dispatch_compute(3, 3, 3);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that this code snippet uses OpenGL, but it can be pretty much any GAPI for which the
<code>GraphicsServer</code> trait is implemented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="materials"><a class="header" href="#materials">Materials</a></h1>
<p>Material defines a set of values for a shader. Materials usually contains textures (diffuse, normal, height, emission and other maps), numerical values (floats, integers), vectors, booleans, matrices and arrays of each type, except
textures. Each parameter can be changed in runtime giving you the ability to create animated materials. However,
in practice, most materials are static, this means that once it's created, it won't be changed anymore.</p>
<p>Please keep in mind that the actual "rules" of drawing an entity are stored in the shader,
<strong>material is only a storage</strong> for specific uses of the shader.</p>
<p>Multiple materials can share the same shader, for example standard shader covers 95% of most common use cases,
and it is shared across multiple materials. The only difference are property values, for example you can draw
multiple cubes using the same shader, but with different textures.</p>
<p>Material itself can be shared across multiple places as well as the shader. This gives you the ability to render
multiple objects with the same material efficiently.</p>
<h2 id="performance-11"><a class="header" href="#performance-11">Performance</a></h2>
<p>It is very important re-use materials as much as possible, because the number of materials used per frame
significantly correlates with performance. The more unique materials you have per frame, the more work
the renderer and video driver need in order to render a frame and more time the frame will require for
rendering, thus lowering your FPS.</p>
<h2 id="standard-material"><a class="header" href="#standard-material">Standard material</a></h2>
<p>The engine offers a standard PBR material, PBR stands for "Physically-Based Rendering" which gives you the quality
of shading which is very close to materials in real world (to some extent of course).</p>
<p>The standard material can cover 95% of use cases, and it is suitable for almost any kind of game, except maybe
some cartoon-ish or stylized games.</p>
<p>The standard material has quite a lot of properties that can be used to fully utilize the power of PBR rendering:</p>
<ul>
<li><strong>diffuseColor</strong> - an RGBA color that will be used as a base color for you object. <strong>Caveat:</strong> the opacity value
(alpha) will be used only with <code>Forward</code> render path! This means that you will need to switch render path on your
mesh (<a href="rendering/materials.html#transparency">see below</a>)</li>
<li><strong>diffuseTexture</strong> - a 2D texture containing the unlit "basic" colors of your object, this is the most commonly
used texture. For example, you can assign a brick wall texture to this property and your object will look like a brick
wall.</li>
<li><strong>normalTexture</strong> - a 2D texture containing per-pixel normal vectors.</li>
<li><strong>metallicTexture</strong> - a 2D texture containing per-pixel metallic factor, where 0 - dielectric, 1 - metal.
In simple words it defines whether your object reflects (1.0) the environment or not (0.0).</li>
<li><strong>roughnessTexture</strong> - a 2D texture containing per-pixel roughness factor, where 0 - completely flat, 1 -
very rough.</li>
<li><strong>heightTexture</strong> - a 2D texture containing per-pixel displacement value, it is used with parallax mapping to
crate an effect of volume on a flat surface.</li>
<li><strong>emissionTexture</strong> - a 2D texture containing per-pixel emission lighting. You could use this to create emissive
surfaces like small lamps on wall of sci-fi ship, or to create glowing eyes for your monsters that will scare
the player.</li>
<li><strong>lightmapTexture</strong> - a 2D texture containing per-pixel <strong>static</strong> lighting. It is used to apply precomputed
light to your 3D models, and the most common use case is to lit a static object using a static light. Precomputed
light is very cheap. The engine offers built-in lightmapper that can generate lightmaps for you.</li>
<li><strong>aoTexture</strong> - a 2D texture containing per-pixel shading values, allows you to "bake" shadows in for your 3D
object.</li>
<li><strong>texCoordScale</strong> - a 2D vector that allows you to scale texture coordinates used to sample the textures
mentioned above (except lightmaps, they're using separate texture coordinates)</li>
<li><strong>layerIndex</strong> - a natural number that is used for decals masking, a decal will only be applied to your mesh
if and only if the decal has matching index.</li>
<li><strong>emissionStrength</strong> - a 3D vector that allows you to set the strength of emission per-channel (R, G, B) for
your <code>emissionTexture</code></li>
</ul>
<h2 id="transparency"><a class="header" href="#transparency">Transparency</a></h2>
<p>The standard material offers very basic transparency support, to use it you have to explicitly switch render
path on your mesh object. It could be done in this way:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{mesh::RenderPath, node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn set_forward_render_path(scene: &amp;mut Scene, mesh_handle: Handle&lt;Node&gt;) {
</span>    scene.graph[mesh_handle]
        .as_mesh_mut()
        .set_render_path(RenderPath::Forward);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>After this, your mesh will be rendered using a specialized render pass called Forward which supports alpha-blending
and transparent objects. <strong>Caveat:</strong> Current forward renderer implementation does not support any kind of lighting,
if you need lighting, you will need to use custom shader for that!</p>
<h2 id="material-import"><a class="header" href="#material-import">Material import</a></h2>
<p>When you're loading a 3D model in the engine, the engine tries to convert the materials stored inside to standard
material. In most cases there is no way to create 100% matching material on the fly, instead the engine tries
to do its best to make sure the material will be imported as closely as possible to the original one. Various 3D modelling
tools use different material system, but all of them allow you to export your 3D model in one of the commonly
used formats (such as FBX).</p>
<h3 id="blender"><a class="header" href="#blender">Blender</a></h3>
<p>When using Blender, make sure you are using <strong>Principled BSDF</strong> material, it is the closest material that can be converted
to engine's standard material at almost 100% fidelity.</p>
<h3 id="3ds-max"><a class="header" href="#3ds-max">3Ds max</a></h3>
<p>It highly depends on the version of the 3Ds max, but in general the default material should work fine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-maps"><a class="header" href="#light-maps">Light Maps</a></h1>
<p>Fyrox supports light maps for static lighting, that allows you to pre-compute the lighting, store it into a texture
and use this texture for rendering. This makes lighting very fast to render, but requires additional pre-processing
step and slightly increases memory usage. Light maps are very useful for static lights and static level geometry; they
do not work with dynamic objects and lights. Light maps could be used on mobile devices, to significantly increase
performance. This is how "baked" light looks like:</p>
<p><img src="rendering/example_light_map.png" alt="example light map" /></p>
<p>This is light map for one of the curtains in the scene on screenshot below. As you can see, there are quite a lot of
parts on this texture, this is because the engine generates second texture coordinates for the light map, and sometimes
it cannot generate one big chunk, and it has to add seams. Despite the look of it, the light map is actually tightly
packed, it contains a lot of black pixels because the ambient color is black and not all pixels on it are actually lit.</p>
<h2 id="how-to-generate"><a class="header" href="#how-to-generate">How to generate</a></h2>
<p>There are two major ways of generating a light map: from the editor and from code. Usually, using the editor is preferable,
because you can immediately see the results. Code-based approach could be used if you're making your own tool for light
maps.</p>
<h3 id="from-editor-3"><a class="header" href="#from-editor-3">From editor</a></h3>
<p>You can generate a light map from the editor in just a few clicks, go to <code>View -&gt; Light Panel</code> and the Light Panel should
open:</p>
<p><img src="rendering/lightmap.png" alt="lightmap" /></p>
<p>There's not many settings in this window, but all of them are very important. At first, choose a folder in which the editor
will store the generated light map by clicking <code>...</code> button. The last two parameters are the following:</p>
<ul>
<li>Texels per unit - it defines 'pixels density' per unit of area (square meters). The more the value, the more detailed
the produced light map will be and vice versa. This value <strong>directly</strong> affects performance in quadratic manner, which
means that if you change it from 32 to 64, the time needed to generate the light map won't double, but it will be 4 times
more. Default value is 64 which is a good balance between quality and generation speed.</li>
<li>Spacing - relative spacing between UV elements generated by the built-in UV mapper. The more the value, the more the
distance between the UV elements will be. This parameter is used to prevent seams from occurring, when rendering meshes
with bilinear filtration. Default value is 0.005, which is a good balance between size of the light maps and their quality
(lack of seams).</li>
</ul>
<p>Usually the default values are fine for most cases, but you can tweak them and compare the results. Now you can click
the <code>Generate Light Map</code> button and wait until the light map is fully generated.</p>
<p><img src="rendering/lightmap_gen.png" alt="lightmap generation" /></p>
<p>You can cancel the generation at any time, however in some cases there might be a small delay between cancel request
and the actual generation cancellation. When the generation is done, you should immediately see the result:</p>
<p><img src="rendering/generated_lightmap.png" alt="generated lightmap" /></p>
<p>Now if you save the scene, it will remember the generated light map and will load it automatically for you.</p>
<h3 id="from-code-4"><a class="header" href="#from-code-4">From code</a></h3>
<p>The following example creates a simple scene and generates a light map for it, which is then saved to disk:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_lightmap() {
    // Create a test scene first.
    let mut scene = Scene::new();

    let data = SurfaceData::make_cone(
        16,
        1.0,
        1.0,
        &amp;Matrix4::new_nonuniform_scaling(&amp;Vector3::new(1.0, 1.1, 1.0)),
    );

    MeshBuilder::new(BaseBuilder::new())
        .with_surfaces(vec![SurfaceBuilder::new(SurfaceResource::new_ok(
            ResourceKind::Embedded,
            data,
        ))
        .build()])
        .build(&amp;mut scene.graph);

    PointLightBuilder::new(BaseLightBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 2.0, 0.0))
                .build(),
        ),
    ))
    .with_radius(4.0)
    .build(&amp;mut scene.graph);

    // Prepare the data for generation using the scene.
    let data =
        LightmapInputData::from_scene(&amp;scene, |_, _| true, Default::default(), Default::default())
            .unwrap();

    // Generate the lightmap.
    let lightmap = Lightmap::new(data, 64, 0.005, Default::default(), Default::default()).unwrap();

    // Save each texture to disk.
    let mut counter = 0;
    for entry_set in lightmap.map.values() {
        for entry in entry_set {
            let mut data = entry.texture.as_ref().unwrap().data_ref();
            data.save(Path::new(&amp;format!("{}.png", counter))).unwrap();
            counter += 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-the-lightmap"><a class="header" href="#using-the-lightmap">Using the lightmap</a></h2>
<p>You can ignore this section if you're generated a light map in the editor, because your scene already contains all
required connections to the generated light map, and it will be loaded automatically with the scene. However, if you
need to change the light maps on the fly, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn change_light_map(scene: &amp;mut Scene, resource_manager: ResourceManager) {
    let light_map = fyrox::core::futures::executor::block_on(Lightmap::load(
        "a/path/to/lightmap.lmp",
        resource_manager,
    ))
    .unwrap();

    scene.graph.set_lightmap(light_map).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-3"><a class="header" href="#limitations-3">Limitations</a></h2>
<p>Fyrox uses CPU light map generator, which means that it is quite slow. Light sources that were baked into a light map
will also light up any surface with light map on - this essentially means double lighting. To fix that you need to
disable light sources that were baked into the light map explicitly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings-1"><a class="header" href="#settings-1">Settings</a></h1>
<p>Renderer has a large set of settings, that allows you to tweak graphics quality to find optimal balance between
rendering quality and performance. Quality settings are represented by the following structure:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::renderer::{CsmSettings, ShadowMapPrecision};
</span>struct QualitySettings {
    point_shadow_map_size: usize,
    point_soft_shadows: bool,
    point_shadows_enabled: bool,
    point_shadows_distance: f32,
    point_shadow_map_precision: ShadowMapPrecision,
    spot_shadow_map_size: usize,
    spot_soft_shadows: bool,
    spot_shadows_enabled: bool,
    spot_shadows_distance: f32,
    spot_shadow_map_precision: ShadowMapPrecision,
    csm_settings: CsmSettings,
    use_ssao: bool,
    ssao_radius: f32,
    light_scatter_enabled: bool,
    fxaa: bool,
    use_parallax_mapping: bool,
    use_bloom: bool,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>point_shadow_map_size</code> - size of a cube map face of shadow map texture (in pixels). The higher, the better quality,
but lower performance. Typical values for medium GPU (GTX 1050) is 1024 pixels.</li>
<li><code>point_soft_shadows</code> - should the shadows from point lights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
<li><code>point_shadows_enabled</code> - are the shadows from point lights enabled?</li>
<li><code>point_shadows_distance</code> - maximal distance from a camera to draw point light shadows. It is used to disable shadows
on distant lights. The distance is given in meters. The lower the value, the better performance is.</li>
<li><code>point_shadow_map_precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels. Lower bit depth means better
performance and lower quality.</li>
<li><code>spot_shadow_map_size</code> - size of a shadow map texture for spotlights. The higher, the better quality,
but lower performance. Typical values for medium GPU (GTX 1050) is 1024 pixels.</li>
<li><code>spot_soft_shadows</code> - should the shadows from spotlights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
<li><code>spot_shadows_enabled</code> - are the shadows from spotlights enabled?</li>
<li><code>spot_shadows_distance</code> - maximal distance from a camera to draw spotlight shadows. It is used to disable shadows
on distant lights. The distance is given in meters. The lower the value, the better performance is.</li>
<li><code>spot_shadow_map_precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels.  Lower bit depth means better
performance and lower quality.</li>
<li><code>csm_settings</code> - settings for cascaded shadow maps for directional lights.
<ul>
<li><code>enabled</code> - whether cascaded shadow maps enabled or not.</li>
<li><code>size</code> - size of texture for each cascade.</li>
<li><code>precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels. Lower bit depth means better
performance and lower quality.</li>
<li><code>pcf</code> - should the shadows from directional lights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
</ul>
</li>
<li><code>use_ssao</code> - defines whether the renderer should perform separate screen-space ambient occlusion pass. This option
has relatively small performance impact.</li>
<li><code>ssao_radius</code> - radius of sampling hemisphere used in SSAO, it defines much ambient occlusion will be in your scene.
has no performance impact.</li>
<li><code>light_scatter_enabled</code> - global switch to enable or disable light scattering. Each light have its own scatter switch,
but this one is able to globally disable scatter. Light scattering has medium performance impact, it also depends on
light count in your scene.</li>
<li><code>fxaa</code> - is full-screen anti-aliasing needed? This option has low performance impact.</li>
<li><code>use_parallax_mapping</code> - defines whether the renderer should use parallax mapping to simulate bumps and dents on
flat surfaces using special textures. This option has low performance impact.</li>
<li><code>use_bloom</code> - defines whether the renderer should draw glowing pixels. This option has low performance impact.</li>
</ul>
<h2 id="presets"><a class="header" href="#presets">Presets</a></h2>
<p>The renderer offers built-in presets for various graphics quality, use <code>QualitySettings::ultra()</code>,
<code>QualitySettings::high()</code>, <code>QualitySettings::medium()</code> and <code>QualitySettings::low()</code> presets to quickly tune
quality-performance balance.</p>
<h2 id="how-to-apply"><a class="header" href="#how-to-apply">How to apply</a></h2>
<p>To apply the settings, use <code>Renderer::set_quality_settings</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::log::Log, engine::GraphicsContext, plugin::PluginContext, renderer::QualitySettings,
</span><span class="boring">};
</span><span class="boring">
</span>fn set_quality_settings(context: &amp;mut PluginContext) {
    // Keep in mind, that graphics context can be non-initialized. This could happen if you're trying to access it before
    // your game received `Event::Resumed` event.
    if let GraphicsContext::Initialized(ref mut graphics_context) = context.graphics_context {
        let mut settings = QualitySettings::high();

        // Disable something.
        settings.use_ssao = false;
        settings.fxaa = false;

        // Apply.
        Log::verify(graphics_context.renderer.set_quality_settings(&amp;settings))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that graphics context can be non-initialized. This could happen if you're trying to access it before your
game received <code>Event::Resumed</code> event. See the docs for <a href="https://docs.rs/fyrox/latest/fyrox/event/enum.Event.html#variant.Resumed">Event::Resumed</a>
for more info. There is only one place, where graphics context is guaranteed to be initialized -
<code>Plugin::on_graphics_context_initialized</code> method. Inside it, you can access the renderer by simple:
<code>context.graphics_context.as_initialized_mut().renderer</code>, in other places you should always do a checked borrow.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-pass-1"><a class="header" href="#render-pass-1">Render Pass</a></h1>
<p>You can define your own render passes that extends the renderer, currently there are render passes only for scenes,
so no custom post-effects (this is planned to be improved in Fyrox 0.28). Render pass has full access to graphics
framework (which is a thin wrapper around OpenGL) so it can utilize full power of it to implement various graphical
effects.</p>
<h2 id="creating-a-render-pass"><a class="header" href="#creating-a-render-pass">Creating a render pass</a></h2>
<p>Render pass is a complex thing, that requires relatively deep knowledge in computer graphics. It is intended to be used
by experienced graphics programmers. Here's the simplest render pass that renders unit quad without any textures.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyRenderPass {
    enabled: bool,
    shader: Box&lt;dyn GpuProgram&gt;,
    target_scene: Handle&lt;Scene&gt;,
    quad: Box&lt;dyn GeometryBuffer&gt;,
    uniform_location: usize,
    uniform_buffer: Box&lt;dyn Buffer&gt;,
}

impl MyRenderPass {
    pub fn new(
        renderer: &amp;mut Renderer,
        target_scene: Handle&lt;Scene&gt;,
    ) -&gt; Result&lt;Self, FrameworkError&gt; {
        let vs = r"
                layout(location = 0) in vec3 vertexPosition;

                layout(std140) uniform Uniforms {
                    mat4 worldViewProjectionMatrix;
                }                
                         
                void main()
                {
                    gl_Position = worldViewProjectionMatrix * vertexPosition;
                }
            ";

        let fs = r"                
                out vec4 FragColor;             
                
                void main()
                {
                    FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                }
            ";

        let shader = renderer.server.create_program("MyShader", vs, fs)?;
        let uniform_buffer =
            renderer
                .server
                .create_buffer(256, BufferKind::Uniform, BufferUsage::DynamicDraw)?;

        uniform_buffer.write_data_of_type(
            &amp;StaticUniformBuffer::&lt;256&gt;::new()
                .with(&amp;Matrix4::identity())
                .finish(),
        )?;

        Ok(Self {
            enabled: true,
            uniform_location: shader.uniform_block_index(&amp;"Uniforms".into())?,
            uniform_buffer,
            target_scene,
            quad: &lt;dyn GeometryBuffer as GeometryBufferExt&gt;::from_surface_data(
                &amp;SurfaceData::make_quad(&amp;Matrix4::identity()),
                BufferUsage::StaticDraw,
                renderer.server.as_ref(),
            )?,
            shader,
        })
    }
}

impl SceneRenderPass for MyRenderPass {
    fn on_ldr_render(
        &amp;mut self,
        ctx: SceneRenderPassContext,
    ) -&gt; Result&lt;RenderPassStatistics, FrameworkError&gt; {
        let mut stats = RenderPassStatistics::default();

        // Make sure to render only to target scene.
        if self.enabled &amp;&amp; ctx.scene_handle == self.target_scene {
            let resources = ResourceBindGroup {
                bindings: &amp;[ResourceBinding::Buffer {
                    buffer: self.uniform_buffer.as_ref(),
                    binding: BufferLocation::Auto {
                        shader_location: self.uniform_location,
                    },
                    data_usage: BufferDataUsage::default(),
                }],
            };
            stats += ctx.framebuffer.draw(
                self.quad.as_ref(),
                ctx.viewport,
                self.shader.as_ref(),
                &amp;DrawParameters::default(),
                &amp;[resources],
                ElementRange::Full,
            )?;
        }

        Ok(stats)
    }

    fn source_type_id(&amp;self) -&gt; TypeId {
        ().type_id()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The code snippet shows how to create a shader, find its uniforms, and finally how to actually render something in
target frame buffer.</p>
<h2 id="registering-a-render-pass"><a class="header" href="#registering-a-render-pass">Registering a render pass</a></h2>
<p>Every render pass must be registered in the renderer, otherwise it won't be used. You can register a render pass using
<code>add_render_pass</code> method of the <code>Renderer</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn usage_example(renderer: &amp;mut Renderer, render_pass: MyRenderPass) {
    let shared_pass = Rc::new(RefCell::new(render_pass));
    // You can share the pass across multiple places to be able to control it.
    renderer.add_render_pass(shared_pass);
}
<span class="boring">}</span></code></pre></pre>
<p>Please notice that we've wrapped render pass in <code>Rc&lt;RefCell&lt;..&gt;&gt;</code>, this means that you can share it across multiple places
and modify its data from the code of your game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="normal-maps"><a class="header" href="#normal-maps">Normal Maps</a></h1>
<p>This chapter explains how to use normal maps in the engine correctly and how to solve common issues with normal maps as
well.</p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>Fyrox uses so-called <code>DirectX Y-</code> normal maps, which means that it expects the origin of local coordinate system of a
normal map to be at the left-top corner of the map, instead of <code>OpenGL Y+</code> normal maps where the origin is at the
left-bottom corner of the map. <code>DirectX Y-</code> normal maps are much more prevalent nowadays, especially when it comes to
game-ready 3D models. Some software (like Substance Painter), by default has exporting settings to be set to <code>DirectX Y-</code>
style normal maps.</p>
<p>The difference between the two is quite obvious if you look at the lighting with both normal maps:</p>
<p><img src="rendering/normal_map_difference.png" alt="difference" /></p>
<p>The left one is <code>DirectX Y-</code> and the right one is <code>OpenGL Y+</code>. As you can see, the left one looks correctly - the
screw head is convex as in reality and the lighting is also correct. On the other side, however, the screw head look to
be concave and the lighting is opposite.</p>
<h2 id="solving-issues"><a class="header" href="#solving-issues">Solving Issues</a></h2>
<p>If you have these sort of issues in your project, all you need to do is to flip (<code>G = 1 - G</code>) green channel of you
normal map. For now, this should be done manually in some pictures editor, future versions of the engine will have a
switch to flip green channel for you automatically.</p>
<p>A simple trick of how to understand which type of normal map you have: look at any obvious bump (convex part) on the normal
map, if its top contains green-ish colors then you have <code>OpenGL Y+</code> normal maps and its green channel should be flipped:</p>
<p><img src="rendering/normal_map_y_difference.png" alt="y difference" /></p>
<p>On the image above, the screw head (in the red circle) is an obviously convex and on the left side you can see, that
the green-ish colors is at the bottom, while on the right side green-ish colors is at the top. You could also check the
lighting results on your 3D model and see if they're correct (looks the same as in the 3D modelling software, for
instance) while moving a light source around.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics-server"><a class="header" href="#graphics-server">Graphics Server</a></h1>
<p>Graphics server is an abstraction that hides low-level graphics API (such as DirectX, OpenGL, Vulkan, etc.)
calls under a higher level interface that consists of a number of "building blocks" that allows you to
render computer graphics in an easier way.</p>
<h2 id="opengl-graphics-server"><a class="header" href="#opengl-graphics-server">OpenGL Graphics Server</a></h2>
<p>The default graphics server is the OpenGL-based one (<code>GlGraphicsServer</code>). Why using a deprecated API in the
modern world? The answer is simple: OpenGL is wide-spread, runs on pretty much all mainstream platforms
(except consoles). Fyrox has a small developers team, which can't maintain a number of different GAPIs for
different platforms. Foreseeing the next potential question - why not just use wgpu? The answer is again
simple: legacy. Fyrox is a relatively old game engine (compared to the entire Rust ecosystem, of course)
and when its development was started, there was no such thing as wgpu. Transition to it nowadays is a
challenging task, since the renderer of the engine is quite big. Anyway, the engine is still evolving and
more support for other GAPIs will be added in the future.</p>
<h2 id="custom-graphics-server"><a class="header" href="#custom-graphics-server">Custom Graphics Server</a></h2>
<p>It is possible to write a graphics server with pretty much any API, since a graphics server
(<code>GraphicsServer</code> trait) has quite a small number of functions. If you're familiar with other GAPIs, then
it should be relatively straightforward for you to implement your own server.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<p>Typical use of the graphics server is shown extensively in the <a href="rendering/render_pass.html">render pass section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics-debugging-and-profiling"><a class="header" href="#graphics-debugging-and-profiling">Graphics Debugging and Profiling</a></h1>
<p>Fyrox does not have any special tools for graphics debugging and profiling yet, such tools are planned for Fyrox 2.0.
For now, you can use third-party tools for this, such as <a href="https://renderdoc.org/">RenderDoc</a>,
<a href="https://developer.nvidia.com/nsight-systems">NVIDIA Nsight</a>, <a href="https://gpuopen.com/rgp/">AMD Radeon GPU Profiler</a>, etc.</p>
<h2 id="names-for-graphics-entities"><a class="header" href="#names-for-graphics-entities">Names for Graphics Entities</a></h2>
<p>The engine has an ability to assign meaningful names for entities of underlying graphical API for the ease of
debugging.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    let executor = Executor::from_params(
        EventLoop::new().ok(),
        GraphicsContextParams {
            // This option forces the engine to use meaningful names for
            // GPU objects (textures, buffers, shaders, etc.)
            named_objects: true,
            window_attributes: WindowAttributes::default(),
            vsync: true,
            msaa_sample_count: None,
            graphics_server_constructor: Default::default(),
        },
    );
    // ...
}</code></pre></pre>
<p>Recompile your game and run a graphics debugger (RenderDoc, for instance) and you should see that now GPU entities
have meaningful names:</p>
<p><img src="rendering/capture.png" alt="capture" /></p>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<p>Accurate GPU profiling is a hard task, because GPUs work independently of CPUs and any attempt to measure how
much time is spent on GPU from the CPU side will only measure how much time was spent to prepare and issue
commands for a GPU. That being said, profiling requires specialized tools for target GPUs. Use<br />
<a href="https://developer.nvidia.com/nsight-systems">NVIDIA Nsight</a> or <a href="https://gpuopen.com/rgp/">AMD Radeon GPU Profiler</a>,
depending on the GPU you're using. <a href="https://renderdoc.org/">RenderDoc</a> also has <em>some</em> ability to measure
GPU times, but its precision is not very high.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-management-2"><a class="header" href="#asset-management-2">Asset Management</a></h1>
<p>This chapter covers asset management in the engine. Asset management is performed by <code>Asset Browser</code> in the editor
and by <code>ResourceManager</code> from API.</p>
<h2 id="general-info"><a class="header" href="#general-info">General Info</a></h2>
<p>Assets loading is asynchronous, it is possible to load multiple assets in parallel or load until a specific asset is
loaded.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>It is strongly advised to specify all resources used by your game entities inside your scripts, instead of requesting
resources directly from the resource manager on demand. This approach solves two common issues:</p>
<ol>
<li>It allows you to set resources directly from the editor by a simple drag'n'drop from the Asset Browser.</li>
<li>The engine will be able to wait until all resources used by a scene are fully loaded. This is especially important,
because this way can guarantee, that scene loading will be "seamless" and if the scene was loaded, it means that all
resources used by it are loaded too.</li>
</ol>
<p>This can be achieved by adding a respective field in your script. For example, you may a have a weapon script that
shoots some projectiles. In this case all you need to add a <code>projectile: Option&lt;ModelResource&gt;</code> field in your script,
assign it to some prefab in the editor and then <a href="resources/model.html#instantiation">instantiate</a> it from code when shooting.
Storing
resource handle directly in your script helps the engine to gather all resources used by parent scene and preload them
too while loading the scene itself. Such approach prevent lags when doing actual shooting, which is especially important
if you're targeting a WebAssembly platform. On WebAssembly all the files accessed over network API which could work with
unstable connection. In any case, even on PC it helps a lot.</p>
<p>Requesting resources on demand could be useful in limited situations:</p>
<ol>
<li>You're loading a new game level - in this case it is perfectly fine to request the resource manually.</li>
<li>You're doing some background work (level streaming for instance).</li>
</ol>
<h2 id="asset-browser"><a class="header" href="#asset-browser">Asset Browser</a></h2>
<p>Asset browser allows you to preview your assets and edit their import properties. It looks something like this (keep
in mind that the screenshot could be outdated).</p>
<p><img src="resources/asset_browser.png" alt="Asset Browser" /></p>
<p>There are three main areas in it:</p>
<ol>
<li>Left directory tree - shows all <em>directories</em> starting from project root. It does <em>not</em> show any files, this is
for what the center section is.</li>
<li>Center asset previewer - shows all assets from selected directory. The path at the top of the section shows asset
path.</li>
<li>Right asset import options inspector - it shows import properties of selected asset.</li>
</ol>
<p>Typical workflow could look like this:</p>
<ol>
<li>Select desired directory from the left tree</li>
<li>Select desired asset in the center previewer</li>
<li>Edit import properties of selected asset and click "Apply" button to save import options and re-load the asset with
new options.</li>
</ol>
<p>Alternatively, you can just type in the name of some resource you're looking for in the search bar at the top of the
Asset Browser.</p>
<p>Check next chapters to learn how to manage specific asset types and what their import does what.</p>
<h2 id="api-docs"><a class="header" href="#api-docs">API Docs</a></h2>
<p>Please read API docs <a href="https://docs.rs/fyrox/latest/fyrox/asset/manager/struct.ResourceManager.html">here</a></p>
<h2 id="internal-state-and-access-to-data"><a class="header" href="#internal-state-and-access-to-data">Internal State and Access to Data</a></h2>
<p>Resource itself is a small state machine that is used in asynchronous loading. When you've requested a resource from
a resource manager, at first it looks for loaded instance and if it is found - shares a handle to the resource with you.
If there's no such resource, it creates a new instance with <code>Pending</code> state and immediately returns it to you.
All pending resources are placed in some sort of queue which is then processed by a set of worker threads that does
the loading. When a worker thread finished loading of a resource, it marks the resource either as <code>Ok</code> or <code>LoadError</code>,
depending on whether the loading was successful or not respectively. This process makes access to the data more
convoluted.</p>
<p>In simple cases when you don't need the data immediately after request, you can use checked access to resource data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn checked_access(texture_resource: &amp;Resource&lt;Texture&gt;) {
    let mut state = texture_resource.state();
    if let Some(texture) = state.data() {
        println!("Kind: {:?}", texture.kind());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is relatively cheap, it tries to block a mutex and checks the actual state of the resource. If it is loaded,
the reference is returned to you. In some cases you know for sure that a resource is loaded and its data can be
obtained like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn unchecked_access(texture_resource: &amp;Resource&lt;Texture&gt;) {
    let texture = texture_resource.data_ref();
    println!("Kind: {:?}", texture.kind());
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind that <code>data_ref</code> call will panic if the resource isn't loaded. Try to avoid using this method everywhere,
especially if you aren't sure about the state of the resource. Never use it in combination with <code>request</code> method of
resource manager, because it most likely will panic randomly, because of async loading.</p>
<p>Every resource implements <code>Future</code> trait and can be awaited in async functions and multiple resources could be
awaited simultaneously:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn await_resource(texture_resource: Resource&lt;Texture&gt;) {
    if let Ok(result) = texture_resource.await {
        // `data_ref` will never panic after the above check.
        let texture = result.data_ref();
        println!("Kind: {:?}", texture.kind());
    };
}
<span class="boring">}</span></code></pre></pre>
<p>When the data is needed right after the <code>request</code> call, you need to block current thread until the resources is fully
loaded. Depending on the platform, you can use <code>futures::block_on</code> to block current thread in-place and get the resource
data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn block_and_wait(texture_resource: Resource&lt;Texture&gt;) {
    // Block the current thread and wait until the resource is loaded.
    if let Ok(result) = futures::executor::block_on(texture_resource) {
        // `data_ref` will never panic after the above check.
        let texture = result.data_ref();
        println!("Kind: {:?}", texture.kind());
    };
}
<span class="boring">}</span></code></pre></pre>
<p>This approach has its disadvantages, the most notable one is lack of proper support on WebAssembly. In short:
main thread cannot be blocked in JS to let any background tasks to finish because of micro-task system which
works in the same thread. All of this complicates even more because of async nature of resource loading in JS.
Internally Fyrox relies on <code>fetch</code> API, which is async by design and non-blocking. All these problems could be
avoided by embedding resources directly in the binary of your game using <code>include_bytes!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn embedded_resource() -&gt; Option&lt;Resource&lt;Texture&gt;&gt; {
    let data = include_bytes!("texture.png");
    TextureResource::load_from_memory(
        Default::default(),
        data,
        TextureImportOptions::default()
            .with_compression(CompressionOptions::NoCompression)
            .with_minification_filter(TextureMinificationFilter::Linear),
    )
    .ok()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-resources"><a class="header" href="#model-resources">Model resources</a></h1>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported formats</a></h2>
<p>Fyrox supports these file formats for 3D models:</p>
<ul>
<li>FBX - standard game development industry 3D model exchange format</li>
<li>RGS - native scenes format produced by Fyroxed (the editor)</li>
</ul>
<p>The list could be extended in the future.</p>
<h2 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h2>
<p>Model must be instantiated in your scene, there is no other way of using it. To do this, you can either use drag'n'drop
from Asset Browser in the editor or instantiate the model dynamically from code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn instantiate_model(
    path: &amp;Path,
    resource_manager: ResourceManager,
    scene: &amp;mut Scene,
) -&gt; Handle&lt;Node&gt; {
    // Load model first. Alternatively, you can store resource handle somewhere and use it for
    // instantiation.
    let model = resource_manager.request::&lt;Model&gt;(path).await.unwrap();

    model.instantiate(scene)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="material-import-1"><a class="header" href="#material-import-1">Material import</a></h2>
<p>The engine tries to import materials as close as possible to originals in the model, however it is not always possible
because some 3D modelling software could use different shading models. By default, the engine tries to convert
everything to PBR materials, so if you have a 3D model with a special material made for cartoon shading, the
engine will still import it as PBR material (with lots of missing textures of course). You should take this into
account when working with something other than PBR materials.</p>
<p>In cases when your 3D model have some weird materials, you should create appropriate materials and shaders <em>manually</em>,
the engine is not a magic tool, it has some defaults that do not cover all possible cases.</p>
<p>It is also possible to specify how to resolve textures while loading a 3D model, select your model in the <code>Asset Browser</code>
and there will be import options right below the model preview:</p>
<p><img src="resources/model_import.png" alt="model import" /></p>
<p>It is also possible to specify such options manually. To do that, you need to create import options file with the
following content near your 3D model (this is what the editor does for you):</p>
<pre><code class="language-text">(
    material_search_options: RecursiveUp
)
</code></pre>
<p>The file must have the <code>.options</code> additional extension. For example, if you have a <code>foo.fbx</code> model, the options
file should have <code>foo.fbx.options</code> name. Even if it is possible to modify it by hand, it is strongly advised to use
the editor to edit import options, because it reduces the chance of messing up.</p>
<h2 id="tips-for-blender"><a class="header" href="#tips-for-blender">Tips for Blender</a></h2>
<p>Blender's FBX exporter has exporting scale properties usually set to 100%, this may lead to incorrect scale
of your model in the engine. It will have <code>(100.0, 100.0, 100.0)</code> scale which is very huge. To fix that, set
the scale in the exporter to <code>0.01</code>.</p>
<h2 id="tips-for-3ds-max"><a class="header" href="#tips-for-3ds-max">Tips for 3Ds Max</a></h2>
<p>Latest versions of 3Ds max have node-based material editor which creates some "junk" nodes which may mess up
material import. To prevent any issues with that, you should clean all assignments to material slots to use
maps directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textures-1"><a class="header" href="#textures-1">Textures</a></h1>
<p>Texture is an image that is used to fill faces to add details to them. In most cases textures are just 2D images, however
there are some exclusions to that - for example cube maps, that may be used for environment mapping. Fyrox supports 1D,
2D, 3D and Cube textures.</p>
<h2 id="supported-formats-1"><a class="header" href="#supported-formats-1">Supported formats</a></h2>
<p>To load images and decode them, Fyrox uses image and ddsfile crates. Here is the list of supported formats: png,
tga, bmp, dds, jpg, gif, tiff, dds.</p>
<h2 id="compressed-textures"><a class="header" href="#compressed-textures">Compressed textures</a></h2>
<p>Fyrox supports most commonly used formats of compressed textures: DXT1, DXT3, DXT5. Such textures can be loaded
only from <code>DDS</code> files. You can specify on-demand texture compression in import options (see below), it works for every
texture format except DDS. It is meant to be used when you don't want to bother with DDS format, there are two
compression methods:</p>
<ul>
<li><code>Quality</code> - has 4:1 compression ratio, supports full 8-bit alpha channel. Textures with gradients will most likely
suffer from noticeable banding.</li>
<li><code>Speed</code> - has lower quality compared to <code>Quality</code> mode, but it has 8:1 compression ratio for texture without alpha
channel and 6:1 with alpha channel. Keep in mind, that alpha channel in this mode supports only 1 bit - it is either
enabled or not.</li>
</ul>
<p>Compressed textures usually does not support color gradient very well, if you have a texture with a lot of colors and
gradients, then you'll most likely get compressed texture with lots of graphical artifacts such as banding.</p>
<p>It is also worth mentioning, that you should <strong>never</strong> use compression with normal maps, it can significantly distort
normals because normal maps usually have lots of color gradients.</p>
<h2 id="import-options"><a class="header" href="#import-options">Import options</a></h2>
<p>It is possible to define custom import options. Using import options you could set desired compression quality,
filtering, wrapping, etc. Import options should be defined using Asset Browser in the editor:</p>
<p><img src="resources/texture_import.png" alt="texture import" /></p>
<p>It is also possible to define import options manually in a separate file with the same name as the source
texture, but with additional extension <code>options</code>, this is what the editor does for you. For example, you have a
<code>foo.jpg</code> texture, a file with import options should be called <code>foo.jpg.options</code>. Its content may look something like
this:</p>
<pre><code class="language-text">(
    minification_filter: Linear,
    magnification_filter: Linear,
    s_wrap_mode: Repeat,
    t_wrap_mode: ClampToEdge,
    anisotropy: 8.0,
    compression: NoCompression,    
)
</code></pre>
<p>Even if it is possible to modify it by hand, it is strongly advised to use the editor to edit import options, because
it reduces chances of messing up.</p>
<h2 id="render-target"><a class="header" href="#render-target">Render target</a></h2>
<p>Texture can be used as a render target to render a scene in it. To do this you should use <code>new_render_target</code> method and
pass its result to scene's render target property. Renderer will automatically provide you info about metrics of
texture, but it won't give you access to pixels of render target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-buffer"><a class="header" href="#sound-buffer">Sound Buffer</a></h1>
<p>Sound sources uses dedicated resource type to store the actual waveform they play. Sound buffer could be
loaded from a few supported formats: WAV, OGG.</p>
<h2 id="how-to-load"><a class="header" href="#how-to-load">How to Load</a></h2>
<p>Sound buffers could be loaded using standard resource manager methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_sound_node(resource_manager: &amp;ResourceManager) -&gt; SoundBufferResource {
    resource_manager.request::&lt;SoundBuffer&gt;("/path/to/resource.ogg")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="streaming"><a class="header" href="#streaming">Streaming</a></h2>
<p>In order to stream large audio files, instead of loading them entirely in memory, the simplest strategy is to create a
corresponding <code>.options</code> file near the source file, with the following content:</p>
<pre><code class="language-json">(
  stream: true
)
</code></pre>
<p>Keep in mind, that sound buffers that uses streaming <strong>cannot</strong> be shared across multiple sound sources.
Streaming should only be used in unique, large sound source, such as game music.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-resources"><a class="header" href="#custom-resources">Custom Resources</a></h1>
<p>In Fyrox, you can create your own, custom resource type that can be embedded in the standard resource management pipeline.
It could be useful to access specific data using engine's resource manager. Custom resources has a few major advantages
over manual resource management via direct files access:</p>
<ol>
<li>Since Fyrox resource system is asynchronous, your resource can be loaded in separate worker thread which speeds up
loading (since it may run on a separate CPU core).</li>
<li>You can access your resources from the Asset Browser and assign their handles to scripts directly from the editor.</li>
<li>File access for resource management has an abstraction, that unifies the access over all supported platforms. This
means that you don't need to use <code>fetch</code> API directly, if you're targeting WebAssembly platform, or use <code>AssetManager</code>
on Android.</li>
</ol>
<p>To create a custom resource, you need to do three major steps:</p>
<ol>
<li>Define your resource structure with all required traits implemented.</li>
<li>Add a custom resource loader, that will be used by the resource manager to load your custom resource.</li>
<li>Register the resource loader in the resource manager.</li>
</ol>
<p>See the code snippet in the next section as a guide.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Custom resource is just an ordinary struct with some data. It must implement <code>Debug</code>, <code>Reflect</code>, <code>Visit</code>, <code>ResourceData</code>
traits. Also, it must contain at least path to external file with the content. Here's the simplest custom resource, that
contains some string data.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Debug, Visit, Reflect, TypeUuidProvider)]
// Every resource must provide a unique identifier, that is used for dynamic type
// casting, serialization, etc.
#[type_uuid(id = "15551157-651b-4f1d-a5fb-6874fbfe8637")]
struct CustomResource {
    // You resource must store the path.
    path: PathBuf,
    some_data: String,
}

impl ResourceData for CustomResource {
    fn type_uuid(&amp;self) -&gt; Uuid {
        &lt;Self as TypeUuidProvider&gt;::type_uuid()
    }

    fn save(&amp;mut self, path: &amp;Path) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        Ok(())
    }

    fn can_be_saved(&amp;self) -&gt; bool {
        true
    }
}

struct CustomResourceLoader;

impl ResourceLoader for CustomResourceLoader {
    fn extensions(&amp;self) -&gt; &amp;[&amp;str] {
        // An array of extensions, supported by this loader. There could be any number of extensions
        // since sometimes multiple extensions map to a single resource (for instance, jpg, png, bmp, are
        // all images).
        &amp;["my_resource"]
    }

    fn data_type_uuid(&amp;self) -&gt; Uuid {
        &lt;CustomResource as TypeUuidProvider&gt;::type_uuid()
    }

    fn load(&amp;self, path: PathBuf, io: Arc&lt;dyn ResourceIo&gt;) -&gt; BoxedLoaderFuture {
        Box::pin(async move {
            match io.load_file(&amp;path).await {
                Ok(content) =&gt; {
                    let my_resource = CustomResource {
                        path,
                        some_data: String::from_utf8(content).unwrap(),
                    };

                    Ok(LoaderPayload::new(my_resource))
                }
                Err(err) =&gt; Err(LoadError::new("Failed to load resource")),
            }
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that you must provide <strong>unique</strong> UUID for every resource type that you're creating. Otherwise, using
existing id multiple times will cause incorrect serialization and type casting. The next step is to register the new
resource in the resource manager. This can be done by adding the following code to the <code>register</code> method for
<code>impl PluginConstructor for GameConstructor</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct MyGame {}

impl Plugin for MyGame {
    fn register(&amp;self, context: PluginRegistrationContext) {
        context
            .resource_manager
            .state()
            .loaders
            .set(CustomResourceLoader);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>After doing so, any attempt to load a resource with <code>my_resource</code> extension will call the <code>load</code> method of your
resource loader.</p>
<h2 id="editor-support-1"><a class="header" href="#editor-support-1">Editor Support</a></h2>
<p>There's one more step before your custom resource is fully usable - you need to register a property editor for it, so
any fields in your scripts that has <code>my_resource: Option&lt;Resource&lt;CustomResource&gt;&gt;</code> fields can be editable in the editor.
Otherwise, you'll see an error message in the Inspector instead of resource selector field. To register a property editor,
add the following lines to <code>editor/src/main.rs</code> file, somewhere after the editor instance is created:</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    // Your editor initialization stuff.
    let editor = Editor::new(None);

    // Register property editor.
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .insert(
            ResourceFieldPropertyEditorDefinition::&lt;CustomResource&gt;::new(
                editor.message_sender.clone(),
            ),
        );

    // ...
}</code></pre></pre>
<p>After this, the editor will create this property editor for <code>my_resource</code> field and will allow you to set its value by
drag'n'dropping an asset from the Asset Browser.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-hot-reloading"><a class="header" href="#asset-hot-reloading">Asset Hot Reloading</a></h1>
<p>Fyrox supports asset hot reloading for most of the supported asset types. Hot reloading is a very useful feature that
allows you to reload assets from disk when they're changing. For example, you can change a texture, save it and the
engine will automatically reload it and the changes will reflect in the game (and the editor). This section of the book
explains how asset hot reloading works for specific asset types and what to expect from it.</p>
<h2 id="textures-2"><a class="header" href="#textures-2">Textures</a></h2>
<p>Content of textures will be automatically reloaded when their source files are changed. Textures loading is usually quite
fast and even large number of changed textures shouldn't cause significant lags.</p>
<h2 id="sound-2"><a class="header" href="#sound-2">Sound</a></h2>
<p>Content of sound buffers will be automatically reloaded when their source files are changed. There might be a "pop" sound
when a buffer is reloaded, this happens because of a sudden change of amplitude of the signal. Reloading of sound buffers
could be quite slow for large sounds (such a music), since usually sound buffers are encoded with some algorithm and this
data needs to be decoded when reloading.</p>
<h2 id="models"><a class="header" href="#models">Models</a></h2>
<p>Model resource (which is prefab also) supports hot reloading as well, but with some small limitations.</p>
<p>If a node in FBX or GLTF model changes its name, then its instance in the running game won't receive the changes from
the source file. This happens, because the engine uses object name to search for the "ancestor" from which it then takes
the data. If you swap names between two or more objects, their properties will be swapped in the game also. This issue
does not exist if you're changing names in native engine prefabs.</p>
<p>Hierarchy changes in a source file will be reflected in all instances, however it could not work correctly if you're changing
hierarchy in FBX or GLTF model if there are duplicated names. This issue does not exist if you're changing names in native
engine prefabs.</p>
<p>Objects deleted in models will be also deleted in the running game, which could result in crash if you're expecting the
objects to be always alive.</p>
<p>Any change in a leaf prefab in a chain of hierarchical prefabs will cause an update pass of its first ancestor. In other
words, if you have a level with a room prefab, and this room prefab has chair prefab instances in it then any change in the
chair prefab source file will be applied to the chair prefab itself, then its instances in the room prefab. See
<a href="resources/../scene/inheritance.html">property inheritance</a> chapter for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Resource manager is able to notify its subscribers about specific events of resources. There are four kinds of resource
events:</p>
<ol>
<li><code>Loaded</code> - occurs when a resource was fully loaded without any errors.</li>
<li><code>Reloaded</code> - occurs when a resource was already fully loaded, but was reloaded by an explicit request.</li>
<li><code>Added</code> - occurs when a resource was just added to the resource manager. This event is fired right after a resource
was requested from the manager.</li>
<li><code>Removed</code> - occurs when a resource was removed from the resource manager. This event is fired when the resource
manager removes and unloads an unused resource.</li>
</ol>
<p>To subscribe for resource events use the event broadcaster:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn subscribe_to_events(resource_manager: &amp;ResourceManager) {
    let (sender, receiver) = channel();
    resource_manager.state().event_broadcaster.add(sender);

    while let Ok(event) = receiver.try_recv() {
        match event {
            ResourceEvent::Loaded(_) =&gt; {}
            ResourceEvent::Reloaded(_) =&gt; {}
            ResourceEvent::Added(_) =&gt; {}
            ResourceEvent::Removed(_) =&gt; {}
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="engine"><a class="header" href="#engine">Engine</a></h1>
<p>This chapter of the book contains detailed description for the engine parts, such as graphics context, window
management, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics-context"><a class="header" href="#graphics-context">Graphics Con<strong>t</strong>ext</a></h1>
<p>Graphics context stores the main application window and the renderer. Graphics context could not exist at all, this is
so called "headless" mode which could be useful for dedicated servers.</p>
<h2 id="creation"><a class="header" href="#creation">Creation</a></h2>
<p>Graphics context is created and destroyed automatically when the engine receives <code>Resumed</code> and <code>Suspended</code>
events. Usually, <code>Suspended</code> event is sent only on platforms that supports suspension, such as Android.
Suspension happens when you switch to another application on your smartphone. Other supported platforms
do not support suspension, so this event is not sent on them.</p>
<p>Keep in mind, that when the engine is just initialized there's no graphics context at all, so you
can't access it (for example, to change the window title). Instead, you have to use
<code>Plugin::on_graphics_context_initialized</code> method to do this, or check if the graphics context is alive in
the game loop and do required actions.</p>
<h2 id="interaction-with-plugins"><a class="header" href="#interaction-with-plugins">Interaction with Plugins</a></h2>
<p>There's very clear interaction between plugins and graphics context. There are two plugin methods that
will be called when the graphics context is either created or destroyed - <code>on_graphics_context_initialized</code>
and <code>on_graphics_context_destroyed</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct Game {}

impl Plugin for Game {
    fn on_graphics_context_initialized(&amp;mut self, context: PluginContext) {
        // At this stage it is safe to call `as_initialized_mut`, because graphics context is guaranteed
        // to be alive when this method is being called.
        let graphics_context = context.graphics_context.as_initialized_mut();

        graphics_context.window.set_title("My Cool Game");
    }

    fn on_graphics_context_destroyed(&amp;mut self, context: PluginContext) {
        println!("Graphics context was destroyed.")
    }
<span class="boring">}</span></code></pre></pre>
<p>You can also do a checked borrow of the graphics context at any place in a plugin. For example, the following
code tries to fetch current graphics context, and if it succeeds, then it prints current FPS in the window
title:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        if let GraphicsContext::Initialized(graphics_context) = context.graphics_context {
            graphics_context.window.set_title(&amp;format!(
                "FPS: {}",
                graphics_context.renderer.get_statistics().frames_per_second
            ));
        }
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="window"><a class="header" href="#window">Window</a></h2>
<p>See the next chapter to learn more how to interact with the main application window.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-management"><a class="header" href="#window-management">Window Management</a></h1>
<p>This chapter of the book explains how to manage the main application window and its related parts.</p>
<blockquote>
<p>⚠️ Main window exists only if there's a graphics context. That's why the following examples
checks for a graphics context to be available. Graphics context could be missing if you're using
the engine in "headless" mode (could be useful for game servers) or on some platforms (such as Android)
that support application suspension.</p>
</blockquote>
<h2 id="title"><a class="header" href="#title">Title</a></h2>
<p>Setting a title is very easy to do:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let GraphicsContext::Initialized(ref graphics_context) = ctx.graphics_context {
            graphics_context.window.set_title("My Awesome Game");
        }
<span class="boring">}</span></code></pre></pre>
<h2 id="cursor"><a class="header" href="#cursor">Cursor</a></h2>
<p>This section contains the code for the most common use cases of the mouse cursor.</p>
<h3 id="show-or-hide"><a class="header" href="#show-or-hide">Show or Hide</a></h3>
<p>You can show or hide the mouse cursor using the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // Hide the cursor if the window exists.
        if let GraphicsContext::Initialized(ref graphics_context) = ctx.graphics_context {
            graphics_context.window.set_cursor_visible(false);
        }
<span class="boring">}</span></code></pre></pre>
<h3 id="lock-inside-window"><a class="header" href="#lock-inside-window">Lock Inside Window</a></h3>
<p>It is possible to lock the mouse cursor in the window bounds. You can do it using the <code>set_cursor_grab</code>
method if the main window:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let GraphicsContext::Initialized(ref graphics_context) = ctx.graphics_context {
            Log::verify(graphics_context.window.set_cursor_grab(
                // Use one of the following here: None, Confined, Locked. See the API docs for
                // CursorGrabMode for more info.
                CursorGrabMode::Confined,
            ));
        }
<span class="boring">}</span></code></pre></pre>
<h2 id="fullscreen-mode"><a class="header" href="#fullscreen-mode">Fullscreen Mode</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let GraphicsContext::Initialized(ref graphics_context) = ctx.graphics_context {
            // Option 1: Use borderless non-exclusive full screen mode.
            graphics_context
                .window
                .set_fullscreen(Some(Fullscreen::Borderless(None)));

            // Option 2: Use true exclusive full screen mode.
            if let Some(monitor) = graphics_context.window.current_monitor() {
                if let Some(first_avilable_video_mode) = monitor.video_modes().next() {
                    graphics_context
                        .window
                        .set_fullscreen(Some(Fullscreen::Exclusive(first_avilable_video_mode)));
                }
            }
        }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-engine-initialization"><a class="header" href="#manual-engine-initialization">Manual Engine Initialization</a></h1>
<p>It is possible to initialize the engine manually and have custom game logic loop. It could be done something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    let event_loop = EventLoop::new().unwrap();

    let mut window_attributes = WindowAttributes::default();
    window_attributes.resizable = true;
    window_attributes.title = "My Game".to_string();

    let serialization_context = Arc::new(SerializationContext::new());
    let task_pool = Arc::new(TaskPool::new());
    let mut engine = Engine::new(EngineInitParams {
        graphics_context_params: GraphicsContextParams {
            window_attributes,
            vsync: true,
            msaa_sample_count: None,
            graphics_server_constructor: GraphicsServerConstructor::default(),
        },
        resource_manager: ResourceManager::new(task_pool.clone()),
        serialization_context,
        task_pool,
        widget_constructors: Arc::new(new_widget_constructor_container()),
    })
    .unwrap();

    let mut previous = Instant::now();
    let fixed_time_step = 1.0 / 60.0;
    let mut lag = 0.0;

    event_loop
        .run(move |event, window_target| {
            window_target.set_control_flow(ControlFlow::Wait);

            let scenes = engine
                .scenes
                .pair_iter()
                .map(|(s, _)| s)
                .collect::&lt;Vec&lt;_&gt;&gt;();

            match event {
                Event::Resumed =&gt; {
                    engine
                        .initialize_graphics_context(window_target)
                        .expect("Unable to initialize graphics context!");
                }
                Event::Suspended =&gt; {
                    engine
                        .destroy_graphics_context()
                        .expect("Unable to destroy graphics context!");
                }
                Event::AboutToWait =&gt; {
                    // This main game loop - it has fixed time step which means that game
                    // code will run at fixed speed even if renderer can't give you desired
                    // 60 fps.
                    let elapsed = previous.elapsed();
                    previous = Instant::now();
                    lag += elapsed.as_secs_f32();
                    while lag &gt;= fixed_time_step {
                        lag -= fixed_time_step;

                        // ************************
                        // ************************
                        // Put your game logic here.
                        // ************************
                        // ************************

                        // It is very important to update the engine every frame!
                        engine.update(fixed_time_step, window_target, &amp;mut lag, Default::default());
                    }

                    if let GraphicsContext::Initialized(ref ctx) = engine.graphics_context {
                        ctx.window.request_redraw();
                    }
                }
                Event::WindowEvent { event, .. } =&gt; {
                    match event {
                        WindowEvent::CloseRequested =&gt; window_target.exit(),
                        WindowEvent::Resized(size) =&gt; {
                            if let Err(e) = engine.set_frame_size(size.into()) {
                                Log::writeln(
                                    MessageKind::Error,
                                    format!("Unable to set frame size: {:?}", e),
                                );
                            }
                        }
                        WindowEvent::RedrawRequested =&gt; {
                            engine.render().unwrap();
                        }
                        _ =&gt; (),
                    }

                    if let Some(os_event) = translate_event(&amp;event) {
                        for ui in engine.user_interfaces.iter_mut() {
                            ui.process_os_event(&amp;os_event);
                        }
                    }
                }
                _ =&gt; (),
            }
        })
        .unwrap();
}</code></pre></pre>
<p>Keep in mind, that this code does <strong>NOT</strong> have plugins nor editor support. It is just barebones engine without anything
attached to it. If you still need the editor and plugins, but don't like the built-in game loop or initialization routines,
read the next section.</p>
<h2 id="custom-executor"><a class="header" href="#custom-executor">Custom Executor</a></h2>
<p>The recommended way of using the engine is to generate a project, that has an editor and a bunch of platform-dependent
executor crates. If the built-in executor do not have features you need, or have some issues you know how to fix, you
can create custom executor. All you need to do is to copy <a href="https://github.com/FyroxEngine/Fyrox/blob/master/fyrox-impl/src/engine/executor.rs">the built-in one</a>,
add it your module tree and modify as you like. Then you need to replace all usages of built-in one with your custom one
and that's pretty much it - now you have full control in engine initialization and game loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">Network</a></h1>
<p>This part of the book explains how to make a multiplayer game with Fyrox and which functionality it has for this
purpose. In general, network support in the engine is quite basic and some features might be missing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>This chapter explains what the engine offers for making multiplayer games.</p>
<h2 id="protocols"><a class="header" href="#protocols">Protocols</a></h2>
<p>Fyrox has basic support for simple network operations using TCP. This reliable network protocol with guaranteed
delivery, but it may suffer from large latency, thus it may not be suitable for some applications. In particular,
in high pace shooters TCP will result in quite noticeable lag. Such games should use mixed approach of UDP+TCP, where
UDP should be used for "insignificant" data and TCP to send important data. Insignificant data can include the data
that changes every frame (position, rotation, etc.). On the other hand, important data can include player connection
data. Everything related to TCP-based network entities is located in <code>fyrox::core::net</code> module.</p>
<h2 id="client-server-architecture"><a class="header" href="#client-server-architecture">Client-Server Architecture</a></h2>
<p>Multiplayer games are usually based on client-server architecture. As stated in the title, it consists of a server
and any number of clients. There's also a subdivision for the server side—it could be a dedicated server or a listen
server.</p>
<p>Dedicated server is an application that is responsible only for game logic and interaction with clients; it does
not render anything on screen, does not accept any input from a player.</p>
<p>Listen server is a combination of a dedicated server and the client running in the same process (application). In most
cases, this is the most preferable option for typical players, since it allows them to start a server and play as
a "client" and allow other players to join their server.</p>
<p>Typical structure is quite simple for TCP connections, and it is recommended if you've never ever made a multiplayer
game. The following example implements a listen server (where you have both the server and the client part running in
the same application), which is the easiest kind of server to implement. Its implementation could look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Implements listen server.
#[derive(Default, Reflect, Debug)]
pub struct Game {
    scene: Handle&lt;Scene&gt;,
    server: Option&lt;Server&gt;,
    client: Option&lt;Client&gt;,
}

impl Plugin for Game {
    fn init(&amp;mut self, scene_path: Option&lt;&amp;str&gt;, context: PluginContext) {
        self.server = Some(Server::new());
        self.client = Some(Client::connect(Server::ADDRESS));
    }

    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        if let Some(server) = self.server.as_mut() {
            server.accept_connections();
            server.read_messages();
        }
        if let Some(client) = self.client.as_mut() {
            client.read_messages();
        }
    }

    fn on_scene_loaded(
        &amp;mut self,
        path: &amp;Path,
        scene: Handle&lt;Scene&gt;,
        data: &amp;[u8],
        context: &amp;mut PluginContext,
    ) {
        self.scene = scene;

        if self.server.is_none() {
            context.scenes[scene]
                .graph
                .physics
                .enabled
                .set_value_and_mark_modified(false);
        }
    }
}

#[derive(Reflect)]
pub struct Server {
    #[reflect(hidden)]
    listener: NetListener,
    #[reflect(hidden)]
    connections: Vec&lt;NetStream&gt;,
    #[reflect(hidden)]
    prev_node_states: FxHashMap&lt;Handle&lt;Node&gt;, NodeState&gt;,
}

impl Server {
    const ADDRESS: &amp;'static str = "127.0.0.1:10000";

    pub fn new() -&gt; Self {
        Self {
            listener: NetListener::bind(Self::ADDRESS).unwrap(),
            connections: Default::default(),
            prev_node_states: Default::default(),
        }
    }

    pub fn accept_connections(&amp;mut self) {
        self.connections.extend(self.listener.accept_connections())
    }

    pub fn read_messages(&amp;mut self) {
        for connection in self.connections.iter_mut() {
            connection
                .process_input::&lt;ClientMessage&gt;(|msg| info!("Received client message: {msg:?}"));
        }
    }

    pub fn send_message_to_clients(&amp;mut self, message: ServerMessage) {
        for connection in self.connections.iter_mut() {
            connection.send_message(&amp;message).unwrap();
        }
    }
}

#[derive(Reflect)]
pub struct Client {
    #[reflect(hidden)]
    connection: NetStream,
}

impl Client {
    pub fn connect(address: &amp;str) -&gt; Self {
        Self {
            connection: NetStream::connect(address).unwrap(),
        }
    }

    pub fn read_messages(&amp;mut self) {
        self.connection
            .process_input::&lt;ServerMessage&gt;(|msg| info!("Received server message: {msg:?}"));
    }

    pub fn send_message_to_server(&amp;mut self, message: ClientMessage) {
        self.connection.send_message(&amp;message).unwrap();
    }
}

impl Visit for Game {
    fn visit(&amp;mut self, name: &amp;str, visitor: &amp;mut Visitor) -&gt; VisitResult {
        // This must be implemented only for hot-reloading support. It is up to you to maintain
        // client-server connections during hot-reloading, and it is out of the scope of this example.
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There's a lot of code, but it is very straightforward. There are two main entities here: <code>Server</code> and <code>Client</code>.
The server holds a TCP listener, which internally handles handshake network operations that allows to establish
a reliable connection between the listener and any number of clients. Each such connection is called stream.</p>
<p>The client holds a connection to the server (read: stream). The next interesting part is how the game update loop
is structured:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        if let Some(server) = self.server.as_mut() {
            server.accept_connections();
            server.read_messages();
        }
        if let Some(client) = self.client.as_mut() {
            client.read_messages();
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>At first, the server tries to accept all incoming connections and only then tries to read all the incoming messages.
The client is also trying to read all the incoming messages. The server side will be <code>None</code> for other players (non-host).</p>
<p>The listen server could be quite confusing because it has both the server and the client at the same time. If you've
never implemented multiplayer games, it will be even more confusing. The main question that arises very often—how
to manage the server and client at the same time? The answer to this is very simple—the same as with dedicated
servers: all interaction must be done via messages. The client must never access the server side directly and vice
versa.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>Network interaction is usually based on some kind of messages. Message is a simple data storage that contains some
data to perform specific actions. There could be server and client messages, each serves different purpose. For example,
a server message is sent by a server and interpreted on a client side. It could include commands to load specific level,
add other players, synchronize the state of objects, and so on. A client message is sent by a client to a server and
interpreted on a server side. For example, it could include player input state. A typical set of messages could look like
this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Server messages are meant to be sent to clients.
#[derive(Serialize, Deserialize, Debug)]
pub enum ServerMessage {
    LoadLevel { path: PathBuf },
    Sync { entity_states: Vec&lt;NodeState&gt; },
}

#[derive(Serialize, Deserialize, Debug)]
// Client messages are meant to be sent to a server.
pub enum ClientMessage {
    PlayerInput { left: bool, right: bool },
}
<span class="boring">}</span></code></pre></pre>
<p>Sending a message (from either side) is very straightforward:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Game {
    fn send_test_messages(&amp;mut self) {
        // Send the server message to the clients.
        if let Some(server) = self.server.as_mut() {
            // Force clients to load a level.
            server.send_message_to_clients(ServerMessage::LoadLevel {
                path: PathBuf::from("data/scenes/scene.rgs"),
            })
        }
        // Send the client message.
        if let Some(client) = self.client.as_mut() {
            client.send_message_to_server(ClientMessage::PlayerInput {
                // Player's moving left.
                left: true,
                right: false,
            })
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="stable-ids"><a class="header" href="#stable-ids">Stable IDs</a></h2>
<p>When it comes to game entities (scene nodes), it is essential to have unique IDs for them, to be able to synchronize their
states across multiple clients. The engine uses UUID for this purpose. Why can't we just use node handles for this? The
main reason is that it is unreliable, because scene node handles are basically just an index + generation id. The index
part could be different for different clients for the same scene node. Usually it happens when relatively heavy prefabs
are instantiated in a separate async task (see the respective section below). If we assign a unique id for the scene node
across all clients, and it will make client-server synchronization reliable, since we can use this id to find the entity.</p>
<p>There are a number of ways to assign unique ids for scene nodes. The easiest is to use <code>.with_id</code> method when building
a scene node:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_node_with_id(scene: &amp;mut Scene, id: Uuid) -&gt; Handle&lt;Node&gt; {
    PivotBuilder::new(BaseBuilder::new().with_instance_id(SceneNodeId(id))).build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>What if we want to instantiate a prefab on all clients, how can we ensure that the ids of the entire hierarchy will
be the same? The easiest way to do this is to use a pair of built-in methods - <code>Model::generate_ids</code> and <code>.with_ids()</code>.
Typical structure could look like this. At first, define a new message type:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, Default)]
pub struct InstantiatePrefabMessage {
    pub path: PathBuf,
    pub position: Vector3&lt;f32&gt;,
    pub rotation: UnitQuaternion&lt;f32&gt;,
    pub ids: FxHashMap&lt;Handle&lt;Node&gt;, SceneNodeId&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>It contains all that is needed to instantiate a new prefab on the client side. The server side needs the following
function:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function is called on the server side.
pub fn create_prefab_message(ctx: &amp;mut PluginContext) -&gt; InstantiatePrefabMessage {
    let path = PathBuf::from("data/models/bot.rgs");

    let bot_prefab =
        fyrox::core::futures::executor::block_on(ctx.resource_manager.request::&lt;Model&gt;(&amp;path))
            .unwrap();

    InstantiatePrefabMessage {
        path,
        position: Vector3::new(1.0, 2.0, 3.0),
        rotation: Default::default(),
        ids: bot_prefab.generate_ids(),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>At first, it loads the desired prefab, then generates ids for all its sub-nodes and creates a new message with this
information. This message is then can be sent over the network to all clients. When a client receives such a message,
it could handle it like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function is called on the client side.
pub fn on_prefab_message_received(
    desc: InstantiatePrefabMessage,
    game: &amp;mut Game,
    ctx: &amp;mut PluginContext,
) {
    let result =
        fyrox::core::futures::executor::block_on(ctx.resource_manager.request::&lt;Model&gt;(&amp;desc.path));

    match result {
        Ok(model) =&gt; {
            let scene = &amp;mut ctx.scenes[game.scene];
            model
                .begin_instantiation(scene)
                .with_position(desc.position)
                .with_rotation(desc.rotation)
                .with_ids(&amp;desc.ids)
                .finish();
        }
        Err(err) =&gt; {
            Log::err(format!(
                "Unable to instantiate {} prefab. Reason: {:?}",
                desc.path.display(),
                err
            ));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The crucial part here is <code>.with_ids(..)</code> call, which forces the prefab's sub-nodes to have the provided set of ids.
This way all the nodes across all clients will have the same unique id per node.</p>
<h2 id="dealing-with-async"><a class="header" href="#dealing-with-async">Dealing with Async</a></h2>
<p>Leaving your game responsive while performing some computationally heavy work is crucial for smooth gameplay. Some of
the heaviest tasks in pretty much any game is loading an asset. The engine has a built-in task system to help avoid
lags during this process.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function is called on the client side.
pub fn on_prefab_message_received_async(desc: InstantiatePrefabMessage, ctx: &amp;mut PluginContext) {
    ctx.task_pool.spawn_plugin_task(
        // The resource itself could be used as a task.
        ctx.resource_manager.request::&lt;Model&gt;(&amp;desc.path),
        // This closure will be called when the task (resource loading) is completed.
        move |result, game: &amp;mut Game, ctx| match result {
            Ok(model) =&gt; {
                let scene = &amp;mut ctx.scenes[game.scene];
                model
                    .begin_instantiation(scene)
                    .with_position(desc.position)
                    .with_rotation(desc.rotation)
                    .with_ids(&amp;desc.ids)
                    .finish();
            }
            Err(err) =&gt; {
                Log::err(format!(
                    "Unable to instantiate {} prefab. Reason: {:?}",
                    desc.path.display(),
                    err
                ));
            }
        },
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>There's one quite large multiplayer game built with Fyrox - <a href="https://github.com/mrDIMAS/FishFolly">Fish Folly</a>. It is
a "Fall Guys"-like platformer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h1>
<p>Pretty much every game has dozens of changing objects, and you need to synchronize their state across all the clients,
so their state matches the server state. In the simplest case, all that you need is to collect information about node
positions and rotations and send them to the clients:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct NodeState {
    pub node: SceneNodeId,
    pub position: Vector3&lt;f32&gt;,
    pub rotation: UnitQuaternion&lt;f32&gt;,
}

impl Server {
    pub fn sync(&amp;mut self, scene: Handle&lt;Scene&gt;, ctx: &amp;mut PluginContext) {
        let scene = some_or_return!(ctx.scenes.try_get(scene));
        let mut entity_states = Vec::with_capacity(scene.graph.capacity() as usize);
        for (handle, node) in scene.graph.pair_iter() {
            entity_states.push(NodeState {
                node: node.instance_id(),
                position: **node.local_transform().position(),
                rotation: **node.local_transform().rotation(),
            });
        }
        self.send_message_to_clients(ServerMessage::Sync { entity_states });
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If the number of objects is low, it will work fine on most machines and network connections. However, this algorithm
is somewhat dumb, because it gathers a ton of useless information. For example, most of the scene objects remain
static, and thus their "new" position and rotation can be ignored because it is not new at all—it's the same
as in the previous frame.</p>
<h2 id="delta-compression"><a class="header" href="#delta-compression">Delta Compression</a></h2>
<p>Delta compression is used to minimize the amount of data being sent from the server to clients and vice versa. It is
a simple, yet very efficient way of reducing the required network bandwidth and performance requirements of your game.</p>
<p>The simplest delta compression could be implemented like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Server {
    pub fn sync_with_delta_compression(&amp;mut self, scene: Handle&lt;Scene&gt;, ctx: &amp;mut PluginContext) {
        let scene = some_or_return!(ctx.scenes.try_get(scene));
        let mut entity_states = Vec::with_capacity(scene.graph.capacity() as usize);
        for (handle, node) in scene.graph.pair_iter() {
            let current_state = NodeState {
                node: node.instance_id(),
                position: **node.local_transform().position(),
                rotation: **node.local_transform().rotation(),
            };

            // Simple delta compression.
            let prev_state = self
                .prev_node_states
                .entry(handle)
                .or_insert(current_state.clone());

            if *prev_state != current_state {
                entity_states.push(current_state.clone());
                *prev_state = current_state;
            }
        }

        self.send_message_to_clients(ServerMessage::Sync { entity_states });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="physics-5"><a class="header" href="#physics-5">Physics</a></h2>
<p>Client-server model assumes that the server has the priority in calculations and its state has the top priority
than clients. This applies to physics simulation as well, no need to run expensive physics simulation if its state
is overwritten by the server state anyway. That being said, the client must have physics simulation disabled. This can
be done like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_scene_loaded(
        &amp;mut self,
        path: &amp;Path,
        scene: Handle&lt;Scene&gt;,
        data: &amp;[u8],
        context: &amp;mut PluginContext,
    ) {
        self.scene = scene;

        if self.server.is_none() {
            context.scenes[scene]
                .graph
                .physics
                .enabled
                .set_value_and_mark_modified(false);
        }
    }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-server-hosting"><a class="header" href="#game-server-hosting">Game Server Hosting</a></h1>
<p>The main issue with today's Internet is that it is mostly based on very old IPv4, which supports around 4 billion
IP addresses and pretty much all of them are already allocated between companies and individuals. Nowadays, internet
connection relies on network address translation (NAT) to be able to have multiple devices with their own IP addresses.
This fact makes it impossible to connect two devices directly to each other, because the devices simply do not
have a stable IP address anymore (it is defined by NAT). This could be solved by IPv6, which essentially has almost
unlimited number of addresses, yet its adoption is quite slow.</p>
<p>Unfortunately, there is no easy way to connect two or more devices directly. One of the simplest ways is to rent a
virtual personal server (VPS) with a stable IP address and use it as a sort of "proxy" server that will be able to
handle connections between the devices. This process is called <a href="https://en.wikipedia.org/wiki/Hole_punching_(networking)">hole punching</a>.
It is used all the time in modern internet, but sometimes it isn't enough and the only solution is to host
a dedicated game server on a VPS (or a more powerful, yet costly, real web server).</p>
<p>To bypass all these issues once and for all, your game should be able to run a dedicated game server, which should be
deployed on a VPS/real server. The rule of thumb here is to develop and test your game in your local network, and only
when its minimal valuable version is ready, rent a server and test it with players across the globe.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h1>
<p>Fyrox features an extremely powerful and flexible node-based user interface system. Power and flexibility comes with
a certain price: it has a steep learning curve. This chapter will cover user interface usage in the engine, explain
basic concepts, provide information about most commonly used widgets, and so on.</p>
<h2 id="web-demo-1"><a class="header" href="#web-demo-1">Web Demo</a></h2>
<p>You can explore UI system capabilities in this <a href="https://fyrox.rs/assets/demo/ui/index.html">web demo</a>. Keep in mind,
that it was designed to run on PC and wasn't tested on mobile devices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts-3"><a class="header" href="#basic-concepts-3">Basic concepts</a></h1>
<p>This chapter should help you understand basic concepts lying in the foundation of the GUI in the engine.</p>
<h2 id="stateful"><a class="header" href="#stateful">Stateful</a></h2>
<p>Stateful UI means that we can create and destroy widgets when we need to, it is the opposite approach of
immediate-mode or stateless UIs when you don't have long-lasting state for your widgets
(usually stateless UI hold its state only for one or two frames).</p>
<p>Stateful UI is much more powerful and flexible, it allows you to have complex layout system without having to
create hacks to create complex layout as you'd do in immediate-mode UIs. It is also much faster in terms of
performance.</p>
<p>Stateful UI is a must for complex user interfaces that requires rich layout and high performance. I'm not telling
that you <em>can't</em> do it in immediate mode UI, you can, but using tons of hacks. See <a href="ui/basic_concepts/basic_concepts.html#layout">Layout</a> section for
more info.</p>
<h2 id="model-view-controller"><a class="header" href="#model-view-controller">Model-View-Controller</a></h2>
<p>The UI system is designed to be used in a classic model-view-controller MVC approach. Model in this case is your game
state, view is the UI system, controller is your event handlers. In other words - the UI shows what happens in your game
and does not store any game-related information. This is quite old, yet powerful mechanism that decouples UI code from
game code very efficiently and allows you to change game code and UI code independently.</p>
<h2 id="node-based-architecture"><a class="header" href="#node-based-architecture">Node-based architecture</a></h2>
<p>Every user interface could be represented as a set of small blocks that have hierarchical bonding between each
other. For example a button could be represented using two parts: a background and a foreground. Usually the background
is just a simple rectangle (either a vector or bitmap), and a foreground is a text. The text (the foreground widget)
is a child object of the rectangle (the background widget). These two widgets forms another, more complex widget that
we call button. Graphically it will look like this:</p>
<p><img src="ui/basic_concepts/./button.svg" alt="Button" /></p>
<p>On the right side of the image we can see the generic button and on the left side, we can see its hierarchical
structure. Such approach allows us to modify the look of the button as we wish, we can create a button with
image background, or with any vector image, or even other widgets. The foreground can be anything too, it can also
contain its own complex hierarchy, like a pair of an icon with a text and so on.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Every widget in the engine uses composition to build more complex widgets. All widgets (and respective builders) contains
<code>Widget</code> instance inside, it provides basic functionality the widget such as layout information, hierarchy, default
foreground and background brushes (their usage depends on derived widget), render and layout transform and so on.</p>
<h2 id="component-querying"><a class="header" href="#component-querying">Component Querying</a></h2>
<p>Many widgets provide component querying functionality - you can get an immutable reference to inner component by its type. It is
used instead of type casting in many places. Component querying is much more flexible compared to direct type casting.
For example, you may want to build a custom <a href="ui/basic_concepts/../tree.html">Tree</a> widget, you want your CustomTree to inherit all the
functionality from the Tree, but add something new. The Tree widget can manage its children subtrees, but it needs to
somehow get required data from subtree. Direct type casting would fail in this case, because now you have something
like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::tree::Tree;
</span>struct CustomTree {
    tree: Tree,
    my_data: u32
}
<span class="boring">}</span></code></pre></pre>
<p>On other hand, component querying will work fine, because you can query inner component (Tree in our case). Please note
that this has nothing similar with ECS and stuff, it is made to circumvent Rust's lack of inheritance.</p>
<h2 id="message-passing-2"><a class="header" href="#message-passing-2">Message passing</a></h2>
<p>The engine uses message passing mechanism for any UI logic. What does that mean? Let's see at the button from the
previous section and imagine we want to change its text. To do that we need to explicitly "tell" the button's text
widget to change its content to something new. This is done by sending a message to the widget.</p>
<p>There is no classic callbacks to handle various types of messages, which may come from widgets. Instead, you should write
your own message dispatcher where you'll handle all messages. Why so? At first - decoupling, in this case business logic
is decoupled from the UI. You just receive messages one-by-one and do specific logic. The next reason is that any
callback would require context capturing which could be somewhat restrictive - since you need to share context with the
UI, it would force you to wrap it in <code>Rc&lt;RefCell&lt;..&gt;&gt;</code>/<code>Arc&lt;Mutex&lt;..&gt;&gt;</code>.</p>
<p>Message dispatcher is very easy to write, all you need to do is to handle UI messages in <code>Plugin::on_ui_message</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct MyPlugin {
    button: Handle&lt;UiNode&gt;,
}

impl Plugin for MyPlugin {
    fn on_ui_message(&amp;mut self, _context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.button {
                println!("The button was clicked!");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, all you need to do is to check type of incoming message and message destination, which is a node handle
from which a message was come from. Then you do any actions you want.</p>
<h3 id="message-routing-strategies"><a class="header" href="#message-routing-strategies">Message routing strategies</a></h3>
<p>Message passing mechanism works in pair with various routing strategies that allows you to define how the message
will "travel" across the tree of nodes.</p>
<ol>
<li>Bubble - a message starts its way from a widget and goes up on hierarchy until it reaches root node of hierarchy.
Nodes that lies outside that path won't receive the message. This is the most important message routing strategy, that
is used for <strong>every</strong> node by default.</li>
<li>Direct - a message passed directly to every node that are capable to handle it. There is actual routing in this
case. Direct routing is used in rare cases when you need to catch a message outside its normal "bubble" route.</li>
</ol>
<p>Bubble message routing is used to handle complex hierarchies of widgets with ease. Let's take a look at the button
example above - it has text widget as a content and when, for instance, you hover a mouse over the text widget the UI
system creates a "mouse moved" message and sends it to the text. Once it was processed by the text, it "floats" one
level of hierarchy up - to the button widget itself. This way the button widget can process mouse events as well.</p>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>The UI systems uses complex, yet powerful layout system that allows you to build complex user interfaces with
complex layout. Layout pass has two <em>recursive</em> sub-passes:</p>
<ol>
<li>Measurement - the sub-pass is used to fetch the desired size of each widget in hierarchy. Each widget in the hierarchy
"asked" for its desired size with the constraint from a parent widget. This step is recursive - to know a desired size
of a widget root of some hierarchy you need to recursively fetch the desired sizes of every descendant.</li>
<li>Arrangement - the sub-pass is used to set final position and size of each widget in hierarchy. It uses desired size
of every widget from the previous step to set the final size and relative position. This step is recursive.</li>
</ol>
<p>Such separation in two passes is required because we need to know desired size of each node in hierarchy before we can
actually do an arrangement.</p>
<h2 id="code-first-and-editor-first-approaches"><a class="header" href="#code-first-and-editor-first-approaches">Code-first and Editor-first approaches</a></h2>
<p>The UI system supports both ways of making a UI:</p>
<ol>
<li>Code-first approach is used when your user interface is procedural and its appearance is heavily depends on
your game logic. In this case you need to use various widget builder to create UIs.</li>
<li>Editor-first approach is used when you have relatively static (animations does not count) user interface,
that almost does not change in time. In this case you can use built-in WYSIWYG (what-you-see-is-what-you-get)
editor. See <a href="ui/basic_concepts/../editor/editor.html">Editor</a> chapter for more info.</li>
</ol>
<p>In case of code-first approach you should prefer so-called <em>fluent syntax</em>: this means that you can create your
widget in series of nested call of other widget builders. In code, it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fancy_button(
    ui: &amp;mut UserInterface,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();
    ButtonBuilder::new(WidgetBuilder::new())
        .with_back(
            ImageBuilder::new(WidgetBuilder::new())
                .with_texture(resource_manager.request::&lt;Texture&gt;("path/to/your/texture"))
                .build(ctx),
        )
        .with_text("Click me!")
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>This code snippet creates a button with an image and a text. Actually it creates <strong>three</strong> widgets, that forms
complex hierarchy. The topmost widget in hierarchy is the <code>Button</code> widget itself, it has two children widgets:
background image and a text. Background image is set explicitly by calling image widget builder with specific
texture. The text is created implicitly, the button builder creates <code>Text</code> widget for you and attaches it to
the button. The structure of the button can contain <em>any</em> number of nodes, for example you can create a button
that contains text with some icon. To do that, replace <code>.with_text("My Button")</code> with this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fancy_button_with_text(
    ui: &amp;mut UserInterface,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    ButtonBuilder::new(WidgetBuilder::new())
        .with_content(
            GridBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ImageBuilder::new(WidgetBuilder::new().on_column(0))
                            .with_texture(resource_manager.request::&lt;Texture&gt;("your_icon"))
                            .build(ctx),
                    )
                    .with_child(
                        TextBuilder::new(WidgetBuilder::new().on_column(1))
                            .with_text("My Button")
                            .build(ctx),
                    ),
            )
            .add_row(Row::stretch())
            .add_column(Column::auto())
            .add_column(Column::stretch())
            .build(ctx),
        )
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Quite often you need to store a handle to a widget in a variable, there is one neat trick to do that preserving
the fluent syntax:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fancy_button_with_shortcut(
    ui: &amp;mut UserInterface,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();
    let image;
    ButtonBuilder::new(WidgetBuilder::new())
        .with_back({
            image = ImageBuilder::new(WidgetBuilder::new())
                .with_texture(resource_manager.request::&lt;Texture&gt;("path/to/your/texture"))
                .build(ctx);
            image
        })
        .with_text("Click me!")
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-4"><a class="header" href="#limitations-4">Limitations</a></h2>
<p>UI system uses completely different kind of scenes - UI scenes, which are fully decoupled from game scenes. This means
that you can't incorporate UI widgets in a game scene. As a consequence, you don't have an ability to attach scripts to
widgets - their logic is strictly defined in their backing code. This limitation is intentional, and it is here
only for one reason - decoupling of UI code from game logic. Currently, there's only one right approach to make UIs -
to create widgets in your game plugin and sync the state of the widgets with game entities manually.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui-editor"><a class="header" href="#ui-editor">UI Editor</a></h1>
<p><img src="ui/editor/ui_editor.png" alt="UI Editor" /></p>
<p>User interface (UI) editor is used to create and edit UI scenes. Unlike many other game engines, UI scenes are
completely different kind of scenes - their content <strong>cannot</strong> be mixed with standard game scenes. This is
made on purpose - such separation enables a variety of optimizations and greatly improves flexibility.</p>
<h2 id="appearance"><a class="header" href="#appearance">Appearance</a></h2>
<p>UI editor looks pretty much the same as the editor for game scenes, with the only difference that it is
2D only. On the left side it contains the world viewer, which is used to manipulate the tree of widgets.
On the right side it has the inspector, which is used to edit properties of widgets. It also has just a
few tools in the toolbar - selection and move tool.</p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>To start making a UI scene all you need to do is to create a new UI scene. This could be done from
<code>File -&gt; New UI Scene</code> menu. After this you'll see an example scene with a button and a text. You can either
delete these widgets, or use them as you want. You can create any kinds of widgets in the UI scene, even
custom-made ones. All you need to do is to click <code>Create -&gt; UI</code> and select a desired widget, or you can also
right-click on a widget in the world viewer and create a widget from the context menu. The widget created
from the context menu will become a child widget of the widget from which you've opened the context menu.</p>
<p>Widgets can form an arbitrary hierarchy, which could be changed by dragging a widget and dropping it on some
other widget in the world viewer. Keep in mind, that some widgets may contain handles to other widgets, and
you need to set them too. For example, the Button widget contains a handle of its content which is used to
delete a current content when changing it to some other. If you'll leave button's content as unassigned handle,
then your button may behave weirdly. Some of the widgets (like layout panels) works directly with their
children widgets and do not have "external" handles.</p>
<h2 id="widgets"><a class="header" href="#widgets">Widgets</a></h2>
<p>See a respective chapter for each widget to learn how it can be created and tweaked. Keep in mind, that UI
editor is a new feature of the engine and the book's chapters could lack some information about the editor.</p>
<h2 id="video"><a class="header" href="#video">Video</a></h2>
<p>The following video shows how to create a simple main menu for a 2D platformer.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/qQTxEK5TTxM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-2"><a class="header" href="#rendering-2">Rendering</a></h1>
<p>User interface is usually rendered directly on screen, and in most cases this is enough. However, there are some
specific cases when you need to incorporate user interface in your game scene as an interactive screen (holographic,
for example) or to render some scene inside some UI element (to create some sort of in-game CCTV, for example). This
chapter covers these specific cases and rendering nuances in general.</p>
<h2 id="offscreen-rendering"><a class="header" href="#offscreen-rendering">Offscreen Rendering</a></h2>
<p>Offscreen rendering is used to render a UI into a texture, so it can be later used in your game scene. Here's a simple
example - holographic inventory in sci-fi games:</p>
<p><img src="ui/offscreen_ui.png" alt="offscreen ui" /></p>
<p>Default engine's user interface instance (accessible in <code>context.user_interfaces.first/first_mut()</code> from plugin methods) can't be rendered
offscreen due to engine design. However, you can create a new user interface instance, populate it with widgets, and
then render it to a texture. This could be done like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Visit, Reflect, Debug)]
struct Game {
    // Add these fields to your game.
    my_ui: UserInterface,
    render_target: TextureResource,
    screen_size: Vector2&lt;f32&gt;,
}

impl Plugin for Game {
    fn init(&amp;mut self, scene_path: Option&lt;&amp;str&gt;, context: PluginContext) {
        // Add this code to your Plugin::init

        // Define the desired render target size.
        let width = 128;
        let height = 128;

        // Create render target and user interface.
        self.render_target = TextureResource::new_render_target(width, height);
        self.screen_size = Vector2::new(width as f32, height as f32);
        self.my_ui = UserInterface::new(self.screen_size);

        // Create some widgets as usual.
        ButtonBuilder::new(WidgetBuilder::new())
            .with_text("Click Me!")
            .build(&amp;mut self.my_ui.build_ctx());

        // Use render_target as an ordinary texture - it could be applied to any material like so:
        let mut material = Material::standard();
        material.bind("diffuseTexture", Some(self.render_target.clone()));
        // This material **must** be assigned to some mesh in your scene!
    }

    fn update(&amp;mut self, context: &amp;mut PluginContext) {
        // It is very important to update the UI every frame and process all events that
        // comes from it.
        self.my_ui
            .update(self.screen_size, context.dt, &amp;Default::default());

        while let Some(message) = self.my_ui.poll_message() {
            // Do something with the events coming from the custom UI.
        }
    }

    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: PluginContext) {
        // This is the tricky part. Event OS event handling will be different depending on the use case.
        // In cases if your UI just shows some information, this method can be fully removed. In case when
        // you need to interact with the UI, there are two different ways.
        // 1) If your UI will be incorporated in 2D scene, you need to patch mouse events - mostly positions
        // of the cursor so it will be in local coordinates.
        // 2) In 3D, it is much more complex - you need to patch mouse events as well, but use mouse OS events
        // to produce a picking ray and do an intersection test with a quad that will serve as a canvas for your
        // UI to obtain the local mouse coordinates.
        if let Event::WindowEvent { event, .. } = event {
            if let Some(event) = utils::translate_event(event) {
                self.my_ui.process_os_event(&amp;event);
            }
        }
    }

    fn before_rendering(&amp;mut self, context: PluginContext) {
        // Render the UI before every other rendering operation, this way the texture will be ready for use immediately.
        if let GraphicsContext::Initialized(ref mut graphics_context) = context.graphics_context {
            Log::verify(graphics_context.renderer.render_ui_to_texture(
                self.render_target.clone(),
                self.screen_size,
                self.my_ui.draw(),
                Color::TRANSPARENT,
                PixelKind::RGBA8,
            ));
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There's quite a lot of code, but it is quite simple and the comments should help you to understand which part does what.
It uses standard plugin structure and contents of each method should be placed in the according methods in your game.
This code creates a new user interface, a render target of appropriate size and renders the UI into the render
target. The render target then could be used as a diffuse texture in one of your materials, which in its turn, can
be assigned to pretty much any mesh in your game.</p>
<h2 id="embedding-scene-into-ui"><a class="header" href="#embedding-scene-into-ui">Embedding Scene into UI</a></h2>
<p>It is possible to "embed" a scene into arbitrary user interface. This could be useful if you need to create some sort
of CCTV, or to show 3D graphics in 2D user interface and so on. To do so, you need to specify a render target for your
scene and then use the texture (render target) in an <code>Image</code> widget.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reroute_scene_rendering(
    width: u32,
    height: u32,
    scene: &amp;mut Scene,
    context: &amp;mut PluginContext,
) -&gt; Handle&lt;UiNode&gt; {
    // Create render target first.
    let render_target = TextureResource::new_render_target(width, height);

    // Specify render target for the scene.
    scene.rendering_options.render_target = Some(render_target.clone());

    // The scene will be drawn in this image widget.
    ImageBuilder::new(
        WidgetBuilder::new()
            .with_width(width as f32)
            .with_height(height as f32),
    )
    .with_texture(render_target.clone())
    .build(&amp;mut context.user_interfaces.first_mut().build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>This function could be used as-is to re-route rendering of a scene to an <code>Image</code> widget. It creates a new render target
first, then it assigns it to the scene, and also it creates a new <code>Image</code> widget with the render target as a texture.
A simple example of what this code does is the scene previewer in the editor:</p>
<p><img src="ui/rerouting.png" alt="rerouting" /></p>
<p>If you set <code>width</code> and <code>height</code> to match your screen size, you'll create a simple "overlay" that will allow you to
render scene entities on top of the UI. In this case, however, you also need to configure scene camera accordingly,
and probably use orthographic projection so the coordinates would match.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="font"><a class="header" href="#font">Font</a></h1>
<p>Font is used to store graphical representation of unicode characters. The engine supports TTF and OTF fonts,
you can load pretty much any font from the internet and use it as is.</p>
<h2 id="create-new-font"><a class="header" href="#create-new-font">Create New Font</a></h2>
<p>There are two ways to create font instance - either load font from file, or load it directly from memory.</p>
<h3 id="loading-font-from-file"><a class="header" href="#loading-font-from-file">Loading Font From File</a></h3>
<p>Since every font in the engine is a resource, you can load fonts using standard resource manager like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_font_from_file(ctx: &amp;PluginContext) -&gt; Resource&lt;Font&gt; {
    ctx.resource_manager.request::&lt;Font&gt;("path/to/my/font")
}
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-font-from-memory"><a class="header" href="#creating-font-from-memory">Creating Font From Memory</a></h3>
<p>This option could be useful, if you already have your font loaded into memory. Loading font from data buffer is
very simple:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_font_from_memory(data: Vec&lt;u8&gt;) -&gt; Resource&lt;Font&gt; {
    Resource::new_ok(
        ResourceKind::Embedded,
        Font::from_memory(data, 1024).unwrap(),
    )
}
<span class="boring">}</span></code></pre></pre>
<p><code>data</code> input parameter could be a buffer that contains any valid TTF/OTF font. For example, you can load TTF file into
a data buffer and create font using the data buffer:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_font_from_file_memory() -&gt; Resource&lt;Font&gt; {
    let mut data = Vec::new();
    File::open("path/to/your/font.ttf")
        .unwrap()
        .read_to_end(&amp;mut data)
        .unwrap();

    Resource::new_ok(
        ResourceKind::Embedded,
        Font::from_memory(data, 1024).unwrap(),
    )
}
<span class="boring">}</span></code></pre></pre>
<h2 id="default-font"><a class="header" href="#default-font">Default Font</a></h2>
<p>User interface provides its own font of fixed size, it is enough to cover most of the use cases, but the default font
includes only ASCII characters, if you need extended character set, you can replace default font using the following
code snippet:</p>
<pre><pre class="playground"><code class="language-rust  no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_default_font(ui: &amp;mut UserInterface, resource_manager: &amp;ResourceManager) {
    ui.default_font = resource_manager.request::&lt;Font&gt;("path/to/my/font");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-to-change-font-size"><a class="header" href="#how-to-change-font-size">How to Change Font Size</a></h2>
<p>All you need to do is to set font size in your Text or TextBox widgets like so:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn text(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_text("Some text")
        .with_font_size(30.0.into()) // Sets the desired font size.
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>You can also change the font size at runtime using <code>TextMessage::FontSize</code> message like so:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_font_size(text: Handle&lt;UiNode&gt;, ui: &amp;UserInterface, new_font_size: f32) {
    ui.send_message(TextMessage::font_size(
        text,
        MessageDirection::ToWidget,
        new_font_size.into(),
    ))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="important-notes"><a class="header" href="#important-notes">Important notes</a></h2>
<p>Internally, font may use a number of texture atlases to pack all glyphs into a single texture. Font system creates
a new atlas for every glyph size. Each atlas could be split into multiple pages, which essentially just a texture
of a fixed size. Such paging is needed, because there's a hardware limit of maximum texture size on video cards and
instead of praying that everything fits into a single page, the engine automatically adds a new page if none of the
previous cannot fit a new character.</p>
<p>Keep in mind, that when you create a font, its atlases are empty. They're filled on demand when you try to use
a character that wasn't used previously.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styles"><a class="header" href="#styles">Styles</a></h1>
<p>The engine has an ability to customize the appearance of widgets, however it is not centralized, and has to be done
per widget. Check <code>Style</code> section of each widget (keep in mind that some of the widgets does not support custom styles,
mainly because they were made in a hurry).</p>
<p>In general, styling of widgets could be performed by replacing parts of a widget with your own. For example, a button by default
uses <a href="ui/./decorator.html">Decorator</a> widget as its background, which in its turn uses simple set of brushes to control
internal <a href="ui/./border.html">Border</a> widget's parameters, such as background and foreground colors. This is ok if you're
creating some tools, where you don't need bells and whistles. However, buttons in games could be of any shape, color,
have any kind of animations and so on. For this reason, <code>Button</code> widget allows you to change background widget with
your own. So, imagine that you have a button template with two images that represents its state - <code>Pressed</code> and <code>Normal</code>.
In this case you could create a custom widget, that will render different images depending on pressed state and use
this widget as a background widget of your button.</p>
<p>The same applies to pretty much every other widget, for example <a href="ui/./checkbox/check_box.html">CheckBox</a> allows you to change
check marks for every of three states as well as a widget that is used as a background.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets-1"><a class="header" href="#widgets-1">Widgets</a></h1>
<p>The subsections of this chapter explains how to use every widget built into Fyrox. The widgets in the table of contents
to the left are ordered in alphebetical order. However, below we will order them by primary function to help introduce
them to new users.</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>The Container widgets primary purpose is to contain other widgets. They are mostly used as a tool to layout the UI in
visually different ways.</p>
<ul>
<li><a href="ui/./stack_panel.html">Stack panel</a>: The Stack Panel arranges widgets in a linear fashion, either vertically or horizontally depending
on how it's setup.</li>
<li><a href="ui/./wrap_panel.html">Wrap Panel</a>: The Wrap Panel arranges widgets in a linear fashion but if it overflows the widgets are continued
adjacent to the first line. Can arrange widgets either vertically or horizontally depending on how it's setup.</li>
<li><a href="ui/./grid.html">Grid</a>: The Grid arranges widgets into rows and columns with given size constraints.</li>
<li><a href="ui/./canvas.html">Canvas</a>: The Canvas arranges widgets with pixel perfect precision.\</li>
<li><a href="ui/./window.html">Window</a>: The Window holds other widgets in a panel that can be configured at setup to be move-able, expanded and
contracted via user input, exited, and have a displayed label. The window has a title bar to assist with these features.
<ul>
<li><a href="ui/./message_box.html">Message Box</a>: The Message Box is a Window that has been streamlined to show standard confirmation/information
dialogues, for example, closing a document with unsaved changes. It has a title, some text, and a fixed set of buttons
(Yes, No, Cancel in different combinations).</li>
</ul>
</li>
<li><a href="ui/./menu.html">Menu</a>: The Menu is a root container for Menu Items, an example could be a menu strip with File, Edit, View,
etc. items.</li>
<li><a href="ui/./popup.html">Popup</a>: The Popup is a panel that locks input to its content while it is open. A simple example of it could
be a context menu.</li>
<li><a href="ui/./scroll_viewer.html">Scroll Viewer</a>: The ScrollViewer is a wrapper for Scroll Panel that adds two scroll bars to it.
<ul>
<li><a href="ui/./scroll_panel.html">Scroll Panel</a>: The Scroll Panel is a panel that allows you to apply some offset to children widgets. It is
used to create "scrollable" area in conjunction with the Scroll Viewer.</li>
</ul>
</li>
<li><a href="ui/./expander.html">Expander</a>: The Expander handles hiding and showing multiple panels of widgets in an according style UI element.
Multiple panels can be shown or hidden at any time based on user input.</li>
<li><a href="ui/./tab_control.html">Tab Control</a>: The Tab Control handles hiding several panels of widgets, only showing the one that the user has
selected.</li>
<li><a href="ui/./dock.html">Docking Manager</a>: The Docking manager allows you to dock windows and hold them in-place.</li>
<li><a href="ui/./tree.html">Tree</a>: The Tree allows you to create views for hierarchical data.</li>
<li><a href="ui/./screen.html">Screen</a>: Screen is a widget that always has the size of the screen of the UI in which it is used.</li>
</ul>
<h2 id="visual"><a class="header" href="#visual">Visual</a></h2>
<p>The Visual widgets primary purpose is to provide the user feedback generally without the user directly interacting with them.</p>
<ul>
<li><a href="ui/./text.html">Text</a>: The Text widget is used to display a string to the user.</li>
<li><a href="ui/./image.html">Image</a>: The Image widget is used to display a pixel image to the user.</li>
<li><a href="ui/./vector_image.html">Vector Image</a>: The Vector Image is used to render vector instructions as a graphical element.</li>
<li><a href="ui/./rect.html">Rect</a>: The Rect allows you to specify numeric values for X, Y, Width, and Height of a rectangle.</li>
<li><a href="ui/./progress_bar.html">Progress Bar</a>: The Progress Bar shows a bar whoes fill state can be adjusted to indicate visually how full
something is, for example how close to 100% is a loading process.</li>
<li><a href="ui/./decorator.html">Decorator</a>: The Decorator is used to style any widget. It has support for different styles depending on various
events like mouse hover or click.
<ul>
<li><a href="ui/./border.html">Border</a>: The Border widget is used in conjunction with the Decorator widget to provide configurable boarders
to any widget for styling purposes.</li>
</ul>
</li>
</ul>
<h2 id="controls-1"><a class="header" href="#controls-1">Controls</a></h2>
<p>Control widgets primary purpose is to provide users with intractable UI elements to control some aspect of the program.</p>
<ul>
<li><a href="ui/./button.html">Button</a>: The Button provides a press-able control that can contain other UI elements, for example a Text or Image Widget.</li>
<li><a href="ui/./checkbox/check_box.html">Check Box</a>: The CheckBox is a toggle-able control that can contain other UI elements, for example a Text or Image Widget.</li>
<li><a href="ui/./text_box.html">Text Box</a>: The Text Box is a control that allows the editing of text.</li>
<li><a href="ui/./scroll_bar.html">Scroll Bar</a>: The Scroll Bar provides a scroll bar like control that can be used on its own as a data input or
with certain other widgets to provide content scrolling capabilities.</li>
<li><a href="ui/./numeric.html">Numeric Field</a>: The Numeric Field provides the ability to adjust a number via increment and decrement buttons or
direct input. The number can be constrained to remain inside a specific range or have a specific step.</li>
<li><a href="ui/./range.html">Range</a>: The Range allows the user to edit a numeric range - specify its beginning and end values.</li>
<li><a href="ui/./list_view.html">List View</a>: The List View provides a control where users can select from a list of items.</li>
<li><a href="ui/./dropdown_list.html">Dropdown List</a>: The Drop-down List is a control which shows the currently selected item and provides a drop-down
list to select an item.</li>
<li><a href="ui/./file_browser.html">File Browser</a>: The File Browser is a tree view of the file system allowing the user to select a file or folder.</li>
<li><a href="ui/./curve_editor.html">Curve Editor</a>: The CurveEditor allows editing parametric curves - adding points, and setting up transitions
(constant, linear, cubic) between them.</li>
<li><a href="ui/./inspector.html">Inspector</a>: The Inspector automatically creates and handles the input of UI elements based on a populated
Inspector Context given to it allowing the user to adjust values of a variety of models without manually creating UI's
for each type.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-widget"><a class="header" href="#custom-widget">Custom Widget</a></h1>
<p>It is possible to create your own widgets, that could solve a specific task that couldn't be solved easily with the
widgets that the engine provides.</p>
<p>Let's say, for instance, that we need to have a custom button with specific visual effects. It will have a border and
a text, and it will also react to mouse events:</p>
<p><img src="ui/custom_widget.gif" alt="custom widget" /></p>
<p>A "skeleton" of such widget could be something like this (for now it does nothing):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "e3b067e1-f3d8-4bac-a272-3c9edd960bf3")]
struct MyButtonExample {
    widget: Widget,
    border: Handle&lt;UiNode&gt;,
    text: Handle&lt;UiNode&gt;,
}

define_widget_deref!(MyButtonExample);

impl Control for MyButtonExample {
    fn handle_routed_message(&amp;mut self, ui: &amp;mut UserInterface, message: &amp;mut UiMessage) {
        // Pass another message to the base widget first.
        self.widget.handle_routed_message(ui, message);
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum MyButtonMessage {
    // A message, that will be emitted when our button is clicked.
    Click,
}

impl MyButtonMessage {
    // A constructor for `Click` message.
    define_constructor!(
        MyButtonMessage:Click =&gt; fn click(), layout: false
    );
}

#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "e3b067e1-f3d8-4bac-a272-3c9edd960bf3")]
struct MyButton {
    widget: Widget,
    border: Handle&lt;UiNode&gt;,
    text: Handle&lt;UiNode&gt;,
}

define_widget_deref!(MyButton);

impl MyButton {
    fn set_colors(&amp;self, ui: &amp;UserInterface, text_color: Color, border_color: Color) {
        for (handle, color) in [(self.border, border_color), (self.text, text_color)] {
            ui.send_message(WidgetMessage::foreground(
                handle,
                MessageDirection::ToWidget,
                Brush::Solid(color).into(),
            ));
        }

        // Make the fill brush of the border slightly dimmer than the input value.
        let mut border_color = Hsv::from(border_color);
        border_color.set_brightness(border_color.brightness() - 20.0);
        ui.send_message(WidgetMessage::background(
            self.border,
            MessageDirection::ToWidget,
            Brush::Solid(border_color.into()).into(),
        ));
    }
}

impl Control for MyButton {
    fn handle_routed_message(&amp;mut self, ui: &amp;mut UserInterface, message: &amp;mut UiMessage) {
        // Pass another message to the base widget first.
        self.widget.handle_routed_message(ui, message);

        // Then process it in our widget.
        if let Some(msg) = message.data::&lt;WidgetMessage&gt;() {
            if message.destination() == self.handle()
                || self.has_descendant(message.destination(), ui)
            {
                match msg {
                    WidgetMessage::MouseUp { .. } =&gt; {
                        // Send the message to outside world, saying that the button was clicked.
                        ui.send_message(MyButtonMessage::click(
                            self.handle(),
                            MessageDirection::FromWidget,
                        ));
                        ui.release_mouse_capture();
                    }
                    WidgetMessage::MouseDown { .. } =&gt; {
                        ui.capture_mouse(message.destination());
                    }
                    WidgetMessage::MouseEnter =&gt; {
                        // Make both the border and text brighter when the mouse enter the bounds of our button.
                        self.set_colors(
                            ui,
                            Color::opaque(220, 220, 220),
                            Color::opaque(140, 140, 140),
                        );
                    }
                    WidgetMessage::MouseLeave =&gt; {
                        // Make both the border and text dimmer when the mouse leaves the bounds of our button.
                        self.set_colors(
                            ui,
                            Color::opaque(120, 120, 120),
                            Color::opaque(100, 100, 100),
                        );
                    }
                    _ =&gt; (),
                }
            }
        }
    }
}

pub struct MyButtonBuilder {
    widget_builder: WidgetBuilder,
    // Some text of our button.
    text: String,
}

impl MyButtonBuilder {
    pub fn new(widget_builder: WidgetBuilder) -&gt; Self {
        Self {
            widget_builder,
            text: Default::default(),
        }
    }

    pub fn with_text(mut self, text: String) -&gt; Self {
        self.text = text;
        self
    }

    pub fn build(self, ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
        let text = TextBuilder::new(
            WidgetBuilder::new()
                .with_vertical_alignment(VerticalAlignment::Center)
                .with_horizontal_alignment(HorizontalAlignment::Center),
        )
        .with_text(self.text)
        .build(ctx);

        let border = BorderBuilder::new(WidgetBuilder::new().with_child(text))
            .with_stroke_thickness(Thickness::uniform(2.0).into())
            .build(ctx);

        let button = MyButton {
            widget: self.widget_builder.with_child(border).build(ctx),
            border,
            text,
        };

        ctx.add_node(UiNode::new(button))
    }
}

fn my_button_builder_usage(ctx: &amp;mut BuildContext) {
    MyButtonBuilder::new(WidgetBuilder::new().with_width(200.0).with_height(32.0))
        .with_text("Click Me!".to_string())
        .build(ctx);
}

#[derive(Default, Visit, Reflect, Debug)]
struct MyPlugin {
    my_button: Handle&lt;UiNode&gt;,
}

impl Plugin for MyPlugin {
    fn on_ui_message(&amp;mut self, context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if message.destination() == self.my_button {
            if let Some(MyButtonMessage::Click) = message.data() {
                // Do something.
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Every widget in the engine must have an instance of <code>Widget</code> (<code>widget: Widget</code> field) type in them and implement the
<code>Control</code> trait with two required methods. <code>query_component</code> is used for dynamic component fetching and could be used
to support behavior mix-ins and support derived widgets, that based on some other widgets. There's a lot more of
available methods in the <code>Control</code> trait, however for simplicity we won't use it in this chapter.</p>
<p><code>handle_routed_message</code> is used to react to various messages, but only in the <code>child -&gt; parent -&gt; parent_of_parent -&gt; ...</code>
chain. For example, if some of the child widget of our button will receive a message, it will also be passed to our button,
then to a parent of our button (if any), etc. This routing strategy is called "bubble" routing (it acts like a bubble of
air in the water; it always goes up). See <a href="ui/basic_concepts/basic_concepts.html#message-routing-strategies">this section</a> for
more info.</p>
<h2 id="custom-logic"><a class="header" href="#custom-logic">Custom Logic</a></h2>
<p>Now let's add some logic to the button, that will handle various mouse events. The full version of our button widget's
logic will be like so:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq)]
pub enum MyButtonMessage {
    // A message, that will be emitted when our button is clicked.
    Click,
}

impl MyButtonMessage {
    // A constructor for `Click` message.
    define_constructor!(
        MyButtonMessage:Click =&gt; fn click(), layout: false
    );
}

#[derive(Clone, Debug, Reflect, Visit, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "e3b067e1-f3d8-4bac-a272-3c9edd960bf3")]
struct MyButton {
    widget: Widget,
    border: Handle&lt;UiNode&gt;,
    text: Handle&lt;UiNode&gt;,
}

define_widget_deref!(MyButton);

impl MyButton {
    fn set_colors(&amp;self, ui: &amp;UserInterface, text_color: Color, border_color: Color) {
        for (handle, color) in [(self.border, border_color), (self.text, text_color)] {
            ui.send_message(WidgetMessage::foreground(
                handle,
                MessageDirection::ToWidget,
                Brush::Solid(color).into(),
            ));
        }

        // Make the fill brush of the border slightly dimmer than the input value.
        let mut border_color = Hsv::from(border_color);
        border_color.set_brightness(border_color.brightness() - 20.0);
        ui.send_message(WidgetMessage::background(
            self.border,
            MessageDirection::ToWidget,
            Brush::Solid(border_color.into()).into(),
        ));
    }
}

impl Control for MyButton {
    fn handle_routed_message(&amp;mut self, ui: &amp;mut UserInterface, message: &amp;mut UiMessage) {
        // Pass another message to the base widget first.
        self.widget.handle_routed_message(ui, message);

        // Then process it in our widget.
        if let Some(msg) = message.data::&lt;WidgetMessage&gt;() {
            if message.destination() == self.handle()
                || self.has_descendant(message.destination(), ui)
            {
                match msg {
                    WidgetMessage::MouseUp { .. } =&gt; {
                        // Send the message to outside world, saying that the button was clicked.
                        ui.send_message(MyButtonMessage::click(
                            self.handle(),
                            MessageDirection::FromWidget,
                        ));
                        ui.release_mouse_capture();
                    }
                    WidgetMessage::MouseDown { .. } =&gt; {
                        ui.capture_mouse(message.destination());
                    }
                    WidgetMessage::MouseEnter =&gt; {
                        // Make both the border and text brighter when the mouse enter the bounds of our button.
                        self.set_colors(
                            ui,
                            Color::opaque(220, 220, 220),
                            Color::opaque(140, 140, 140),
                        );
                    }
                    WidgetMessage::MouseLeave =&gt; {
                        // Make both the border and text dimmer when the mouse leaves the bounds of our button.
                        self.set_colors(
                            ui,
                            Color::opaque(120, 120, 120),
                            Color::opaque(100, 100, 100),
                        );
                    }
                    _ =&gt; (),
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, the most of the code was placed in <code>handle_routed_message</code>, we using it to respond for four messages:
<code>MouseDown</code> + <code>MouseUp</code>, <code>MouseEnter</code> + <code>MouseLeave</code>. Let's look closely at each pair of the messages.</p>
<p>The first two messages is used to handle clicks and send appropriate message to the outside world if a click has happened.
When you're sending a message, it is not immediately processed, instead it is put in the common message queue and will
be processed by the engine later. You can react to such messages to perform a desired action, see
<a href="ui/custom.html#reacting-to-click-messages">the section below</a> for more info.</p>
<p>The last two events are used to alter the visual appearance of the button by changing the colors of both the border and
the text. The source code above is very simple and straightforward, despite the look of it.</p>
<h2 id="builder"><a class="header" href="#builder">Builder</a></h2>
<p>Did you notice, that we didn't assign anything to <code>border</code> and <code>text</code> handles in our button widget? It is because, we
haven't made a respective builder for our button. Builder is a separate structure, that collects all the info from
the outside world and "compiles" it into a finished widget. Usually, widgets contains a bunch of children widgets, which
in their turn could have their own children and so on. In our case, the button will have two child widgets: a border and
a text.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyButtonBuilder {
    widget_builder: WidgetBuilder,
    // Some text of our button.
    text: String,
}

impl MyButtonBuilder {
    pub fn new(widget_builder: WidgetBuilder) -&gt; Self {
        Self {
            widget_builder,
            text: Default::default(),
        }
    }

    pub fn with_text(mut self, text: String) -&gt; Self {
        self.text = text;
        self
    }

    pub fn build(self, ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
        let text = TextBuilder::new(
            WidgetBuilder::new()
                .with_vertical_alignment(VerticalAlignment::Center)
                .with_horizontal_alignment(HorizontalAlignment::Center),
        )
        .with_text(self.text)
        .build(ctx);

        let border = BorderBuilder::new(WidgetBuilder::new().with_child(text))
            .with_stroke_thickness(Thickness::uniform(2.0).into())
            .build(ctx);

        let button = MyButton {
            widget: self.widget_builder.with_child(border).build(ctx),
            border,
            text,
        };

        ctx.add_node(UiNode::new(button))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is how a button is created, at first we're creating a border widget instance with a text widget as a child of it.
Text widget uses the actual text string from our builder, and also it sets the desired alignment in parent border's
bounds. Finally, we're initializing an instance of <code>MyButton</code> with the handles of the widget we've just made and as
the last step we're adding the widget to the user interface.</p>
<h2 id="using-the-builder"><a class="header" href="#using-the-builder">Using the Builder</a></h2>
<p>The widget could be created using the builder we've just made like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_button_builder_usage(ctx: &amp;mut BuildContext) {
    MyButtonBuilder::new(WidgetBuilder::new().with_width(200.0).with_height(32.0))
        .with_text("Click Me!".to_string())
        .build(ctx);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="reacting-to-click-messages"><a class="header" href="#reacting-to-click-messages">Reacting to Click Messages</a></h2>
<p>Our button sends a <code>Click</code> message every time when it was pressed, and we can use this message to perform some actions
in an application. All you need to do is to catch <code>MyButtonMessage::Click</code> in <code>Plugin::on_ui_message</code> and do something
in response:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Visit, Reflect, Debug)]
struct MyPlugin {
    my_button: Handle&lt;UiNode&gt;,
}

impl Plugin for MyPlugin {
    fn on_ui_message(&amp;mut self, context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if message.destination() == self.my_button {
            if let Some(MyButtonMessage::Click) = message.data() {
                // Do something.
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-widget-or-composition-of-widgets"><a class="header" href="#custom-widget-or-composition-of-widgets">Custom widget or composition of widgets.</a></h2>
<p>When do you need a custom widget? The answer depends on the use case, but the general rules here is quite simple:</p>
<ul>
<li>If your widget exist in a single instance, then there is no need to create a custom widget for it.</li>
<li>If you need to create multiple instances of your widget, and each widget will carry some specific data, then you
definitely need a custom widget.</li>
</ul>
<p>Custom widgets have some limitations that could be limiting, one of them is that custom widgets do not have
access to your code, since they're "living" inside UI and know nothing about the "environment" where they're
being used.</p>
<h2 id="source-code-and-web-demo"><a class="header" href="#source-code-and-web-demo">Source Code and Web Demo</a></h2>
<p>Full source code for this chapter can be found <a href="https://github.com/FyroxEngine/Fyrox-demo-projects/blob/main/ui/game/src/custom.rs">here</a>
, and you can also run <a href="https://fyrox.rs/assets/demo/ui/index.html">web demo</a> to see it in action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<p><img src="ui/button.png" alt="buttons" /></p>
<h2 id="simple-button-with-text"><a class="header" href="#simple-button-with-text">Simple button with text</a></h2>
<p>To create a simple button with text you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(WidgetBuilder::new())
        .with_text("Click me!")
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>How to create a button using custom dimensions (100x100) and custom text alignment (Vertical centered and Horizontal
right aligned):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_button_custom(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(WidgetBuilder::new().with_width(100.0).with_height(100.0))
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text("Click me!")
                .with_horizontal_text_alignment(HorizontalAlignment::Right)
                .with_vertical_text_alignment(VerticalAlignment::Center)
                .build(&amp;mut ui.build_ctx()),
        )
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="a-button-with-image"><a class="header" href="#a-button-with-image">A button with image</a></h2>
<p>More fancy-looking button with an image as a background could be created using this code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fancy_button(
    ui: &amp;mut UserInterface,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    ButtonBuilder::new(WidgetBuilder::new())
        .with_back(
            ImageBuilder::new(WidgetBuilder::new())
                .with_texture(resource_manager.request::&lt;Texture&gt;("path/to/your/texture"))
                .build(ctx),
        )
        .with_text("Click me!")
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-handling"><a class="header" href="#message-handling">Message handling</a></h2>
<p>When clicked, a button sends a <code>ButtonMessage::Click</code> message, you can catch it in your code and do something
useful:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Reflect, Visit)]
struct MyGame {
    button: Handle&lt;UiNode&gt;,
}

impl Plugin for MyGame {
    fn on_ui_message(&amp;mut self, _context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.button {
                //
                // Insert your code clicking handling code here.
                //
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-a-button-to-exit-the-game"><a class="header" href="#using-a-button-to-exit-the-game">Using a button to exit the game</a></h2>
<p>This example shows how to create a button that will close your game.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct Game {
    quit_button_handle: Handle&lt;UiNode&gt;,
}

fn create_quit_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(WidgetBuilder::new())
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text("Quit")
                .build(&amp;mut ui.build_ctx()),
        )
        .build(&amp;mut ui.build_ctx())
}

impl Game {
    fn new(ctx: PluginContext) -&gt; Self {
        Self {
            quit_button_handle: create_quit_button(ctx.user_interfaces.first_mut()),
        }
    }
}

impl Plugin for Game {
    fn on_ui_message(&amp;mut self, context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.quit_button_handle {
                if let Some(window_target) = context.window_target {
                    window_target.exit();
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="border"><a class="header" href="#border">Border</a></h1>
<p>The Border widget provides a stylized, static border around its child widget. Below is an example of creating a 1 pixel
thick border around a button widget:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_border_with_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    BorderBuilder::new(
        WidgetBuilder::new().with_child(
            TextBuilder::new(WidgetBuilder::new())
                .with_text("I'm boxed in!")
                .build(&amp;mut ui.build_ctx()),
        ),
    )
    //You can also use Thickness::uniform(1.0)
    .with_stroke_thickness(
        Thickness {
            left: 1.0,
            right: 1.0,
            top: 1.0,
            bottom: 1.0,
        }
        .into(),
    )
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>As with other UI elements, we create the border using the BorderBuilder helper struct. The widget that should have a
border around it is added as a child of the base WidgetBuilder, and the border thickness can be set by providing a
Thickness struct to the BorderBuilder's <em>with_stroke_thickness</em> function. This means you can set different thicknesses
for each edge of the border.</p>
<p>You can style the border by creating a Brush and setting the border's base WidgetBuilder's foreground or background.
The foreground will set the style of the boarder itself, while setting the background will color the whole area within
the border. Below is an example of a blue border and a red background with white text inside.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_blue_border_with_red_background(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    BorderBuilder::new(
        WidgetBuilder::new()
            .with_foreground(Brush::Solid(Color::opaque(0, 0, 200)).into())
            .with_background(Brush::Solid(Color::opaque(200, 0, 0)).into())
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("I'm boxed in Blue and backed in Red!")
                    .build(&amp;mut ui.build_ctx()),
            ),
    )
    .with_stroke_thickness(
        Thickness {
            left: 2.0,
            right: 2.0,
            top: 2.0,
            bottom: 2.0,
        }
        .into(),
    )
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas"><a class="header" href="#canvas">Canvas</a></h1>
<p><img src="ui/canvas.png" alt="canvas" /></p>
<p>Canvas is a panel widget that allows you to explicitly set coordinates for children widgets. It is useful when you
need to manually control position of children widgets (like potions on the image above). As any other panel widget, it
does not have its own graphical representation, so the image above shows only its positioning capabilities. Root UI node
is also canvas, so any widgets that are not attached to any other widgets can have explicit position.</p>
<h2 id="how-to-create-17"><a class="header" href="#how-to-create-17">How to create</a></h2>
<p>Use <code>CanvasBuilder</code> to create Canvas instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_canvas(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    CanvasBuilder::new(WidgetBuilder::new()).build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Canvas does not have any specific options, so its creation is probably simplest of all widgets.</p>
<h2 id="how-to-position-children-nodes"><a class="header" href="#how-to-position-children-nodes">How to position children nodes</a></h2>
<p>Use <code>.with_desired_position</code> on children widgets to set specific position:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_canvas_with_children_widgets(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    CanvasBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new().with_desired_position(Vector2::new(100.0, 200.0)),
                )
                .with_text("Simple Text at (100.0, 200.0)")
                .build(ctx),
            )
            .with_child(
                ButtonBuilder::new(
                    WidgetBuilder::new().with_desired_position(Vector2::new(200.0, 100.0)),
                )
                .with_text("Simple Button at (200.0, 100.0)")
                .build(ctx),
            ),
    )
    .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>The code snippet will create a canvas with a text widget located at (100.0, 200.0) relative to top-left corner of the
canvas and a button located at (200.0, 100.0).</p>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<p>Canvas provides infinite bounds for children widgets, this means that children nodes <strong>will not</strong> be stretched, instead
they'll shrink to fit their content. For example, a button with a text will take slightly bigger rectangle than the
text bounds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check-box"><a class="header" href="#check-box">Check box</a></h1>
<p>Checkbox is a UI widget that have three states - <code>Checked</code>, <code>Unchecked</code> and <code>Undefined</code>. In most cases it is used
only with two values which fits in <code>bool</code> type. Third, undefined, state is used for specific situations when your
data have such state.</p>
<h2 id="how-it-looks"><a class="header" href="#how-it-looks">How it looks</a></h2>
<p>Checkbox in <code>Checked</code> state:</p>
<p><img src="ui/checkbox/checked.PNG" alt="Checked" /></p>
<p>Checkbox in <code>Unchecked</code> state:</p>
<p><img src="ui/checkbox/unchecked.PNG" alt="Unchecked" /></p>
<h2 id="how-to-create-18"><a class="header" href="#how-to-create-18">How to create</a></h2>
<p>To create a checkbox you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_checkbox(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    CheckBoxBuilder::new(WidgetBuilder::new())
        // A custom value can be set during initialization.
        .checked(Some(true))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>The above code will create a checkbox without any textual info, but usually checkboxes have some useful info
near them. To create such checkbox, you could use <code>.with_content(..)</code> method which accepts any widget handle.
For checkbox with text, you could use <code>TextBuilder</code> to create textual content, for checkbox with text - use
<code>ImageBuilder</code>. As already said, you're free to use any widget handle there.</p>
<p>Here's an example of checkbox with textual content.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_checkbox_with_text(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    CheckBoxBuilder::new(WidgetBuilder::new())
        // A custom value can be set during initialization.
        .checked(Some(true))
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text("This is a checkbox")
                .build(ctx),
        )
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-handling-1"><a class="header" href="#message-handling-1">Message handling</a></h2>
<p>Checkboxes are not static widget and have multiple states. To handle a message from a checkbox, you need to handle
a <code>CheckBoxMessage::Check</code> message. To do so, you can do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug, Default)]
struct Game {
    checkbox: Handle&lt;UiNode&gt;,
}

impl Plugin for Game {
    fn on_ui_message(&amp;mut self, context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if let Some(CheckBoxMessage::Check(value)) = message.data() {
            if message.destination() == self.checkbox {
                //
                // Insert your clicking handling code here.
                //
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind that checkbox (as any other widget) generates <code>WidgetMessage</code> instances. You can catch them too and
do a custom handling if you need.</p>
<h2 id="theme"><a class="header" href="#theme">Theme</a></h2>
<p>Checkbox can be fully customized to have any look you want, there are few methods that will help you with
customization:</p>
<ol>
<li><code>.with_content(..)</code> - sets the content that will be shown near the checkbox.</li>
<li><code>.with_check_mark(..)</code> - sets the widget that will be used as checked icon.</li>
<li><code>.with_uncheck_mark(..)</code> - sets the widget that will be used as unchecked icon.</li>
<li><code>.with_undefined_mark(..)</code> - sets the widget that will be used as undefined icon.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curve-editor-wip"><a class="header" href="#curve-editor-wip">Curve editor (WIP)</a></h1>
<p><img src="ui/curve_editor.png" alt="curve editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorator"><a class="header" href="#decorator">Decorator</a></h1>
<p>A visual element that changes its appearance by listening specific events. It can have "pressed", "hover", "selected" or
normal appearance:</p>
<ul>
<li><code>Pressed</code> - enables on mouse down message.</li>
<li><code>Selected</code> - whether decorator selected or not.</li>
<li><code>Hovered</code> - mouse is over the decorator.</li>
<li><code>Normal</code> - not selected, pressed or hovered.</li>
</ul>
<p>This element is widely used to provide some generic visual behaviour for various widgets. For example, it used in
buttons, tree items, dropdown list items, etc.; in other words - everywhere where a widget needs to give visual
feedback the user.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_decorator(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    DecoratorBuilder::new(BorderBuilder::new(WidgetBuilder::new()))
        .with_hover_brush(Brush::Solid(Color::opaque(0, 255, 0)).into())
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docking-manager-wip"><a class="header" href="#docking-manager-wip">Docking manager (WIP)</a></h1>
<p><img src="ui/docking_manager.gif" alt="docking manager" /></p>
<p>Docking manager allows you to dock windows and hold them in-place.</p>
<p>Docking manager can hold any types of UI elements, but dragging works only
for windows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dropdown-list"><a class="header" href="#dropdown-list">Dropdown list</a></h1>
<p><img src="ui/dropdown_list.gif" alt="dropdown list" /></p>
<p>Drop-down list is a control which shows the currently selected item and provides a dropdown
list to select its current item. It is used to show a single selected item in a compact way.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>A dropdown list with two text items with the last one selected, could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_drop_down_list(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    DropdownListBuilder::new(WidgetBuilder::new())
        .with_items(vec![
            TextBuilder::new(WidgetBuilder::new())
                .with_text("Item 0")
                .build(ctx),
            TextBuilder::new(WidgetBuilder::new())
                .with_text("Item 1")
                .build(ctx),
        ])
        .with_selected(1)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that items of a dropdown list could be any widget, but usually each item is wrapped
in some other widget that shows the current state of items (selected, hovered, clicked, etc.). One
of the most convenient ways of doing this is to use Decorator widget:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_item(text: &amp;str, ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    DecoratorBuilder::new(BorderBuilder::new(
        WidgetBuilder::new().with_child(
            TextBuilder::new(WidgetBuilder::new())
                .with_text(text)
                .build(ctx),
        ),
    ))
    .build(ctx)
}

fn create_drop_down_list_with_decorators(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    DropdownListBuilder::new(WidgetBuilder::new())
        .with_items(vec![make_item("Item 0", ctx), make_item("Item 1", ctx)])
        .with_selected(1)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="selection"><a class="header" href="#selection">Selection</a></h2>
<p>Dropdown list supports two kinds of selection - <code>None</code> or <code>Some(index)</code>. To catch a moment when
selection changes, use the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    dropdown_list: Handle&lt;UiNode&gt;,
}

impl Foo {
    fn on_ui_message(&amp;mut self, message: &amp;UiMessage) {
        if let Some(DropdownListMessage::SelectionChanged(new_selection)) = message.data() {
            if message.destination() == self.dropdown_list
                &amp;&amp; message.direction() == MessageDirection::FromWidget
            {
                // Do something.
                dbg!(new_selection);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To change selection of a dropdown list, send <code>DropdownListMessage::SelectionChanged</code> message
to it.</p>
<h2 id="items"><a class="header" href="#items">Items</a></h2>
<p>To change current items of a dropdown list, create the items first and then send them to the
dropdown list using <code>DropdownListMessage::Items</code> message.</p>
<h2 id="opening-and-closing"><a class="header" href="#opening-and-closing">Opening and Closing</a></h2>
<p>A dropdown list could be opened and closed manually using <code>DropdownListMessage::Open</code> and
<code>DropdownListMessage::Close</code> messages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expander"><a class="header" href="#expander">Expander</a></h1>
<p><img src="ui/expander.gif" alt="expander" /></p>
<p>Expander is a simple collapsible container that has a header and collapsible/expandable content zone. It is used to
create collapsible regions with headers.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>The following example creates a simple expander with a textual header and a stack panel widget with few
buttons a content:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_expander(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    ExpanderBuilder::new(WidgetBuilder::new())
        // Header is visible all the time.
        .with_header(
            TextBuilder::new(WidgetBuilder::new())
                .with_text("Foobar")
                .build(ctx),
        )
        // Define a content of collapsible area.
        .with_content(
            StackPanelBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ButtonBuilder::new(WidgetBuilder::new())
                            .with_text("Button 1")
                            .build(ctx),
                    )
                    .with_child(
                        ButtonBuilder::new(WidgetBuilder::new())
                            .with_text("Button 2")
                            .build(ctx),
                    ),
            )
            .build(ctx),
        )
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="customization"><a class="header" href="#customization">Customization</a></h2>
<p>It is possible to completely change the arrow of the header of the expander. By default, the arrow consists
of <code>crate::check_box::CheckBox</code> widget. By changing the arrow, you can customize the look of the header.
For example, you can set the new check box with image check marks, which will use custom graphics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_expander_with_image(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    ExpanderBuilder::new(WidgetBuilder::new())
        .with_checkbox(
            CheckBoxBuilder::new(WidgetBuilder::new())
                .with_check_mark(
                    ImageBuilder::new(WidgetBuilder::new().with_height(16.0).with_height(16.0))
                        .with_opt_texture(None) // Set this to required image.
                        .build(ctx),
                )
                .with_uncheck_mark(
                    ImageBuilder::new(WidgetBuilder::new().with_height(16.0).with_height(16.0))
                        .with_opt_texture(None) // Set this to required image.
                        .build(ctx),
                )
                .build(ctx),
        )
        // The rest is omitted.
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="messages-1"><a class="header" href="#messages-1">Messages</a></h2>
<p>Use <code>ExpanderMessage::Expand</code> message to catch the moment when its state changes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug, Default)]
struct Game {
    expander: Handle&lt;UiNode&gt;,
}

impl Plugin for Game {
    fn on_ui_message(&amp;mut self, context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if let Some(ExpanderMessage::Expand(expanded)) = message.data() {
            if message.destination() == self.expander
                &amp;&amp; message.direction() == MessageDirection::FromWidget
            {
                println!(
                    "{} expander has changed its state to {}!",
                    message.destination(),
                    expanded
                );
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To switch expander state at runtime, send <code>ExpanderMessage::Expand</code> to your Expander widget instance with
<code>MessageDirection::ToWidget</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-browser-wip"><a class="header" href="#file-browser-wip">File browser (WIP)</a></h1>
<p><img src="ui/file_browser.gif" alt="file browser" /></p>
<p>FileBrowser widget is a simple file system tree, FileSelector is a window with FileBrowser and few buttons.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid"><a class="header" href="#grid">Grid</a></h1>
<p>Grids are one of several methods to position multiple widgets in relation to each other. A Grid Widget, as the name
implies, is able to position children widgets into a grid of specifically sized rows and columns.</p>
<p>Here is a simple example that positions several text widgets into a 2 by 2 grid:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_grid(ctx: &amp;mut BuildContext) -&gt; fyrox::core::pool::Handle&lt;UiNode&gt; {
    GridBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("top left ")
                    .build(ctx),
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new().on_column(1))
                    .with_text(" top right")
                    .build(ctx),
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new().on_row(1))
                    .with_text("bottom left ")
                    .build(ctx),
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new().on_row(1).on_column(1))
                    .with_text(" bottom right")
                    .build(ctx),
            ),
    )
    .add_row(GridDimension::auto())
    .add_row(GridDimension::auto())
    .add_column(GridDimension::auto())
    .add_column(GridDimension::auto())
    .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>As with other UI widgets, Grids are created via the GridBuilder struct. Each widget whose position should be controlled
by the Grid should be added as a child of the GridBuilder's base widget.</p>
<p>You then need to tell each child what row and column it belongs to via the on_column and on_row functions of their base
widget. By default, all children will be placed into row 0, column 0.</p>
<p>After that you need to provide sizing constraints for each row and column to the GridBuilder by using the add_row and
add_column functions while providing a GridDimension instance to the call. GridDimension can be constructed with the
following functions:</p>
<ul>
<li><code>GridDimension::auto()</code> - Sizes the row or column so it's just large enough to fit the largest child's size.</li>
<li><code>GridDimension::stretch()</code> - Stretches the row or column to fill the parent's available space, if multiple rows or
columns have this option the size is evenly distributed between them.</li>
<li><code>GridDimension::strict(f32)</code> - Sets the row or column to be exactly the given value of pixels long. So a row will only
be the given number of pixels wide, while a column will be that many pixels tall.</li>
</ul>
<p>You can add any number of rows and columns to a grid widget, and each grid cell does <strong>not</strong> need to have a UI widget
in it to be valid. For example, you can add a column and set it to a specific size via strict to provide spacing between
two other columns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<p><img src="ui/image.png" alt="image" /></p>
<p>Image widget is a rectangle with a texture, it is used draw custom bitmaps. The UI in the engine is vector-based, Image
widget is the only way to draw a bitmap. Usage of the Image is very simple:</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_image(ctx: &amp;mut BuildContext, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
    // You must explicitly set width and height of the image, otherwise it will collapse to a
    // point and you won't see anything.
    let width = 100.0;
    let height = 100.0;
    ImageBuilder::new(WidgetBuilder::new().with_width(width).with_height(height))
        .with_texture(
            // Ask resource manager to load a texture.
            resource_manager.request::&lt;Texture&gt;("path/to/your/texture.png"),
        )
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>There are one common pitfall when using Image widget - you must explicitly set width and height of the image if it is
not placed to some panel, that will stretch it automatically. In other words if you created an image with undefined
width and height, then putting it to some container like Grid' cell will stretch the image to fit cell bounds.</p>
<h2 id="equal-size-to-source"><a class="header" href="#equal-size-to-source">Equal Size to Source</a></h2>
<p>Sometimes you need your image to have equal size with the texture it uses, in this case you should fetch texture
bounds first and then create an Image width these bounds:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_image_equal_in_size_to_source(
    ctx: &amp;mut BuildContext&lt;'_&gt;,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    // Ask resource manager to load the texture and wait while it loads using `.await`.
    if let Ok(texture) = resource_manager
        .request::&lt;Texture&gt;("path/to/your/texture.png")
        .await
    {
        // A texture can be not only rectangular, so we must check that.
        let texture_kind = texture.data_ref().kind();
        if let TextureKind::Rectangle { width, height } = texture_kind {
            return ImageBuilder::new(
                WidgetBuilder::new()
                    .with_width(width as f32)
                    .with_height(height as f32),
            )
            .with_texture(texture)
            .build(ctx);
        }
    }

    // Image wasn't created.
    Handle::NONE
}
<span class="boring">}</span></code></pre></pre>
<p>This function can be used as-is whenever you need to create an Image that have same size as the source file. It is
marked as <code>async</code> because resource loading (texture is a resource) happens in separate thread and to get actual texture
data we must wait it. If you don't want to use async, then use any executor to block current thread and execute the
promise immediately:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_image_sync(
    ctx: &amp;mut BuildContext&lt;'_&gt;,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    fyrox::core::futures::executor::block_on(create_image_equal_in_size_to_source(
        ctx,
        resource_manager,
    ))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="vertical-flip"><a class="header" href="#vertical-flip">Vertical Flip</a></h2>
<p>In some rare cases you need to flip your source image before showing it, there is <code>.with_flip</code> option for that:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_flipped_image(
    ctx: &amp;mut BuildContext,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    ImageBuilder::new(WidgetBuilder::new().with_width(100.0).with_height(100.0))
        .with_flip(true) // Flips an image vertically
        .with_texture(resource_manager.request::&lt;Texture&gt;("path/to/your/texture.png"))
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>There are few places where it can be helpful:</p>
<ul>
<li>You're using render target as a source texture for your Image instance, render targets are vertically flipped due
to mismatch of coordinates of UI and graphics API. The UI has origin at left top corner, the graphics API - bottom left.</li>
<li>Your source image is vertically mirrored.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspector-wip"><a class="header" href="#inspector-wip">Inspector (WIP)</a></h1>
<p><img src="ui/inspector.png" alt="inspector" /></p>
<p>A widget that allows you to generate visual representation for arbitrary structures, that implement <code>Reflect</code> trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-view-wip"><a class="header" href="#list-view-wip">List view (WIP)</a></h1>
<p><img src="ui/list_view.gif" alt="list view" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="menu-wip"><a class="header" href="#menu-wip">Menu (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-box-wip"><a class="header" href="#message-box-wip">Message box (WIP)</a></h1>
<p><img src="ui/message_box.gif" alt="message box" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numericupdown-widget"><a class="header" href="#numericupdown-widget">NumericUpDown Widget</a></h1>
<p><img src="ui/numeric_up_down.gif" alt="numeric up down" /></p>
<p>A widget that handles numbers of any machine type. Use this widget if you need to provide input field for a numeric
type.</p>
<h2 id="how-to-create-19"><a class="header" href="#how-to-create-19">How to create</a></h2>
<p>Use <code>NumericUpDownBuilder</code> to create a new instance of the <code>NumericUpDown</code> widget:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_numeric_widget(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    NumericUpDownBuilder::new(WidgetBuilder::new())
        .with_value(123.0f32)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that this widget is generic and can work with any numeric types. Sometimes you might get an "unknown type"
error message from the compiler (especially if your use <code>123.0</code> ambiguous numeric literals), in this case you need to
specify the type explicitly (<code>NumericUpDownBuilder::&lt;f32&gt;::new...</code>).</p>
<h2 id="limits-1"><a class="header" href="#limits-1">Limits</a></h2>
<p>This widget supports lower and upper limits for the values. It can be specified by <code>NumericUpDownBuilder::with_min_value</code>
and <code>NumericUpDownBuilder::with_max_value</code> (or changed at runtime using <code>NumericUpDownMessage::MinValue</code> and <code>NumericUpDownMessage::MaxValue</code>
messages):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_numeric_widget_with_limits(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    NumericUpDownBuilder::new(WidgetBuilder::new())
        .with_value(123.0f32)
        .with_min_value(42.0)
        .with_max_value(666.0)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>The default limits for min and max are <code>NumericType::min_value</code> and <code>NumericType::max_value</code> respectively.</p>
<h2 id="step"><a class="header" href="#step">Step</a></h2>
<p>Since the value of the widget can be changed via up/down arrow buttons (also by dragging the cursor up or down on them), the widget
provides a way to set the step of the value (for increment and decrement at the same time):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_numeric_widget_with_step(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    NumericUpDownBuilder::new(WidgetBuilder::new())
        .with_value(125.0f32)
        .with_step(5.0)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>The default value of the step is <code>NumericType::one</code>.</p>
<h2 id="precision"><a class="header" href="#precision">Precision</a></h2>
<p>It is possible to specify <strong>visual</strong> rounding of the value up to desired decimal place (it does not change the way how
the actual value is rounded). For example, in some cases you might get irrational values such as <code>1/3 ~= 0.33333333</code>,
but you interested in only first two decimal places. In this case you can set the precision to <code>2</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_numeric_widget_with_precision(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    NumericUpDownBuilder::new(WidgetBuilder::new())
        .with_value(0.3333333f32)
        .with_precision(2)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="popup-wip"><a class="header" href="#popup-wip">Popup (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress-bar-wip"><a class="header" href="#progress-bar-wip">Progress bar (WIP)</a></h1>
<p><img src="ui/progress_bar.gif" alt="progress bar" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range-wip"><a class="header" href="#range-wip">Range (WIP)</a></h1>
<p><img src="ui/range_editor.gif" alt="range editor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rect-editor-wip"><a class="header" href="#rect-editor-wip">Rect editor (WIP)</a></h1>
<p><img src="ui/rect.gif" alt="rect" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-bar"><a class="header" href="#scroll-bar">Scroll bar</a></h1>
<p><img src="ui/scroll_bar.gif" alt="scroll bar" /></p>
<p>Scroll bar is used to represent a value on a finite range. It has a thumb that shows the current value on
on the bar. Usually it is used in pair with <code>ScrollPanel</code> to create something like
<code>ScrollViewer</code> widget. However, it could also be used to create sliders to show some
value that lies within some range.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<p>A simple example of how to create a new <code>ScrollBar</code> could be something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_scroll_bar(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    ScrollBarBuilder::new(WidgetBuilder::new())
        .with_min(0.0)
        .with_max(200.0)
        .with_value(123.0)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>It creates a horizontal scroll bar with <code>123.0</code> value and a range of <code>[0.0..200.0]</code>. To fetch the new value
of the scroll bar, use <code>ScrollBarMessage::Value</code> message:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug, Default)]
struct Game {
    scroll_bar: Handle&lt;UiNode&gt;,
}

impl Plugin for Game {
    fn on_ui_message(&amp;mut self, context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if let Some(ScrollBarMessage::Value(value)) = message.data() {
            if message.destination() == self.scroll_bar
                &amp;&amp; message.direction() == MessageDirection::FromWidget
            {
                //
                // Insert handler code here.
                //
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Please note, that you need to explicitly filter messages by <code>MessageDirection::FromWidget</code>, because it's the only
direction that is used as an "indicator" that the value was accepted by the scroll bar.</p>
<h2 id="orientation"><a class="header" href="#orientation">Orientation</a></h2>
<p>Scroll bar could be either horizontal (default) or vertical. You can select the orientation when building
a scroll bar using <code>ScrollBarBuilder::with_orientation</code> method and provide a desired value from <code>Orientation</code>
enum there.</p>
<h2 id="show-values"><a class="header" href="#show-values">Show values</a></h2>
<p>By default, scroll bar does not show its actual value, you can turn it on using <code>ScrollBarBuilder::show_value</code>
method with <code>true</code> as the first argument. To change rounding of the value, use <code>ScrollBarBuilder::with_value_precision</code>
and provide the desired number of decimal places there.</p>
<h2 id="step-1"><a class="header" href="#step-1">Step</a></h2>
<p>Scroll bar provides arrows to change the current value using a fixed step value. You can change it using
<code>ScrollBarBuilder::with_step</code> method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-panel"><a class="header" href="#scroll-panel">Scroll panel</a></h1>
<p>Scroll panel widget does the same as <a href="ui/scroll_viewer.html">Scroll Viewer</a> widget, but it does not have any additional
widgets and does not have any graphics. It is a panel widget that provides basic scrolling functionality and
<a href="ui/scroll_viewer.html">Scroll Viewer</a> is built on top of it. Strictly speaking, scroll panel widget is used to arrange its
children widgets, so they can be offset by a certain number of units from top-left corner. It is used to provide basic
scrolling functionality.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_scroll_panel(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    ScrollPanelBuilder::new(
        WidgetBuilder::new().with_child(
            GridBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ButtonBuilder::new(WidgetBuilder::new())
                            .with_text("Some Button")
                            .build(ctx),
                    )
                    .with_child(
                        ButtonBuilder::new(WidgetBuilder::new())
                            .with_text("Some Other Button")
                            .build(ctx),
                    ),
            )
            .add_row(Row::auto())
            .add_row(Row::auto())
            .add_column(Column::stretch())
            .build(ctx),
        ),
    )
    .with_scroll_value(Vector2::new(100.0, 200.0))
    .with_vertical_scroll_allowed(true)
    .with_horizontal_scroll_allowed(true)
    .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="scrolling"><a class="header" href="#scrolling">Scrolling</a></h2>
<p>Scrolling value for both axes can be set via <code>ScrollPanelMessage::VerticalScroll</code> and <code>ScrollPanelMessage::HorizontalScroll</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_scrolling_value(
    scroll_panel: Handle&lt;UiNode&gt;,
    horizontal: f32,
    vertical: f32,
    ui: &amp;UserInterface,
) {
    ui.send_message(ScrollPanelMessage::horizontal_scroll(
        scroll_panel,
        MessageDirection::ToWidget,
        horizontal,
    ));
    ui.send_message(ScrollPanelMessage::vertical_scroll(
        scroll_panel,
        MessageDirection::ToWidget,
        vertical,
    ));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="bringing-child-into-view"><a class="header" href="#bringing-child-into-view">Bringing child into view</a></h2>
<p>Calculates the scroll values to bring a desired child into view, it can be used for automatic navigation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bring_child_into_view(scroll_panel: Handle&lt;UiNode&gt;, child: Handle&lt;UiNode&gt;, ui: &amp;UserInterface) {
    ui.send_message(ScrollPanelMessage::bring_into_view(
        scroll_panel,
        MessageDirection::ToWidget,
        child,
    ))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-viewer"><a class="header" href="#scroll-viewer">Scroll viewer</a></h1>
<p><img src="ui/scroll_bar.gif" alt="scroll viewer" /></p>
<p>Scroll viewer is a scrollable region with two scroll bars for each axis. It is used to wrap a content of unknown
size to ensure that all of it will be accessible in its parent widget bounds. For example, it could be used in a
<a href="ui/window.html">Window</a> widget to allow a content of the window to be accessible, even if the window is smaller than
the content.</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<p>A scroll viewer widget could be created using <code>ScrollViewerBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_scroll_viewer(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    ScrollViewerBuilder::new(WidgetBuilder::new())
        .with_content(
            StackPanelBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ButtonBuilder::new(WidgetBuilder::new())
                            .with_text("Click Me!")
                            .build(ctx),
                    )
                    .with_child(
                        TextBuilder::new(WidgetBuilder::new())
                            .with_text("Some\nlong\ntext")
                            .build(ctx),
                    ),
            )
            .build(ctx),
        )
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that you can change the content of a scroll viewer at runtime using <code>ScrollViewerMessage::Content</code> message.</p>
<h2 id="scrolling-speed-and-controls"><a class="header" href="#scrolling-speed-and-controls">Scrolling Speed and Controls</a></h2>
<p>Scroll viewer can have an arbitrary scrolling speed for each axis. Scrolling is performed via mouse wheel and by default it
scrolls vertical axis, which can be changed by holding <code>Shift</code> key. Scrolling speed can be set during the build phase:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_scroll_viewer_with_speed(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    ScrollViewerBuilder::new(WidgetBuilder::new())
        // Set vertical scrolling speed twice as fast as default scrolling speed.
        .with_v_scroll_speed(60.0)
        // Set horizontal scrolling speed slightly lower than the default value (30.0).
        .with_h_scroll_speed(20.0)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Also, it could be set using <code>ScrollViewerMessage::HScrollSpeed</code> or <code>ScrollViewerMessage::VScrollSpeed</code> messages.</p>
<h2 id="bringing-a-child-into-view"><a class="header" href="#bringing-a-child-into-view">Bringing a child into view</a></h2>
<p>Calculates the scroll values to bring a desired child into view, it can be used for automatic navigation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bring_child_into_view(scroll_viewer: Handle&lt;UiNode&gt;, child: Handle&lt;UiNode&gt;, ui: &amp;UserInterface) {
    ui.send_message(ScrollViewerMessage::bring_into_view(
        scroll_viewer,
        MessageDirection::ToWidget,
        child,
    ))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="screen"><a class="header" href="#screen">Screen</a></h1>
<p><img src="ui/screen.gif" alt="screen widget" /></p>
<p>Screen is a widget that always has the size of the screen of the UI in which it is used. It is
main use case is to provide automatic layout functionality, that will always provide screen size
to its children widgets. This is needed, because the root node of any UI is <a href="ui/canvas.html">Canvas</a>
which provides infinite bounds as a layout constraint, thus making it impossible for automatic
fitting to the current screen size. For example, Screen widget could be used as a root node for
<a href="ui/grid.html">Grid</a> widget - in this case the grid instance will always have the size of the
screen and will automatically shrink or expand when the screen size changes. It is ideal choice if
you want to have some widgets always centered on screen (for example - crosshair, main menu of
your game, etc.).</p>
<h2 id="how-to-create-20"><a class="header" href="#how-to-create-20">How To Create</a></h2>
<p>There are two major ways to create a Screen widget - using the editor or by code.</p>
<h3 id="using-the-editor-2"><a class="header" href="#using-the-editor-2">Using the Editor</a></h3>
<p>Go to <code>Create -&gt; UI</code> menu and find <code>Screen</code> widget there, make sure it is a direct child of the
root node of the hierarchy. Alternatively, you can right-click on the root node in the hierarchy
and click <code>Create Child -&gt; Screen</code>. After that you can add any number of children nodes to it.
Screen widget does not have any special properties, so you do not need to tweak it at all.</p>
<h3 id="from-code-5"><a class="header" href="#from-code-5">From Code</a></h3>
<p>The following example creates a simple main menu of a game with just two buttons. The buttons
will always be centered in the current screen bounds. It creates something similar to the gif above,
but not so fancy.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_always_centered_game_menu(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    // Screen widget will provide current screen size to its Grid widget as a layout constraint,
    // thus making it fit to the current screen bounds.
    ScreenBuilder::new(
        WidgetBuilder::new().with_child(
            GridBuilder::new(
                WidgetBuilder::new()
                    .with_width(300.0)
                    .with_height(400.0)
                    .with_child(
                        // Buttons will be stacked one on top of another.
                        StackPanelBuilder::new(
                            WidgetBuilder::new()
                                .on_row(1)
                                .on_column(1)
                                .with_child(
                                    ButtonBuilder::new(WidgetBuilder::new())
                                        .with_text("New Game")
                                        .build(ctx),
                                )
                                .with_child(
                                    ButtonBuilder::new(WidgetBuilder::new())
                                        .with_text("Exit")
                                        .build(ctx),
                                ),
                        )
                        .build(ctx),
                    ),
            )
            // Split the grid into 3 rows and 3 columns. The center cell contain the stack panel
            // instance, that basically stacks main menu buttons one on top of another. The center
            // cell will also be always centered in screen bounds.
            .add_row(Row::stretch())
            .add_row(Row::auto())
            .add_row(Row::stretch())
            .add_column(Column::stretch())
            .add_column(Column::auto())
            .add_column(Column::stretch())
            .build(ctx),
        ),
    )
    .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-panel"><a class="header" href="#stack-panel">Stack Panel</a></h1>
<p>Stack Panels are one of several methods to position multiple widgets in relation to each other. A Stack Panel Widget
orders its children widgets linearly, aka in a stack of widgets, based on the order the widgets were added as children.
So the first widget added will be at the top or left most position, while each additional widget will descend from top to
bottom or continue from left most to right most. The below example code places 3 text widgets into a vertical stack:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_stack_panel(ctx: &amp;mut BuildContext) -&gt; fyrox::core::pool::Handle&lt;UiNode&gt; {
    StackPanelBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Top")
                    .build(ctx),
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Middle")
                    .build(ctx),
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Bottom")
                    .build(ctx),
            ),
    )
    .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see from the example, creating a Stack Panel uses the standard method for creating widgets. Create a new
StackPanelBuilder and provide it with a new WidgetBuilder. Adding widgets to the stack is done by adding children to
the StackBuilder's WidgetBuilder.</p>
<h2 id="stack-panel-orientation"><a class="header" href="#stack-panel-orientation">Stack Panel Orientation</a></h2>
<p>As has been indicated, Stack Panels can be oriented to order its children either Vertical, from top to bottom, or
Horizontal, Left most to right most. This is done using the StackPanelBuilder's with_orientation function providing it
with a gui::Orientation enum value. <strong>By default,</strong> all StackPanel's are Vertical.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_horizontal_stack_panel(ctx: &amp;mut BuildContext) -&gt; fyrox::core::pool::Handle&lt;UiNode&gt; {
    StackPanelBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Left")
                    .build(ctx),
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Middle")
                    .build(ctx),
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Right")
                    .build(ctx),
            ),
    )
    .with_orientation(Orientation::Horizontal)
    .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tab-control"><a class="header" href="#tab-control">Tab Control</a></h1>
<p>The Tab Control handles the visibility of several tabs, only showing a single tab that the user has selected via the
tab header buttons. Each tab is defined via a Tab Definition struct which takes two widgets, one representing the tab
header and the other representing the tab's contents.</p>
<p>The following example makes a 2 tab, Tab Control containing some simple text widgets:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_tab_control(ctx: &amp;mut BuildContext) {
    TabControlBuilder::new(WidgetBuilder::new())
        .with_tab(TabDefinition {
            header: TextBuilder::new(WidgetBuilder::new())
                .with_text("First")
                .build(ctx),
            content: TextBuilder::new(WidgetBuilder::new())
                .with_text("First tab's contents!")
                .build(ctx),
            can_be_closed: true,
            user_data: None,
        })
        .with_tab(TabDefinition {
            header: TextBuilder::new(WidgetBuilder::new())
                .with_text("Second")
                .build(ctx),
            content: TextBuilder::new(WidgetBuilder::new())
                .with_text("Second tab's contents!")
                .build(ctx),
            can_be_closed: true,
            user_data: None,
        })
        .build(ctx);
}
<span class="boring">}</span></code></pre></pre>
<p>As usual, we create the widget via the builder TabControlBuilder. Tabs are added via the <em>with_tab</em> function in the
order you want them to appear, passing each call to the function a directly constructed TabDefinition struct. Tab
headers will appear from left to right at the top with tab contents shown directly below the tabs. As usual, if no
constraints are given to the base WidgetBuilder of the TabControlBuilder, then the tab content area will resize to fit
whatever is in the current tab.</p>
<p>Each tab's content is made up of one widget, so to be useful you will want to use one of the container widgets to help
arrange additional widgets within the tab.</p>
<h2 id="tab-header-styling"><a class="header" href="#tab-header-styling">Tab Header Styling</a></h2>
<p>Notice that you can put any widget into the tab header, so if you want images to denote each tab you can add an Image
widget to each header, and if you want an image <em>and</em> some text you can insert a stack panel with an image on top and
text below it.</p>
<p>You will also likely want to style whatever widgets you add. As can be seen when running the code example above, the
tab headers are scrunched when there are no margins provided to your text widgets. Simply add something like the below
code example and you will get a decent look:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_tab_control_with_header(ctx: &amp;mut BuildContext) {
    TabControlBuilder::new(WidgetBuilder::new()).with_tab(TabDefinition {
        header: TextBuilder::new(WidgetBuilder::new().with_margin(Thickness::uniform(4.0)))
            .with_text("First")
            .build(ctx),
        content: TextBuilder::new(WidgetBuilder::new())
            .with_text("First tab's contents!")
            .build(ctx),
        can_be_closed: true,
        user_data: None,
    });
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p>Text is a simple widget that allows you to print text on screen. It has various options like word wrapping, text
alignment, and so on.</p>
<h2 id="how-to-create-21"><a class="header" href="#how-to-create-21">How to create</a></h2>
<p>An instance of the Text widget could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="text-alignment-and-word-wrapping"><a class="header" href="#text-alignment-and-word-wrapping">Text alignment and word wrapping</a></h2>
<p>There are various text alignment options for both vertical and horizontal axes. Typical alignment values are:
<code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal axis, and <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical axis. An instance of
centered text could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_centered_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_horizontal_text_alignment(HorizontalAlignment::Center)
        .with_vertical_text_alignment(VerticalAlignment::Center)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Long text is usually needs to wrap on available bounds, there are three possible options for word wrapping:
<code>NoWrap</code>, <code>Letter</code>, <code>Word</code>. An instance of text with word-based wrapping could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_with_word_wrap(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_wrap(WrapMode::Word)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>If you need to have a text with some background, you should use <a href="ui/./border.html">Border</a> widget as a parent widget of your
text. <strong>Caveat:</strong> <code>Widget::background</code> is ignored for <code>Text</code> widget!</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_with_background(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    let text_widget =
        TextBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED).into()))
            .with_text(text)
            .build(&amp;mut ui.build_ctx());
    BorderBuilder::new(
        WidgetBuilder::new()
            .with_child(text_widget) // &lt;-- Text is now a child of the border
            .with_background(Brush::Solid(Color::opaque(50, 50, 50)).into()),
    )
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind that now the text widget is a child widget of the border, so if you need to position the text, you should
position the border, not the text.</p>
<h2 id="fonts-and-colors"><a class="header" href="#fonts-and-colors">Fonts and colors</a></h2>
<p>To set a color of the text just use <code>.with_foreground(..)</code> of the <code>WidgetBuilder</code> while building the text instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_colored_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    //               vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    TextBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED).into()))
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>By default, text is created with default font, however it is possible to set any custom font:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_with_font(
    ui: &amp;mut UserInterface,
    text: &amp;str,
    resource_manager: &amp;ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_font(resource_manager.request::&lt;Font&gt;("path/to/your/font.ttf"))
        .with_text(text)
        // You can set any size as well.
        .with_font_size(24.0.into())
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Please refer to <a href="ui/font.html">Font</a> chapter to learn more about fonts.</p>
<h2 id="shadows-1"><a class="header" href="#shadows-1">Shadows</a></h2>
<p>Text widget supports shadows effect to add contrast to your text, which could be useful to make text readable independent
on the background colors. This effect could be used for subtitles. Shadows are pretty easy to add, all you need to do
is to enable them, setup desired thickness, offset and brush (solid color or gradient).</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_red_text_with_black_shadows(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED).into()))
        .with_text(text)
        // Enable shadows.
        .with_shadow(true)
        // Black shadows.
        .with_shadow_brush(Brush::Solid(Color::BLACK))
        // 1px thick.
        .with_shadow_dilation(1.0)
        // Offset the shadow slightly to the right-bottom.
        .with_shadow_offset(Vector2::new(1.0, 1.0))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="messages-2"><a class="header" href="#messages-2">Messages</a></h2>
<p>Text widget can accept the following list of messages at runtime (respective constructors are name with small letter -
<code>TextMessage::Text -&gt; TextMessage::text(widget_handle, direction, text)</code>):</p>
<ul>
<li><code>TextMessage::Text</code> - sets new text for a <code>Text</code> widget.</li>
<li><code>TextMessage::Wrap</code> - sets new <a href="ui/text.html#text-alignment-and-word-wrapping">wrapping mode</a>.</li>
<li><code>TextMessage::Font</code> - sets new <a href="ui/text.html#fonts-and-colors">font</a></li>
<li><code>TextMessage::VerticalAlignment</code> and <code>TextMessage::HorizontalAlignment</code> sets
<a href="ui/text.html#text-alignment-and-word-wrapping">vertical and horizontal</a> text alignment respectively.</li>
<li><code>TextMessage::Shadow</code> - enables or disables <a href="ui/text.html#shadows">shadow casting</a></li>
<li><code>TextMessage::ShadowDilation</code> - sets "thickness" of the shadows under the tex.</li>
<li><code>TextMessage::ShadowBrush</code> - sets shadow brush (allows you to change color and even make shadow with color gradients).</li>
<li><code>TextMessage::ShadowOffset</code> - sets offset of the shadows.</li>
</ul>
<p>An example of changing text at runtime could be something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn request_change_text(ui: &amp;UserInterface, text_widget_handle: Handle&lt;UiNode&gt;, text: &amp;str) {
    ui.send_message(TextMessage::text(
        text_widget_handle,
        MessageDirection::ToWidget,
        text.to_owned(),
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>Please keep in mind, that like any other situation when you "changing" something via messages, you should remember
that the change is <strong>not</strong> immediate. The change will be applied on <code>ui.poll_message(..)</code> call somewhere in your
code (or will be done automatically if you're using scripts or Framework (obsolete)).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-box"><a class="header" href="#text-box">Text Box</a></h1>
<p>TextBox is a text widget that allows you to edit text and create specialized input fields. It has various options like
word wrapping, text alignment, and so on.</p>
<h2 id="how-to-create-22"><a class="header" href="#how-to-create-22">How to create</a></h2>
<p>An instance of the TextBox widget could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_box(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="text-alignment-and-word-wrapping-1"><a class="header" href="#text-alignment-and-word-wrapping-1">Text alignment and word wrapping</a></h2>
<p>There are various text alignment options for both vertical and horizontal axes. Typical alignment values are:
<code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal axis, and <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical axis. An instance of
centered text could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_centered_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_horizontal_text_alignment(HorizontalAlignment::Center)
        .with_vertical_text_alignment(VerticalAlignment::Center)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Long text is usually needs to wrap on available bounds, there are three possible options for word wrapping:
<code>NoWrap</code>, <code>Letter</code>, <code>Word</code>. An instance of text with word-based wrapping could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_with_word_wrap(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_wrap(WrapMode::Word)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fonts-and-colors-1"><a class="header" href="#fonts-and-colors-1">Fonts and colors</a></h2>
<p>To set a color of the text just use <code>.with_foreground(..)</code> of the <code>WidgetBuilder</code> while building the text instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_colored_text_box(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    //                  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    TextBoxBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED).into()))
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>By default, text is created with default font, however it is possible to set any custom font:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_with_font(
    ui: &amp;mut UserInterface,
    text: &amp;str,
    resource_manager: &amp;ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_font(resource_manager.request::&lt;Font&gt;("path/to/your/font.ttf"))
        .with_text(text)
        // You can set any size as well.
        .with_font_size(24.0.into())
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Please refer to <a href="ui/font.html">Font</a> chapter to learn more about fonts.</p>
<h2 id="messages-3"><a class="header" href="#messages-3">Messages</a></h2>
<p>TextBox widget accepts the following list of messages:</p>
<ul>
<li><code>TextBoxMessage::SelectionBrush</code> - change the brush that is used to highlight selection.</li>
<li><code>TextBoxMessage::CaretBrush</code> - changes the brush of the caret (small blinking vertical line).</li>
<li><code>TextBoxMessage::TextCommitMode</code> - changes the <a href="ui/text_box.html#text-commit-mode">text commit mode</a>.</li>
<li><code>TextBoxMessage::Multiline</code> - makes the TextBox either multiline (<code>true</code>) or single line (<code>false</code>)</li>
<li><code>TextBoxMessage::Editable</code> - enables or disables editing of the text.</li>
</ul>
<p><strong>Important:</strong> Please keep in mind, that TextBox widget also accepts <code>Text</code> <a href="ui/text.html#messages">widget messages</a>. An
example of changing text at runtime could be something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn request_change_text(ui: &amp;UserInterface, text_box_widget_handle: Handle&lt;UiNode&gt;, text: &amp;str) {
    ui.send_message(TextMessage::text(
        text_box_widget_handle,
        MessageDirection::ToWidget,
        text.to_owned(),
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>Please keep in mind, that like any other situation when you "changing" something via messages, you should remember
that the change is <strong>not</strong> immediate. The change will be applied on <code>ui.poll_message(..)</code> call somewhere in your
code (or will be done automatically if you're using scripts or Framework (obsolete)).</p>
<h2 id="shortcuts"><a class="header" href="#shortcuts">Shortcuts</a></h2>
<p>There are number of default shortcuts that can be used to speed up text editing:</p>
<ul>
<li><code>Ctrl+A</code> - select all</li>
<li><code>Ctrl+C</code> - copy selected text</li>
<li><code>Ctrl+V</code> - paste text from clipboard</li>
<li><code>Ctrl+Home</code> - move caret to the beginning of the text</li>
<li><code>Ctrl+End</code> - move caret to the beginning of the text</li>
<li><code>Shift+Home</code> - select everything from current caret position until the beginning of current line</li>
<li><code>Shift+End</code> - select everything from current caret position until the end of current line</li>
<li><code>Arrows</code> - move caret accordingly</li>
<li><code>Delete</code> - deletes next character</li>
<li><code>Backspace</code> - deletes previous character</li>
<li><code>Enter</code> - new line (if multiline mode is set) or <code>commit</code> message</li>
</ul>
<h2 id="multiline-text-box"><a class="header" href="#multiline-text-box">Multiline Text Box</a></h2>
<p>By default, text box will not add new line character to the text if you press <code>Enter</code> on keyboard. To enable this
functionality use <code>.with_multiline(true)</code></p>
<h2 id="read-only-mode"><a class="header" href="#read-only-mode">Read-only Mode</a></h2>
<p>You can enable or disable content editing by using read-only mode. Use <code>.with_readonly</code> at build stage.</p>
<h2 id="mask-character"><a class="header" href="#mask-character">Mask Character</a></h2>
<p>You can specify replacement character for every other characters, this is useful option for password fields. Use
<code>.with_mask_char</code> at build stage. For example, you can set replacement character to asterisk <code>*</code> using
<code>.with_mask_char(Some('*'))</code></p>
<h2 id="text-commit-mode"><a class="header" href="#text-commit-mode">Text Commit Mode</a></h2>
<p>In many situations you don't need the text box to send <code>new text</code> message every new character, you either want this
message if <code>Enter</code> key is pressed or TextBox has lost keyboard focus (or both). There is <code>with_text_commit_mode</code> on builder
specifically for that purpose. Use one of the following modes:</p>
<ul>
<li><code>TextCommitMode::Immediate</code> - text box will immediately send <code>Text</code> message after any change.</li>
<li><code>TextCommitMode::LostFocus</code> - text box will send <code>Text</code> message only when it loses focus.</li>
<li><code>TextCommitMode::LostFocusPlusEnter</code> - text box will send <code>Text</code> message when it loses focus or if Enter key was pressed.
This is <strong>default</strong> behavior. In case of multiline text box hitting Enter key won't commit text!</li>
</ul>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>It is possible specify custom input filter, it can be useful if you're creating special input fields like numerical or
phone number. A filter can be specified at build stage like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_box_with_filter(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        // Specify a filter that will pass only digits.
        .with_filter(Arc::new(Mutex::new(|c: char| c.is_ascii_digit())))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>You can change brush of caret by using <code>.with_caret_brush</code> and also selection brush by using <code>.with_selection_brush</code>,
it could be useful if you don't like default colors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree"><a class="header" href="#tree">Tree</a></h1>
<p><img src="ui/tree.gif" alt="tree" /></p>
<p>Tree widget allows you to create views for hierarchical data. It could be used to show file
system entries, graphs, and anything else that could be represented as a tree.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>A simple tree with one root and two children items could be created like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fyrox_ui::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    tree::{TreeBuilder, TreeRootBuilder},
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    BuildContext, UiNode,
</span><span class="boring">};
</span><span class="boring">
</span>fn create_tree(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    // Note, that `TreeRoot` widget is mandatory here. Otherwise some functionality of
    // descendant trees won't work.
    TreeRootBuilder::new(WidgetBuilder::new())
        .with_items(vec![TreeBuilder::new(WidgetBuilder::new())
            .with_content(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Root Item 0")
                    .build(ctx),
            )
            .with_items(vec![
                TreeBuilder::new(WidgetBuilder::new())
                    .with_content(
                        TextBuilder::new(WidgetBuilder::new())
                            .with_text("Child Item 0")
                            .build(ctx),
                    )
                    .build(ctx),
                TreeBuilder::new(WidgetBuilder::new())
                    .with_content(
                        TextBuilder::new(WidgetBuilder::new())
                            .with_text("Child Item 1")
                            .build(ctx),
                    )
                    .build(ctx),
            ])
            .build(ctx)])
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Note, that <code>TreeRoot</code> widget is mandatory here. Otherwise, some functionality of descendant trees
won't work (primarily - selection). See <code>TreeRoot</code> docs for more detailed explanation.</p>
<h2 id="built-in-controls"><a class="header" href="#built-in-controls">Built-in controls</a></h2>
<p>Tree widget is a rich control element, which has its own set of controls:</p>
<p><code>Any Mouse Button</code> - select.
<code>Ctrl+Click</code> - enables multi-selection.
<code>Alt+Click</code> - prevents selection allowing you to use drag'n'drop.
<code>Shift+Click</code> - selects a span of items.
<code>ArrowUp</code> - navigate up from the topmost selection.
<code>ArrowDown</code> - navigate down from the lowermost selection.
<code>ArrowRight</code> - expand the selected item (first from the selection) or (if it is expanded), go
down the tree.
<code>ArrowLeft</code> - collapse the selected item or (if it is collapsed), go up the tree.</p>
<h2 id="adding-items"><a class="header" href="#adding-items">Adding Items</a></h2>
<p>An item could be added to a tree using <code>TreeMessage::AddItem</code> message like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fyrox_ui::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    message::MessageDirection,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    tree::{TreeBuilder, TreeMessage},
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    UiNode, UserInterface,
</span><span class="boring">};
</span><span class="boring">
</span>fn add_item(tree: Handle&lt;UiNode&gt;, ui: &amp;mut UserInterface) {
    let ctx = &amp;mut ui.build_ctx();

    let item = TreeBuilder::new(WidgetBuilder::new())
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text("Some New Item")
                .build(ctx),
        )
        .build(ctx);

    ui.send_message(TreeMessage::add_item(
        tree,
        MessageDirection::ToWidget,
        item,
    ));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="removing-items"><a class="header" href="#removing-items">Removing Items</a></h2>
<p>An item could be removed from a tree using <code>TreeMessage::RemoveItem</code> message like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fyrox_ui::{
</span><span class="boring">    core::pool::Handle, message::MessageDirection, tree::TreeMessage, UiNode, UserInterface,
</span><span class="boring">};
</span><span class="boring">
</span>fn remove_item(tree: Handle&lt;UiNode&gt;, item_to_remove: Handle&lt;UiNode&gt;, ui: &amp;UserInterface) {
    // Note that the `ui` is borrowed as immutable here, which means that the item will **not**
    // be removed immediately, but on the next update call.
    ui.send_message(TreeMessage::remove_item(
        tree,
        MessageDirection::ToWidget,
        item_to_remove,
    ));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="setting-new-items"><a class="header" href="#setting-new-items">Setting New Items</a></h2>
<p>Tree's items could be changed all at once using the <code>TreeMessage::SetItems</code> message like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fyrox_ui::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    message::MessageDirection,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    tree::{TreeBuilder, TreeMessage},
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    UiNode, UserInterface,
</span><span class="boring">};
</span><span class="boring">
</span>fn set_items(tree: Handle&lt;UiNode&gt;, ui: &amp;mut UserInterface) {
    let ctx = &amp;mut ui.build_ctx();

    let items = vec![
        TreeBuilder::new(WidgetBuilder::new())
            .with_content(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Item 0")
                    .build(ctx),
            )
            .build(ctx),
        TreeBuilder::new(WidgetBuilder::new())
            .with_content(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text("Item 1")
                    .build(ctx),
            )
            .build(ctx),
    ];

    // A flag, that tells that the UI system must destroy previous items first.
    let remove_previous = true;
    ui.send_message(TreeMessage::set_items(
        tree,
        MessageDirection::ToWidget,
        items,
        remove_previous,
    ));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="expanding-items"><a class="header" href="#expanding-items">Expanding Items</a></h2>
<p>It is possible to expand/collapse trees at runtime using <code>TreeMessage::Expand</code> message. It provides
different expansion strategies, see docs for <code>TreeExpansionStrategy</code> for more info. Tree expansion
could useful to highlight something visually.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fyrox_ui::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    message::MessageDirection,
</span><span class="boring">    tree::{TreeExpansionStrategy, TreeMessage},
</span><span class="boring">    UiNode, UserInterface,
</span><span class="boring">};
</span><span class="boring">
</span>fn expand_tree(tree: Handle&lt;UiNode&gt;, ui: &amp;UserInterface) {
    ui.send_message(TreeMessage::expand(
        tree,
        MessageDirection::ToWidget,
        true,
        TreeExpansionStrategy::RecursiveAncestors,
    ));
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-image"><a class="header" href="#vector-image">Vector image</a></h1>
<p>Vector image is used to create images, that consists from a fixed set of basic primitives, such as lines,
triangles, rectangles, etc. It could be used to create simple images that can be infinitely scaled without
aliasing issues.</p>
<h2 id="how-to-create-23"><a class="header" href="#how-to-create-23">How To Create</a></h2>
<p>There are two major ways to create a vector image widget - using the editor and from code.</p>
<h3 id="using-the-editor-3"><a class="header" href="#using-the-editor-3">Using the Editor</a></h3>
<p><img src="ui/vector_image.png" alt="vector image" /></p>
<p>To create a vector image from the editor, go to <code>Create -&gt; UI</code> and press <code>Vector Image</code> there. An empty image
should be created and selected, now all you need to do is to fill it with a set of pre-defined shapes. For example,
on the picture above there are two yellow lines forming a cross.</p>
<h3 id="from-code-6"><a class="header" href="#from-code-6">From Code</a></h3>
<p>The following example creates a cross shape with given size and thickness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_cross_vector_image(ctx: &amp;mut BuildContext, size: f32, thickness: f32) -&gt; Handle&lt;UiNode&gt; {
    VectorImageBuilder::new(
        WidgetBuilder::new()
            // Color of the image is defined by the foreground brush of the base widget.
            .with_foreground(ctx.style.property(Style::BRUSH_BRIGHT)),
    )
    .with_primitives(vec![
        Primitive::Line {
            begin: Vector2::new(0.0, 0.0),
            end: Vector2::new(size, size),
            thickness,
        },
        Primitive::Line {
            begin: Vector2::new(size, 0.0),
            end: Vector2::new(0.0, size),
            thickness,
        },
    ])
    .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind that all primitives located in local coordinates. The color of the vector image can be changed by
setting a new foreground brush.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-1"><a class="header" href="#window-1">Window</a></h1>
<p><img src="ui/window.gif" alt="window" /></p>
<p>The Window widget provides a standared window that can contain another widget. Based on setting windows can be configured
so users can do any of the following:</p>
<ul>
<li>Movable by the user. Not configurable.</li>
<li>Have title text on the title bar. Set by the <em>with_title</em> function.</li>
<li>Able to be exited by the user. Set by the <em>can_close</em> function.</li>
<li>Able to be minimized to just the Title bar, and of course maximized again. Set by the <em>can_minimize</em> function.</li>
<li>Able to resize the window. Set by the <em>can_resize</em> function.</li>
</ul>
<p>As with other UI elements, you create and configure the window using the WindowBuilder.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_window(ui: &amp;mut UserInterface) {
    WindowBuilder::new(
        WidgetBuilder::new()
            .with_desired_position(Vector2::new(300.0, 0.0))
            .with_width(300.0),
    )
    .with_content(
        TextBuilder::new(WidgetBuilder::new())
            .with_text("Example Window content.")
            .build(&amp;mut ui.build_ctx()),
    )
    .with_title(WindowTitle::text("Window"))
    .can_close(true)
    .can_minimize(true)
    .open(true)
    .can_resize(false)
    .build(&amp;mut ui.build_ctx());
}
<span class="boring">}</span></code></pre></pre>
<p>You will likely want to constrain the initial size of the window to somethig as shown in the example by providing a set
width and/or height to the base WidgetBuilder. Otherwise it will expand to fit it's content.</p>
<p>You may also want to set an inital position with the <em>with_desired_position</em> function called on the base WidgetBuilder
which sets the position of the window's top-left corner. Otherwise all your windows will start with it's top-left corner
at 0,0 and be stacked on top of eachother.</p>
<p>Windows can only contain a single direct child widget, set by using the <em>with_content</em> function.
Additional calls to <em>with_content</em> replaces the widgets given in previous calls, and the old widgets exist outside the
window, so you should delete old widgets before changing a window's widget.  If you want multiple widgets, you need to
use one of the layout container widgets like the Grid, Stack Panel, etc then add the additional widgets to that widget
as needed.</p>
<p>The Window is a user editable object, but can only be affected by UI Messages they trigger if the message's corresponding
variable has been set to true aka what is set by the <em>can_close</em>, <em>can_minimize</em>, and <em>can_resize</em> functions.</p>
<h2 id="initial-open-state"><a class="header" href="#initial-open-state">Initial Open State</a></h2>
<p>By default, the window will be created in the open, or maximized, state. You can manually set this state via the <em>open</em>
function providing a true or false as desired.</p>
<h2 id="styling-the-buttons"><a class="header" href="#styling-the-buttons">Styling the Buttons</a></h2>
<p>The window close and minimise buttons can be configured with the <em>with_close_button</em> and <em>with_minimize_button</em> functions.
You will want to pass them a button widget, but can do anything else you like past that.</p>
<h2 id="modal-aka-forced-focus"><a class="header" href="#modal-aka-forced-focus">Modal (AKA Forced Focus)</a></h2>
<p>A Modal in UI design terms indicates a window or box that has forced focus. The user is not able to interact with anything
else until the modal is dissmissed.</p>
<p>Any window can be set and unset as a modal via the <em>modal</em> function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-panel"><a class="header" href="#wrap-panel">Wrap panel</a></h1>
<p><img src="ui/wrap_panel.gif" alt="wrap panel" /></p>
<p>Wrap panel is used to stack children widgets either in vertical or horizontal direction with overflow - every widget
that does not have enough space on current line, will automatically be placed on the next line.</p>
<h2 id="how-to-create-24"><a class="header" href="#how-to-create-24">How to create</a></h2>
<p>Use <code>WrapPanelBuilder</code> to create new wrap panel instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_wrap_panel(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    WrapPanelBuilder::new(WidgetBuilder::new())
        .with_orientation(Orientation::Horizontal)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="orientation-1"><a class="header" href="#orientation-1">Orientation</a></h2>
<p>Wrap panel can stack your widgets either in vertical or horizontal direction. Use <code>.with_orientation</code> while building
the panel to switch orientation to desired.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h2>
<p>One of many use case examples could be picture gallery, or asset browser in the Fyroxed:</p>
<p><img src="ui/wrap_panel.png" alt="wrap panel" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-1"><a class="header" href="#serialization-1">Serialization</a></h1>
<p>Serialization is a process that converts arbitrary objects into a set of bytes that can be stored to disk or to send
them over the network. An opposite to serialization - deserialization - is a process that restores objects from a given
set of bytes. Serialization often used to make save/load functionality in games.</p>
<p>Fyrox has built-in serializer that is used all over the place the engine and which is represented by a <code>Visit</code> trait.
<code>Visit</code> name could be confusing, but it is called after well-known <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a>
design pattern.</p>
<p>Serialization and deserialization itself is handled by <code>Visitor</code>, it can be created in two modes: read and write. See
mode info in respective sections below.</p>
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<p>There are two main ways to implement <code>Visit</code> trait, each way serves for specific cases. Let's understand which one to
use when.</p>
<h3 id="proc-macro-derivevisit"><a class="header" href="#proc-macro-derivevisit">Proc-macro <code>#[derive(Visit)]</code></a></h3>
<p>The engine provides proc-macro, that uses code generation to implement <code>Visit</code> trait for you. All you need to do is
to add <code>#[derive(Visit)]</code> to your struct/enum. Code generation in most cases is capable to generate typical
implementation for serialization/deserialization. You should prefer proc-macro to manual implementation in most cases.</p>
<p>The macro supports few very useful attributes, that can be added to fields of a struct/enum:</p>
<ul>
<li><code>#[visit(optional)]</code> - forces the engine to ignore any errors that may occur during deserialization, leaving a field's
value in default state. Very useful option if you're adding a new field to your structure, otherwise the engine will
refuse to continue loading of your struct. In case of scripts, deserialization will stop on missing field, and it will
be partially loaded.</li>
<li><code>#[visit(rename = "new_name")]</code> - replaces the name of a field with given value. Useful if you need to rename a field
in the code, but leave backward compatibility with previous versions.</li>
<li><code>#[visit(skip)]</code> - ignores a field completely. Useful if you don't want to serialize a field at all, or a field is not
serializable.</li>
</ul>
<p>To use the macro, you must import all types related to <code>Visit</code> trait by <code>use fyrox::core::visitor::prelude::*;</code>. Here's
an example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Default)]
struct MyStruct {
    foo: u32,

    #[visit(rename = "baz")]
    foobar: f32,

    #[visit(optional)]
    optional: String,

    #[visit(skip)]
    ignored: usize,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-implementation"><a class="header" href="#manual-implementation">Manual implementation</a></h3>
<p>Manual implementation of the trait gives you an opportunity to fix compatibility issues, do some specific actions
during serialization (logging, for instance). Typical manual implementation could look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStructWithManualVisit {
    foo: u32,
    foobar: f32,
    optional: String,
    ignored: usize,
}

impl Visit for MyStructWithManualVisit {
    fn visit(&amp;mut self, name: &amp;str, visitor: &amp;mut Visitor) -&gt; VisitResult {
        // Create a region first.
        let mut region = visitor.enter_region(name)?;

        // Add fields to it.
        self.foo.visit("Foo", &amp;mut region)?;

        // Manually rename the field for serialization.
        self.foobar.visit("Baz", &amp;mut region)?;

        // Ignore result for option field.
        let _ = self.optional.visit("Baz", &amp;mut region);

        // Ignore `self.ignored`

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code pretty much shows the result of macro expansion from the previous section. As you can see, proc-macro saves
you from writing tons of boilerplate code.</p>
<p>Implementing <code>Visit</code> trait is a first step, the next step is to either serialize an object or deserialize it. See
the following section for more info.</p>
<h2 id="serialization-and-deserialization"><a class="header" href="#serialization-and-deserialization">Serialization and Deserialization</a></h2>
<p>To serialize an object all you need to do is to create an instance of a Visitor in either read or write mode and use it
like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn visit_my_structure(path: &amp;Path, object: &amp;mut MyStruct, write: bool) -&gt; VisitResult {
    if write {
        let mut visitor = Visitor::new();
        object.visit("MyObject", &amp;mut visitor)?;

        // Dump to the path.
        visitor.save_binary(path)
    } else {
        let mut visitor = Visitor::load_binary(path).await?;

        // Create default instance of an object.
        let mut my_object = MyStruct::default();

        // "Fill" it with contents from visitor.
        my_object.visit("MyObject", &amp;mut visitor)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The key function here is <code>visit_my_structure</code> which works in both serialization and deserialization modes depending on
<code>write</code> flag value.</p>
<p>When <code>write</code> is true (serialization), we're creating a new empty visitor and filling it with values from our <code>object</code>
and then "dump" its content to binary file.</p>
<p>When <code>write</code> is false (deserialization), we're loading contents of a file, creating the object in its default state and
then "filling" it with values from the visitor.</p>
<h2 id="environment"><a class="header" href="#environment">Environment</a></h2>
<p>Sometimes there is a need to pass custom data to <code>visit</code> methods, one of the ways to do this is to use <code>blackboard</code> field
of the visitor:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStructWithEnv {
    // ...
}

struct MyEnvironment {
    some_data: String,
}

impl Visit for MyStructWithEnv {
    fn visit(&amp;mut self, name: &amp;str, visitor: &amp;mut Visitor) -&gt; VisitResult {
        if let Some(environment) = visitor.blackboard.get::&lt;MyEnvironment&gt;() {
            println!("{}", environment.some_data);
        }

        Ok(())
    }
}

fn serialize_with_environment() {
    let mut my_object = MyStructWithEnv {
        // ...
    };

    let mut visitor = Visitor::new();

    visitor.blackboard.register(Arc::new(MyEnvironment {
        some_data: "Foobar".to_owned(),
    }));

    my_object.visit("MyObject", &amp;mut visitor).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-5"><a class="header" href="#limitations-5">Limitations</a></h2>
<p>All fields of your structure must implement <code>Default</code> trait, this is essential limitation because deserialization must
have a way to create an instance of an object for you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saved-games"><a class="header" href="#saved-games">Saved Games</a></h1>
<p>Saved game is used to store progress made in a play-through of a game to disk or some other storage. It is very important
for pretty much every game and this chapter will help you to understand basic concepts of saved games in the engine.</p>
<h2 id="saved-game-structure"><a class="header" href="#saved-game-structure">Saved Game Structure</a></h2>
<p>This could sound weird, but saved game in most cases is just a scene with additional data. Let's understand why. At first,
when you're making a save file you need to take some sort of "snapshot" of your game world. Essential way of storing
such data is a scene. Secondly, game plugins is also may store some data that should be saved. By these two facts, it
is quite easy to get a full picture: to make a save all you need to do is to serialize current scene, serialize some
other data and just "dump" it to a file. You might ask: is this efficient to serialize the entire scene? In short: yes.
A bit more detailed answer: when you serialize a scene, it does not store everything, it only stores <em>changed</em> fields
and references to external assets.</p>
<h2 id="usage-6"><a class="header" href="#usage-6">Usage</a></h2>
<p>Fyrox offers a built-in system for saved games. It does exactly what said in the section above - serializes a "diff" of
your scene which can be loaded later as an ordinary scene and the engine will do all the magic for you. Typical usage of
this system is very simple:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug, Default)]
struct MyGame {
    scene: Handle&lt;Scene&gt;,
}

impl MyGame {
    fn new(scene_path: Option&lt;&amp;str&gt;, context: PluginContext) -&gt; Self {
        // Load the scene as usual.
        context
            .async_scene_loader
            .request(scene_path.unwrap_or("data/scene.rgs"));

        Self {
            scene: Handle::NONE,
        }
    }

    fn save_game(&amp;mut self, context: &amp;mut PluginContext) {
        let mut visitor = Visitor::new();
        // Serialize the current scene.
        context.scenes[self.scene]
            .save("Scene", &amp;mut visitor)
            .unwrap();
        // Save it to a file.
        visitor.save_binary(Path::new("save.rgs")).unwrap()
    }

    fn load_game(&amp;mut self, context: &amp;mut PluginContext) {
        // Loading of a saved game is very easy - just ask the engine to load your save file.
        // Note the difference with `Game::new` - here we use `request_raw` instead of
        // `request` method. The main difference is that `request` creates a derived scene
        // from a source scene, but `request_raw` loads the scene without any modifications.
        context.async_scene_loader.request_raw("save.rgs");
    }
}

impl Plugin for MyGame {
    fn on_scene_begin_loading(&amp;mut self, _path: &amp;Path, context: &amp;mut PluginContext) {
        if self.scene.is_some() {
            context.scenes.remove(self.scene);
        }
    }

    fn on_scene_loaded(
        &amp;mut self,
        _path: &amp;Path,
        scene: Handle&lt;Scene&gt;,
        _data: &amp;[u8],
        _context: &amp;mut PluginContext,
    ) {
        self.scene = scene;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is a typical structure of a game that supports saving and loading. As you can see, it is pretty much the same as
the standard code, that can be generated by <code>fyrox-template</code>. The main difference here is two new methods with
self-describing names: <code>save_game</code> and <code>load_game</code>. Let's try to understand what each one does.</p>
<p><code>save_game</code> serializes your current game scene into a file. This function is very simple and can be used as-is in
pretty much any game. You can also write additional game data here using the <code>visitor</code> instance (see next section).</p>
<p><code>load_game</code> - loads a saved game. It just asks the engine to load your save file as an ordinary scene. Note the difference
with code in <code>Game::new</code> - here we use <code>request_raw</code> instead of <code>request</code> method. The main difference is that <code>request</code>
creates a derived scene from a source scene, but <code>request_raw</code> loads the scene without any modifications. What is
derived scene anyway? It is a scene, which does not store all the required data inside, instead, it stores links to
places where the data can be obtained from. You can also think of it as a difference between your saved game and an
original scene.</p>
<p>You can bind these two functions to some keys, for example you can use <code>F5</code> for save and <code>F9</code> for load and call the
respective methods for saving/loading. Also, these methods could be used when a button was pressed, etc.</p>
<h2 id="additional-data"><a class="header" href="#additional-data">Additional Data</a></h2>
<p>As was mentioned in the previous section, it is possible to store additional data in a saved game. It is very simple
to do:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug, Default)]
struct MyData {
    foo: String,
    bar: u32,
}

#[derive(Visit, Reflect, Debug, Default)]
struct MyGame {
    scene: Handle&lt;Scene&gt;,
    data: MyData,
}

impl MyGame {
    fn new(scene_path: Option&lt;&amp;str&gt;, context: PluginContext) -&gt; Self {
        // Load the scene as usual.
        context
            .async_scene_loader
            .request(scene_path.unwrap_or("data/scene.rgs"));

        Self {
            scene: Handle::NONE,
            data: Default::default(),
        }
    }

    fn save_game(&amp;mut self, context: &amp;mut PluginContext) {
        let mut visitor = Visitor::new();

        // Serialize the current scene.
        context.scenes[self.scene]
            .save("Scene", &amp;mut visitor)
            .unwrap();

        // Write additional data.
        self.data.visit("Data", &amp;mut visitor).unwrap();

        // Save it to a file.
        visitor.save_binary(Path::new("save.rgs")).unwrap()
    }

    pub fn load_game(&amp;mut self, context: &amp;mut PluginContext) {
        // Loading of a saved game is very easy - just ask the engine to load your scene.
        // Note the difference with `Game::new` - here we use `request_raw` instead of
        // `request` method. The main difference is that `request` creates a derived scene
        // from a source scene, but `request_raw` loads the scene without any modifications.
        context.async_scene_loader.request_raw("save.rgs");
    }
}

impl Plugin for MyGame {
    fn on_scene_begin_loading(&amp;mut self, _path: &amp;Path, context: &amp;mut PluginContext) {
        if self.scene.is_some() {
            context.scenes.remove(self.scene);
        }
    }

    fn on_scene_loaded(
        &amp;mut self,
        _path: &amp;Path,
        scene: Handle&lt;Scene&gt;,
        data: &amp;[u8],
        _context: &amp;mut PluginContext,
    ) {
        self.scene = scene;

        // Restore the data when the scene was loaded.
        if let Ok(mut visitor) = Visitor::load_from_memory(data) {
            self.data.visit("Data", &amp;mut visitor).unwrap();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The main difference here with the code snippet from the previous section is that now we have <code>MyData</code> structure which
we want to save in a save file as well as current scene. We're doing that in <code>save_game</code> method by
<code>self.data.visit("Data", &amp;mut visitor).unwrap();</code> which serializes our data. To load the data back (deserialize), we
have to wait until the scene is fully loaded and then try to deserialize the data. This is done by the last three lines
of code of <code>on_scene_loaded</code> method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-3"><a class="header" href="#editor-3">Editor</a></h1>
<p>This section of the book covers various aspects of the editor. Keep in mind, that this section covers aspects of the
editor, that does not have direct relations with engine entities. For example, this section covers
<a href="editor/settings.html">Editor Settings</a>, but does not cover <a href="editor/../animation/anim_editor.html">Animation Editor</a>. This is because, it
is better to show how to use a thing from both sides at once (code and editor), than split it to separate sections.</p>
<p>In this section, you'll know how to use editor-specific parts of the engine, how to use special tools it provides.
Check next chapters to learn more about a part that interests you now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-editors"><a class="header" href="#property-editors">Property Editors</a></h1>
<p>The editor uses <a href="editor/../ui/inspector.html">Inspector</a> widget to show the contents of your scripts and when you're using
custom structures inside your scripts the editor needs to know how to show them in the UI. Inspector widget has a
special mechanism for this called <em>property editors</em>. Basically, it defines a pair <code>TypeId -&gt; Widget</code> - a type has
an associated widget that is responsible for showing the content of the type and (optionally) edit it. If there's no
widget associated with a type, the editor will print an error message near this field, basically telling you that
you need to fix this.</p>
<h2 id="adding-property-editors"><a class="header" href="#adding-property-editors">Adding Property Editors</a></h2>
<p>The engine has property editors for pretty much every case, all you need to do is to associate your type with one of
them. The following sections covers the most common use cases, each of them should be added to <code>editor/src/main.rs</code>
file, after editor's initialization.</p>
<h3 id="structures"><a class="header" href="#structures">Structures</a></h3>
<p>This is the most common case when you need to associate your type with a property editor, and in this case the property
editor will be <code>InspectablePropertyEditorDefinition</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Reflect, Debug)]
struct MyStruct {
    foo: u32,
    bar: String,
}

fn add_property_editor(editor: &amp;Editor) {
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .insert(InspectablePropertyEditorDefinition::&lt;MyStruct&gt;::new());
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that your structure must implement <code>Reflect</code> trait, otherwise you'll get a compilation error.</p>
<h3 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h3>
<p>Enumerations are a bit trickier to support, than simple structures, because they require a bit more traits to be
implemented for your enumeration. At first, make sure that your <code>editor</code> project has the following dependencies:</p>
<pre><code class="language-toml">#[dependencies]
strum = "0.26.0"
strum_macros = "0.26.0"
</code></pre>
<p>These two crates responsible for enum to string (and vice versa) conversions which will be very useful for us. The
following example shows a typical usage:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Reflect, Default, Debug, AsRefStr, EnumString, VariantNames, TypeUuidProvider, Clone)]
#[type_uuid(id = "31311d8b-f956-4ae9-a633-1e45b755f322")]
enum MyEnum {
    #[default]
    Baz,
    Foo(u32),
    Bar {
        baz: String,
        foobar: u32,
    },
}

fn add_enum_property_editor(editor: &amp;Editor) {
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .insert(EnumPropertyEditorDefinition::&lt;MyEnum&gt;::new());
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, your enumeration needs a decent number of trait implementations, hopefully all of them can be derived.</p>
<h3 id="inheritable-properties"><a class="header" href="#inheritable-properties">Inheritable Properties</a></h3>
<p>If your structure or enumeration needs to be inheritable (see more info about <a href="editor/../scene/inheritance.html">property inheritance</a>),
then you need one more step. In case of inheritable variables, your fields will be wrapped in <code>InheritableVariable&lt;&gt;</code> and
this fact requires you to register an appropriate property editor for this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Reflect, Debug, TypeUuidProvider, Default, Clone)]
#[type_uuid(id = "31311d8b-f956-4ae9-a633-1e45b755f323")]
struct MyOtherStruct {
    foo: u32,
    bar: String,
}

// An example script with inheritable field of custom structure.
struct MyScript {
    inheritable: InheritableVariable&lt;MyOtherStruct&gt;,
}

fn add_inheritable_property_editor(editor: &amp;Editor) {
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .insert(InspectablePropertyEditorDefinition::&lt;MyOtherStruct&gt;::new());

    // This is responsible for supporting inheritable properties in scripts.
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .insert(InheritablePropertyEditorDefinition::&lt;MyOtherStruct&gt;::new());

    // Alternatively, the two previous insertions could be replaced by a single call of helper
    // method:
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .register_inheritable_inspectable::&lt;MyStruct&gt;();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="collections"><a class="header" href="#collections">Collections</a></h3>
<p>If you have a vector of some custom structure (<code>Vec&lt;MyStruct&gt;</code>), then you also need to register a property editor for
it:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// An example script with Vec field of custom structure.
struct MyOtherScript {
    inheritable: Vec&lt;MyOtherStruct&gt;,
}

fn add_collection_property_editor(editor: &amp;Editor) {
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .insert(InspectablePropertyEditorDefinition::&lt;MyOtherStruct&gt;::new());

    // VecCollectionPropertyEditorDefinition is used to create a property editor for Vec&lt;MyStruct&gt;,
    // internally it uses a registered property editor for its generic argument (MyStruct).
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .insert(VecCollectionPropertyEditorDefinition::&lt;MyOtherStruct&gt;::new());

    // Alternatively, you can use a special helper method to replace the two blocks above by a
    // single one.
    editor
        .plugins
        .get::&lt;InspectorPlugin&gt;()
        .property_editors
        .register_inheritable_vec_collection::&lt;MyOtherStruct&gt;();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-property-editors"><a class="header" href="#custom-property-editors">Custom Property Editors</a></h2>
<p>See <a href="editor/../ui/inspector.html">Inspector</a> widget chapter to learn how to create custom property editors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings-2"><a class="header" href="#settings-2">Settings</a></h1>
<p>This chapter should help you to have better understanding of how to configure the editor and which settings
are responsible for what.</p>
<p><img src="editor/settings.png" alt="settings" /></p>
<h2 id="selection-1"><a class="header" href="#selection-1">Selection</a></h2>
<p>This section contains options for objects selection.</p>
<ul>
<li><code>Ignore Back Faces</code> - if set, forces mouse picking to ignore back faces of triangles, allowing you to "click-thru"
triangles from back side. It is useful to pick objects in scenes where you have a ceiling, if the ceiling is one-sided,
then all clicks will pass through it allowing you to select objects below the ceiling.</li>
</ul>
<h2 id="graphics"><a class="header" href="#graphics">Graphics</a></h2>
<p>Options in this section defines quality settings for rendering. It directly affects performance and can be used to
see how well your scene will be rendered with different options. Almost everything in this section is very well
covered in <a href="editor/../rendering/settings.html">Quality Settings section</a>. The rest of the fields described below.</p>
<ul>
<li><code>Z Near</code> - defines near clipping plane for main preview camera in the scene.</li>
<li><code>Z Far</code> - defines far clipping plane for main preview camera in the scene.</li>
</ul>
<h2 id="debugging-1"><a class="header" href="#debugging-1">Debugging</a></h2>
<p>This section contains options for visual debugging, it helps you to see invisible geometry, such as bounding boxes,
physical objects, etc.</p>
<ul>
<li><code>Show Physics</code> - if set, shows physical entities in wireframe mode using debug renderer. It is useful to see where
physical entities are, and what shape they have.</li>
<li><code>Show Bounds</code> - if set, shows bounding boxes of scene nodes.</li>
<li><code>Show Tbn</code> - if set, shows tangent-binormal-normal basis of every mesh in the scene. It can be useful to debug
graphical issues related to incorrect tangent space.</li>
</ul>
<h2 id="move-mode-settings"><a class="header" href="#move-mode-settings">Move Mode Settings</a></h2>
<p>Options in this section responsible for behaviour of Move interaction mode (a tool that allows you to move a node
with a gizmo).</p>
<ul>
<li><code>Grid Snapping</code> - if set, restricts movement to a 3D grid nodes with axes steps defined by Snap Step parameter
for respective axis.</li>
<li><code>X/Y/Z Snap Step</code> - defines snapping step (in meters) on respective axis.</li>
</ul>
<h2 id="rotate-mode-settings"><a class="header" href="#rotate-mode-settings">Rotate Mode Settings</a></h2>
<p>This section contains options for Rotate interaction mode (a tool that allows you to rotate a node with a gizmo).</p>
<ul>
<li><code>Angle Snapping</code> - if set, restricts rotation around each axis to a series of marks with uniform
angular step added to imaginary dial.</li>
<li><code>X/Y/Z Snap Step</code> - defines snapping step (in radians) around respective axis.</li>
</ul>
<h2 id="model"><a class="header" href="#model">Model</a></h2>
<p>Options in this section affects how the editor handles <a href="editor/../resources/model.html">Model</a> assets.</p>
<ul>
<li><code>Instantiation Scale</code> - defines a scale that will be applied to a root node of every Model resource being instantiated
in the editor. It is useful if you have tons of Model resources that are either too large or too small, and you want
to re-scale them automatically.</li>
</ul>
<h2 id="camera"><a class="header" href="#camera">Camera</a></h2>
<p>This section contains options of editor camera that is used in Scene Preview window.</p>
<ul>
<li><code>Speed</code> - speed of camera in meters per second.</li>
<li><code>Invert Dragging</code> - if set, inverts dragging of the camera via middle mouse button.</li>
<li><code>Drag Speed</code> - defines how fast the camera will move while being dragged via middle mouse button.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-plugins"><a class="header" href="#editor-plugins">Editor Plugins</a></h1>
<p><strong>WARNING: This article is not finished</strong></p>
<p>It is possible to extend editor functionality by custom plugins. This chapter will explain how to create one and how
editor plugins interact with the editor itself.</p>
<h2 id="basic-concepts-4"><a class="header" href="#basic-concepts-4">Basic Concepts</a></h2>
<p>There are few basic concepts that must be known before start writing an editor plugin.</p>
<ol>
<li>MVC - the editor uses classic <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>
(model-view-controller) pattern. This means that the editor always "renders" the actual state of your data model and
its UI is used only to show the data - it does not store anything. Any user change forces the editor to sync the UI
with the new data.</li>
<li>Commands - the editor usually operates on scenes (there could be multiple opened scenes, but only one active) and any
modification of their content <strong>must</strong> be done via <em>commands</em>. <a href="https://en.wikipedia.org/wiki/Command_pattern">Command</a>
is a standard pattern that encapsulates an action. Command pattern is used for undo/redo functionality.</li>
<li>Preview Mode - sometimes there's a need to preview results in the scene itself, for example if you're making an
animation editor plugin of some sort. Any changes to scene nodes done in the preview mode will be discarded after leaving
this mode.</li>
</ol>
<p>Typical update iteration of the editor looks like this: execute scheduled commands, sync the UI with the new state
of the entities, sleep until new commands. If the preview mode is active, the editor will be always active (see
respective section below for more info).</p>
<h2 id="plugin"><a class="header" href="#plugin">Plugin</a></h2>
<p>As an example, we'll create a plugin that will edit a script of a scene node. The script itself will contain a list
of points which forms a line in 3D space. Our plugin will allow to edit position of these points in 3D space using
movement gizmo, like you move scene nodes. Despite the fact that it is possible to edit the points using Inspector,
is much more comfortable to edit them and see where they're directly in the scene previewer. A good tool is the one that
saves time. Our script looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, TypeUuidProvider, ComponentProvider, Reflect, Visit)]
#[type_uuid(id = "69302f1c-f3c7-4853-801c-552c566948d0")]
pub struct MyScript {
    points: Vec&lt;Vector3&lt;f32&gt;&gt;,
}

impl ScriptTrait for MyScript {}
<span class="boring">}</span></code></pre></pre>
<p>All editor plugins must implement <code>EditorPlugin</code> trait, all methods of which are optional. For our purposes we'll use
only a few of them - <code>on_message</code>, <code>on_update</code>, <code>on_sync_to_model</code>. See the API docs for <code>EditorPlugin</code> for more info
about other methods. Typical plugin definition could look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct MyPlugin {
    node_handle: Handle&lt;Node&gt;,
}
impl EditorPlugin for MyPlugin { 
} 
<span class="boring">}</span></code></pre></pre>
<p>Every plugin must be registered in the editor, it could be done from <code>editor</code> crate of your project. Simply add the
following code after editor's initialization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    editor.add_editor_plugin(MyPlugin::default());
<span class="boring">}</span></code></pre></pre>
<p>Our plugin will work with scene nodes that has particular script type, and we need to know a handle of object that is
suitable for editing via our plugin, this is where <code>on_message</code> could be useful:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_message(&amp;mut self, message: &amp;Message, editor: &amp;mut Editor) {
        // Fetch the active scene.
        let Some(entry) = editor.scenes.current_scene_entry_mut() else {
            return;
        };

        let Some(selection) = entry.selection.as_graph() else {
            return;
        };

        // Try to cast it to GameScene, it could also be UiScene for UI scene plugins.
        let Some(game_scene) = entry.controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut editor.engine.scenes[game_scene.scene];

        // When user clicks on some object in scene, the editor produces `SelectionChanged` message
        // which we can catch and check which object was selected.
        if let Message::SelectionChanged { .. } = message {
            for node_handle in selection.nodes().iter() {
                // An object with our script was selected, remember the handle of it in the
                // plugin.
                if scene
                    .graph
                    .try_get_script_of::&lt;MyScript&gt;(*node_handle)
                    .is_some()
                {
                    self.node_handle = *node_handle;

                    break;
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>It is quite verbose, but in general it is very straightforward. We're fetching the active scene first, then checking
selection type of to be graph selection (there are a number of selection types), then checking that the scene is
game scene (there's also <code>UiScene</code>). All that is left to do is to iterate over selected scene nodes and check if
one of them has our script. Once node selection is done, we can write our own interaction mode to</p>
<h2 id="interaction-modes-and-visualization"><a class="header" href="#interaction-modes-and-visualization">Interaction Modes and Visualization</a></h2>
<p>We need a way to show the points of the line in the scene previewer. The editor uses standard scene nodes for this, and
they all live under a "secret" root node (it is hidden in World Viewer, that's why you can't see it there). The good
approach for visualization is just a custom structure with a few methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct LinePointsGizmo {
    point_nodes: Vec&lt;Handle&lt;Node&gt;&gt;,
}

impl LinePointsGizmo {
    fn sync_to_model(
        &amp;mut self,
        node_handle: Handle&lt;Node&gt;,
        game_scene: &amp;GameScene,
        graph: &amp;mut Graph,
    ) {
        let Some(script) = graph.try_get_script_of::&lt;MyScript&gt;(node_handle) else {
            return;
        };
        let points = script.points.clone();

        if self.point_nodes.len() != points.len() {
            self.remove_points(graph);
            for point in points {
                // Point could be represented via sprite - it will always be facing towards editor's
                // camera.
                let point_node = SpriteBuilder::new(BaseBuilder::new())
                    .with_size(0.1)
                    .build(graph);

                self.point_nodes.push(point_node);

                // Link the sprite with the special scene node - the name of it should clearly state
                // its purpose.
                graph.link_nodes(point_node, game_scene.editor_objects_root);
            }
        }
    }

    fn remove_points(&amp;mut self, graph: &amp;mut Graph) {
        for handle in self.point_nodes.drain(..) {
            graph.remove_node(handle);
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p><code>sync_to_model</code> method can be called on every frame in <code>update</code> method of the interaction mode (see below) - it tracks
the number of scene nodes representing points of the line and if there's mismatch, it recreates the entire set.
<code>remove_points</code> should be used when the gizmo is about to be deleted (usually together with the interaction mode).</p>
<p>All interaction with scene nodes should be performed using interaction modes. Interaction mode is a tiny abstraction layer,
that re-routes input from the scene previewer to the modes. We'll create our own interaction mode that will allow
us to move points of the line. Every interaction mode must implement <code>InteractionMode</code>
<a href="https://docs.rs/fyroxed_base/latest/fyroxed_base/interaction/trait.InteractionMode.html">trait</a>. Unfortunately, the
editor's still mostly undocumented, due to its unstable API. There are quite a lot of methods in this trait:</p>
<ul>
<li><code>on_left_mouse_button_down</code> - called when left mouse button was pressed in the scene viewer.</li>
<li><code>on_left_mouse_button_up</code> - called when left mouse button was released in the scene viewer.</li>
<li><code>on_mouse_move</code> - called when mouse cursor moves in the scene viewer.</li>
<li><code>update</code> - called every frame (only for active mode, inactive modes does are not updated).</li>
<li><code>activate</code> - called when an interaction mode became active.</li>
<li><code>deactivate</code> - called when an interaction mode became inactive (i.e. when you're switched to another mode).</li>
<li><code>on_key_down</code> - called when a key was pressed.</li>
<li><code>on_key_up</code> - called when a key was released.</li>
<li><code>handle_ui_message</code> - called when the editor receives a UI message</li>
<li><code>on_drop</code> - called on every interaction mode before the current scene is destroyed.</li>
<li><code>on_hot_key_pressed</code> - called when a hotkey was pressed. Could be used to switch sub-modes of interaction mode.
For example, tile map editor has single interaction mode, but the mode itself has draw/erase/pick/etc. sub modes which
could be switched using <code>Ctrl</code>/<code>Alt</code>/etc. hotkeys.</li>
<li><code>on_hot_key_released</code> - called when a hotkey was released.</li>
<li><code>make_button</code> - used to create a button, that will be placed.</li>
<li><code>uuid</code> - must return type UUID of the mode.</li>
</ul>
<p>Every method has its particular use case, but we'll use only a handful of them. Let's create a new interaction mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DragContext {
    point_index: usize,
    initial_position: Vector3&lt;f32&gt;,
    plane_kind: PlaneKind,
}

#[derive(TypeUuidProvider)]
#[type_uuid(id = "d7f56947-a106-408a-9c18-d0191ef89925")]
pub struct MyInteractionMode {
    move_gizmo: MoveGizmo,
    node_handle: Handle&lt;Node&gt;,
    drag_context: Option&lt;DragContext&gt;,
    message_sender: MessageSender,
    line_points_gizmo: LinePointsGizmo,
    selected_point_index: Option&lt;usize&gt;,
}

impl MyInteractionMode {
    pub fn new(
        game_scene: &amp;GameScene,
        engine: &amp;mut Engine,
        message_sender: MessageSender,
        node_handle: Handle&lt;Node&gt;,
    ) -&gt; Self {
        Self {
            move_gizmo: MoveGizmo::new(game_scene, engine),
            node_handle,
            drag_context: None,
            message_sender,
            line_points_gizmo: LinePointsGizmo::default(),
            selected_point_index: None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To create an interaction mode all that is needed is to add the following lines in <code>on_message</code>, right after
<code>self.node_handle = *node_handle;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>                    entry.interaction_modes.add(MyInteractionMode::new(
                        game_scene,
                        &amp;mut editor.engine,
                        editor.message_sender.clone(),
                        *node_handle,
                    ));
<span class="boring">}</span></code></pre></pre>
<p>The mode must be deleted when we deselect something else, it could be done on <code>Message::SelectionChanged</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Message::SelectionChanged { .. } = message {

            if let Some(mode) = entry.interaction_modes.remove_typed::&lt;MyInteractionMode&gt;() {
                mode.move_gizmo.destroy(&amp;mut scene.graph);
            }
<span class="boring">}</span></code></pre></pre>
<p>Now onto the <code>InteractionMode</code> trait implementation, let's start by adding implementation for <code>make_button</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn make_button(&amp;mut self, ctx: &amp;mut BuildContext, selected: bool) -&gt; Handle&lt;UiNode&gt; {
        make_interaction_mode_button(ctx, include_bytes!("icon.png"), "Line Edit Mode", selected)
    }
<span class="boring">}</span></code></pre></pre>
<p>There's nothing special about it - it uses built-in function, that creates a button with an image and a tooltip. You
could use any UI widget here that sends <code>ButtonMessage::Click</code> messages on interaction. Now onto the <code>on_left_mouse_button_down</code>
method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_left_mouse_button_down(
        &amp;mut self,
        editor_selection: &amp;Selection,
        controller: &amp;mut dyn SceneController,
        engine: &amp;mut Engine,
        mouse_pos: Vector2&lt;f32&gt;,
        frame_size: Vector2&lt;f32&gt;,
        settings: &amp;Settings,
    ) {
        let Some(game_scene) = controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut engine.scenes[game_scene.scene];

        // Pick scene entity at the cursor position.
        if let Some(result) = game_scene.camera_controller.pick(
            &amp;scene.graph,
            PickingOptions {
                cursor_pos: mouse_pos,
                editor_only: true,
                filter: Some(&amp;mut |handle, _| handle != self.move_gizmo.origin),
                ..Default::default()
            },
        ) {
            // The gizmo needs to be fed with input events as well, so it can react to the cursor.
            if let Some(plane_kind) = self.move_gizmo.handle_pick(result.node, &amp;mut scene.graph) {
                // Start point dragging if there's any point selected.
                if let Some(selected_point_index) = self.selected_point_index {
                    self.drag_context = Some(DragContext {
                        point_index: selected_point_index,
                        initial_position: scene.graph
                            [self.line_points_gizmo.point_nodes[selected_point_index]]
                            .global_position(),
                        plane_kind,
                    })
                }
            } else {
                // Handle point picking and remember a selected point.
                for (index, point_handle) in self.line_points_gizmo.point_nodes.iter().enumerate() {
                    if result.node == *point_handle {
                        self.selected_point_index = Some(index);
                    }
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>It is responsible for two things: it handles picking of scene nodes at the cursor position, and it is also changes
currently selected point. Additionally, it creates dragging context if one of the axes of the movement gizmo was clicked
and there's some point selected.</p>
<p>When there's something to drag, we must use new mouse position to determine new location for points in 3D space. There's
<code>on_mouse_move</code> for that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_mouse_move(
        &amp;mut self,
        mouse_offset: Vector2&lt;f32&gt;,
        mouse_position: Vector2&lt;f32&gt;,
        editor_selection: &amp;Selection,
        controller: &amp;mut dyn SceneController,
        engine: &amp;mut Engine,
        frame_size: Vector2&lt;f32&gt;,
        settings: &amp;Settings,
    ) {
        let Some(game_scene) = controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut engine.scenes[game_scene.scene];

        if let Some(drag_context) = self.drag_context.as_ref() {
            let global_offset = self.move_gizmo.calculate_offset(
                &amp;scene.graph,
                game_scene.camera_controller.camera,
                mouse_offset,
                mouse_position,
                frame_size,
                drag_context.plane_kind,
            );

            if let Some(script) = scene
                .graph
                .try_get_script_of_mut::&lt;MyScript&gt;(self.node_handle)
            {
                script.points[drag_context.point_index] =
                    drag_context.initial_position + global_offset;
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>The dragging could be finished simply by releasing the left mouse button:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_left_mouse_button_up(
        &amp;mut self,
        editor_selection: &amp;Selection,
        controller: &amp;mut dyn SceneController,
        engine: &amp;mut Engine,
        mouse_pos: Vector2&lt;f32&gt;,
        frame_size: Vector2&lt;f32&gt;,
        settings: &amp;Settings,
    ) {
        let Some(game_scene) = controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut engine.scenes[game_scene.scene];

        if let Some(drag_context) = self.drag_context.take() {
            if let Some(script) = scene
                .graph
                .try_get_script_of_mut::&lt;MyScript&gt;(self.node_handle)
            {
                // Restore the position of the point and use its new position as the value for
                // the command below.
                let new_position = std::mem::replace(
                    &amp;mut script.points[drag_context.point_index],
                    drag_context.initial_position,
                );

                // Confirm the action by creating respective command.
                self.message_sender.do_command(SetPointPositionCommand {
                    node_handle: self.node_handle,
                    point_index: drag_context.point_index,
                    point_position: new_position,
                });
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This is where the action must be "confirmed" - we're creating a new command and sending it for execution in the
command stack of the current scene. The command used in this method could be defined like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct SetPointPositionCommand {
    node_handle: Handle&lt;Node&gt;,
    point_index: usize,
    point_position: Vector3&lt;f32&gt;,
}

impl SetPointPositionCommand {
    fn swap(&amp;mut self, context: &amp;mut dyn CommandContext) {
        // Get typed version of the context, it could also be UiSceneContext for
        // UI scenes.
        let context = context.get_mut::&lt;GameSceneContext&gt;();
        // Get a reference to the script instance.
        let script = context.scene.graph[self.node_handle]
            .try_get_script_mut::&lt;MyScript&gt;()
            .unwrap();
        // Swap the position of the point with the one stored in the command.
        std::mem::swap(
            &amp;mut script.points[self.point_index],
            &amp;mut self.point_position,
        );
    }
}

impl CommandTrait for SetPointPositionCommand {
    fn name(&amp;mut self, context: &amp;dyn CommandContext) -&gt; String {
        "Set Point Position".to_owned()
    }

    fn execute(&amp;mut self, context: &amp;mut dyn CommandContext) {
        self.swap(context)
    }

    fn revert(&amp;mut self, context: &amp;mut dyn CommandContext) {
        self.swap(context)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See the next section for more info about commands and how they interact with the editor.</p>
<p>The next step is to update the gizmo on each frame:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update(
        &amp;mut self,
        editor_selection: &amp;Selection,
        controller: &amp;mut dyn SceneController,
        engine: &amp;mut Engine,
        settings: &amp;Settings,
    ) {
        let Some(game_scene) = controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut engine.scenes[game_scene.scene];

        self.line_points_gizmo
            .sync_to_model(self.node_handle, game_scene, &amp;mut scene.graph);
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>As was mentioned previously, any modification to scene node's content (including scripts) must be done using commands.
Commands encapsulates an "atomic" action, this could be simple property or collection modification or something complex,
that involves heavy calculations and so on. The editor has a command stack that executes incoming commands and saves them
for potential undo. The stack has a top command, when new command is added to the stack, it removes all command prior the
top and makes the new command the top one. Every removed command is finalized (see below).</p>
<p>There are two ways of using commands: use reflection-based command, or use custom command. Reflection-based commands
usually used when you need to set a new value to some property. On the other hand, custom commands could perform complex
actions, that cannot be done using reflection-based command. The previous section contains an example of custom command,
they're quite verbose and require decent amount of boilerplate code.</p>
<h3 id="custom-commands"><a class="header" href="#custom-commands">Custom Commands</a></h3>
<p>Custom commands is the best way to get better understanding of command system and how it works. This section explains
how to create custom commands and how they're executed. Each command must implement <code>Command</code> trait which looks like
this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct ExampleCommand {}

impl CommandTrait for ExampleCommand {
    fn name(&amp;mut self, context: &amp;dyn CommandContext) -&gt; String {
        // This method is called to get a name for the command which it will show
        // in the command stack viewer.
        "Command".to_string()
    }

    fn execute(&amp;mut self, context: &amp;mut dyn CommandContext) {
        // This method is called when the editor executes the command.
    }

    fn revert(&amp;mut self, context: &amp;mut dyn CommandContext) {
        // This method is called when the editor undo the command.
    }

    fn finalize(&amp;mut self, _: &amp;mut dyn CommandContext) {
        // This method is called when the command is about to be destroyed.
        // Its main use case is mark some resources as free when they were previously
        // reserved by `execute` or `revert`. Usually it is for reserved handles in Pool.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This chapter already showed an example of a custom command:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct SetPointPositionCommand {
    node_handle: Handle&lt;Node&gt;,
    point_index: usize,
    point_position: Vector3&lt;f32&gt;,
}

impl SetPointPositionCommand {
    fn swap(&amp;mut self, context: &amp;mut dyn CommandContext) {
        // Get typed version of the context, it could also be UiSceneContext for
        // UI scenes.
        let context = context.get_mut::&lt;GameSceneContext&gt;();
        // Get a reference to the script instance.
        let script = context.scene.graph[self.node_handle]
            .try_get_script_mut::&lt;MyScript&gt;()
            .unwrap();
        // Swap the position of the point with the one stored in the command.
        std::mem::swap(
            &amp;mut script.points[self.point_index],
            &amp;mut self.point_position,
        );
    }
}

impl CommandTrait for SetPointPositionCommand {
    fn name(&amp;mut self, context: &amp;dyn CommandContext) -&gt; String {
        "Set Point Position".to_owned()
    }

    fn execute(&amp;mut self, context: &amp;mut dyn CommandContext) {
        self.swap(context)
    }

    fn revert(&amp;mut self, context: &amp;mut dyn CommandContext) {
        self.swap(context)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The main idea is very simple, <code>execute</code> must do the required change and <code>revert</code> must undo it. There's one special
method that has very limited use, but it cannot be avoided. <code>finalize</code> is used to return reserved resources back to
where they were obtained from. Typically, it is pool handles that can be reserved for further use. If they won't be
returned, pool will have empty unused entries forever.</p>
<h3 id="reflection-based-commands"><a class="header" href="#reflection-based-commands">Reflection-based Commands</a></h3>
<p>There are three main types of reflection-based commands that can be used to manipulate scene objects:</p>
<h4 id="setpropertycommand"><a class="header" href="#setpropertycommand"><code>SetPropertyCommand</code></a></h4>
<p>Sets a new value for a property at the given path. This command cannot change the size of collections (add or remove
items), the next two commands are exactly for this (see next subsections). This is how you could use this command to
change position of a point at index 1:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_point_1(node_handle: Handle&lt;Node&gt;, message_sender: &amp;MessageSender) {
    message_sender.do_command(SetPropertyCommand::new(
        "points[1]".to_string(),
        Box::new(Vector3::new(1.0, 2.0, 3.0)),
        // Entity getter supplies a reference to the base object, which will be used
        // to search on for the property with the specified name.
        move |ctx| {
            ctx.get_mut::&lt;GameSceneContext&gt;()
                .scene
                .graph
                .node_mut(node_handle)
                .try_get_script_mut::&lt;MyScript&gt;()
                .unwrap()
        },
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>The first argument is a path to variable, it could be any "depth" and support enum variants, indices, etc:
<code>foo.bar.baz@Some.collection[123].stuff</code>. Enum variants are marked by <code>@</code> sign. The second argument is a new value for
the property. It could be any object that implements <code>Reflect</code> trait, in our case it is <code>Vector3&lt;f32&gt;</code>. The last argument
is entity getter function. Its purpose is to provide a reference to an object in which the reflection system will search
for the property with the given name.</p>
<h4 id="addcollectionitemcommand"><a class="header" href="#addcollectionitemcommand"><code>AddCollectionItemCommand</code></a></h4>
<p>Adds a new collection item command at the given path. The collection could be anything that implements <code>ReflectList</code>
trait (<code>Vec</code>, <code>ArrayVec</code>, custom types) or <code>ReflectHashMap</code> trait (<code>HashMap</code>, <code>FxHashMap</code>, custom types). Typical usage
is something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_collection_element(node_handle: Handle&lt;Node&gt;, message_sender: &amp;MessageSender) {
    message_sender.do_command(AddCollectionItemCommand::new(
        "points".to_string(),
        Box::new(Vector3::new(1.0, 2.0, 3.0)),
        // Entity getter supplies a reference to the base object, which will be used
        // to search on for the property with the specified name.
        move |ctx| {
            ctx.get_mut::&lt;GameSceneContext&gt;()
                .scene
                .graph
                .node_mut(node_handle)
                .try_get_script_mut::&lt;MyScript&gt;()
                .unwrap()
        },
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>The meaning of each argument is the same as in <code>SetPropertyCommand</code> command.</p>
<h4 id="removecollectionitemcommand"><a class="header" href="#removecollectionitemcommand"><code>RemoveCollectionItemCommand</code></a></h4>
<p>Removes an item from a collection by the given index. The collection could be anything that implements <code>ReflectList</code>
trait (<code>Vec</code>, <code>ArrayVec</code>, custom types) or <code>ReflectHashMap</code> trait (<code>HashMap</code>, <code>FxHashMap</code>, custom types). In case of
hash maps, the index cannot be used reliably, because hash maps do not have an ability to be randomly indexed. To remove
the exact element at the index, you must ensure that <code>hash_map.iter().nth(index)</code> corresponds to the item and only then
use this index in the command. Typical usage is something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_collection_element(node_handle: Handle&lt;Node&gt;, message_sender: &amp;MessageSender) {
    message_sender.do_command(RemoveCollectionItemCommand::new(
        "points".to_string(),
        1,
        // Entity getter supplies a reference to the base object, which will be used
        // to search on for the property with the specified name.
        move |ctx| {
            ctx.get_mut::&lt;GameSceneContext&gt;()
                .scene
                .graph
                .node_mut(node_handle)
                .try_get_script_mut::&lt;MyScript&gt;()
                .unwrap()
        },
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>The first argument in this command a name of the collection property, the second - item index, and the third is the
entity getter. See <code>SetPropertyCommand</code> for more info.</p>
<h2 id="contextual-panels"><a class="header" href="#contextual-panels">Contextual Panels</a></h2>
<p>In some cases you may want to have a panel, that opens when you select a node with the script. This panel could contain
any UI elements. For educational purposes, we'll create a contextual panel that will create a line using two points
and a number of segments.</p>
<p>(TODO)</p>
<h2 id="preview-mode-2"><a class="header" href="#preview-mode-2">Preview Mode</a></h2>
<p>Preview mode allows you to see objects in dynamic directly in the scene preview window. It is a special mode of the
editor, where it updates and renders every frame and power-saving mode is disabled. It could be useful to preview
various animations.</p>
<p>(TODO)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<p>This section contains information about miscellaneous things, which does not deserve separate section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>The engine has built-in logger that allows you to trace execution of your game by creating log entries when needed.</p>
<p><img src="misc/log.png" alt="Log" /></p>
<p>The window allows you to select severity of the messages that will be put in the window:</p>
<ul>
<li><code>Info+</code> will show all messages with <code>Info</code>, <code>Warning</code>, <code>Error</code> severities.</li>
<li><code>Warning+</code> will show all messages with <code>Warning</code> and <code>Error</code> severities.</li>
<li><code>Error</code> will show all messages with only <code>Error</code> severity.</li>
</ul>
<p>Each log entry can be copied to the clipboard by right-clicking on it and pressing <code>Copy</code> in the context menu. You can
also clear the log using <code>Clear</code> button.</p>
<h2 id="writing-to-the-log"><a class="header" href="#writing-to-the-log">Writing to the log</a></h2>
<p>You can use one of <code>Log::info</code>, <code>Log::warn</code>, <code>Log::err</code> methods, or use <code>Log::writeln</code> with severity specified. It is also
possible to select desired severity level:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::log::{Log, MessageKind};
</span>// These lines will be printed.
Log::info("This is some info");
Log::warn("This is some warning");
Log::err("This is some error");

Log::set_verbosity(MessageKind::Warning);

Log::info("This is some info"); // This won't be printed.
Log::warn("This is some warning");
Log::err("This is some error");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shipping"><a class="header" href="#shipping">Shipping</a></h1>
<p>This chapter explains how to build your game for various target platforms. On most platforms (PC, WebAssembly) you can
use automated build system:</p>
<p><img src="shipping/pc_build.png" alt="PC Build" /></p>
<p>The editor provides a special tool that can create a build for shipping in a few clicks. It can be opened by going to
<code>File -&gt; Export Project...</code>. At first, you need to select a target platform from the list of available platforms.
Then specify the data folders, ignored extensions of assets, data folders, etc. Finally, click <code>Export</code> and wait until
your game build is done. It can take from few minutes to tens of minutes, depending on the size of your game.</p>
<p>See next chapters, to learn more info about desired target platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pc"><a class="header" href="#pc">PC</a></h1>
<p>PC builds can be created using either the automatic approach using the editor or manual. This chapter covers both
ways.</p>
<h2 id="automatic-1"><a class="header" href="#automatic-1">Automatic</a></h2>
<p><img src="shipping/pc_build.png" alt="PC Build" /></p>
<p>The editor provides a special tool that can create a build for shipping in a few clicks. It can be opened by going to
<code>File -&gt; Export Project...</code>. At first, you need to select a target platform from the list of available platforms.
Then specify the data folders, ignored extensions of assets, data folders, etc. Finally, click <code>Export</code> and wait until
your game build is done. It can take from few minutes to tens of minutes, depending on the size of your game.</p>
<h2 id="manual-1"><a class="header" href="#manual-1">Manual</a></h2>
<p>Manual build consists of three main steps:</p>
<ul>
<li>Building the game for desired platform.</li>
<li>Copying assets.</li>
<li>Bundling everything together.</li>
</ul>
<p>Your game can be built pretty easily by a single <code>cargo</code> command:</p>
<pre><code class="language-shell">cargo build --package executor --release
</code></pre>
<p>This command will create an executable file of your game in <code>target/release</code> folder. Go to this folder and copy the
<code>executor</code> file (it can have different extension depending on your platform). Create a folder for your final game build
and copy the <code>executor</code> file there.</p>
<p>Now go to the root directory of your game and copy all assets folders (for example, <code>data</code> folder) and paste it in the
folder with your executable. This is pretty much all you need to create a simple build. However, this solution is far
from optimal, because it clones all the assets, even those that aren't actually used in the final build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h1>
<p>WebAssembly builds can be created using either the automatic approach using the editor or manual. This chapter covers
both ways.</p>
<h2 id="automated"><a class="header" href="#automated">Automated</a></h2>
<p>Use the <a href="shipping/shipping.html">project exporter</a> for automated builds.</p>
<h2 id="manual-2"><a class="header" href="#manual-2">Manual</a></h2>
<p>WebAssembly builds requires a bit of preparations. Install <code>wasm-pack</code> first:</p>
<pre><code class="language-shell">cargo install wasm-pack
</code></pre>
<p>Then run the following commands:</p>
<pre><code class="language-shell">cd executor-wasm
wasm-pack build --target=web --release 
</code></pre>
<p>This command will produce <code>pkg</code> folder in the <code>executor-wasm</code> directory. Now create a folder for your game build, and
you need to copy the <code>pkg</code> folder together with <code>index.html</code>, <code>main.js</code>, <code>styles.css</code> to the folder of your final build.
As the last step you need to copy <code>data</code> folder in the same folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android"><a class="header" href="#android">Android</a></h1>
<p>Android builds requires a lot of preparation steps which include:</p>
<ul>
<li>Android build target installation</li>
<li><code>cargo-apk</code> installation</li>
<li>Android Studio</li>
<li>Android SDK installation (at least API level 26)</li>
<li>NDK installation</li>
<li>CMake installation</li>
<li>JRE installation</li>
</ul>
<p>Install <code>cargo-apk</code> first:</p>
<pre><code class="language-shell">cargo install cargo-apk
</code></pre>
<p>Install Android build target, for example <code>armv7-linux-androideabi</code>:</p>
<pre><code class="language-shell">rustup target add armv7-linux-androideabi
</code></pre>
<p>You should install appropriate target for your target device (or emulator), it could also be <code>x86_64-linux-android</code>.</p>
<p><a href="https://developer.android.com/studio/index.html">Install Android Studio</a> first. Then install NDK by following
these <a href="https://developer.android.com/studio/projects/install-ndk">instructions</a>.</p>
<p>Setup environment variables, you need to set two of them to correct paths: <code>ANDROID_HOME</code> and <code>ANDROID_NDK_ROOT</code>.
Follow these <a href="https://developer.android.com/tools/variables">instructions</a></p>
<p>Install Java Runtime Environment from <a href="https://www.java.com/ru/download/manual.jsp">here</a> and add <code>bin</code> folder
of it to your <code>PATH</code> variable. On Windows it could be <code>C:\Program Files\Java\jre-1.8\bin</code>.</p>
<p>Now you can build your game by running the following command from <code>executor-android</code> folder:</p>
<pre><code class="language-shell">cargo-apk apk build --target=armv7-linux-androideabi
</code></pre>
<h2 id="automation"><a class="header" href="#automation">Automation</a></h2>
<p>Use the <a href="shipping/shipping.html">project exporter</a> for automated builds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>The book offers a set of tutorials of how to write a game of specific genre using the engine. Every tutorial starts
from mild difficulty and keep increasing the difficulty until the end. All tutorials are very well-structured, and
you shouldn't be able to lost in them.</p>
<p>Source code for every tutorial can be found <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main/src/code/tutorials">here</a>.</p>
<p>All tutorials in the book are ordered from simplest to hardest, and each chapter in each tutorial is also ordered in
the same way.</p>
<p>Code snippets in all tutorials does not include required imports, you should use a good IDE (Visual Studio Code + rust-analyzer,
IntelliJ IDEA + Rust Plugin, RustRover, etc.) that can import all missing stuff for your project. Alternatively, you can always
look at the source code of all tutorials in the link above. This is intentional, to reduce the size of all tutorials;
to prevent them from bloating with useless information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2d-platformer-tutorial"><a class="header" href="#2d-platformer-tutorial">2D Platformer Tutorial</a></h1>
<p>2D games are the easiest games to make for beginners, and this tutorial will teach you how to use basics of the engine
while creating a 2D platformer.</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>Source code for the entire tutorial is <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main/src/code/tutorials/platformer">available here</a>.</p>
<h2 id="engine-version-1"><a class="header" href="#engine-version-1">Engine Version</a></h2>
<p>This tutorial is made using Fyrox 0.34.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-controller"><a class="header" href="#character-controller">Character Controller</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="tutorials/platformer/part1.html#2d-platformer-tutorial">2D Platformer Tutorial</a>
<ul>
<li><a href="tutorials/platformer/part1.html#table-of-contents">Table of Contents</a></li>
<li><a href="tutorials/platformer/part1.html#introduction">Introduction</a></li>
<li><a href="tutorials/platformer/part1.html#project">Project</a></li>
<li><a href="tutorials/platformer/part1.html#using-the-editor">Using the Editor</a></li>
<li><a href="tutorials/platformer/part1.html#scripts---player">Scripts - Player</a></li>
<li><a href="tutorials/platformer/part1.html#animation">Animation</a></li>
<li><a href="tutorials/platformer/part1.html#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>In this tutorial, we'll make a character controller for our 2D platformer. Here's what you'll get after finishing the tutorial:</p>
<iframe width="560" height="315" src="https://youtube.com/embed/EcvtwEkBxNU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>You can find the source code of the tutorial <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main/src/code/tutorials/platformer">here</a>, you can
test it yourself by cloning the repository and <code>cargo run --package editor --release</code> in the <code>platformer</code> directory.</p>
<h2 id="project"><a class="header" href="#project">Project</a></h2>
<p>Let's start by making a new project using the special tiny tool - <code>fyrox-template</code> - it allows you to generate all boilerplate
parts in a single call. Install it using the following command:</p>
<pre><code class="language-shell">cargo install fyrox-template
</code></pre>
<p>Navigate to a folder where you want the project to be created and do the following command:</p>
<pre><code class="language-shell">fyrox-template init --name platformer --style 2d
</code></pre>
<p>The tool accepts two arguments - project name and a style, we're interested in 2D game so the style is set to 2D. After
the project is generated, you should memorize two commands:</p>
<ul>
<li><code>cargo run --package editor --release</code> - launches the editor with your game attached, the editor allows you to run your game
inside it and edit game entities. It is intended to be used only for development.</li>
<li><code>cargo run --package executor --release</code> - creates and runs the production binary of your game that can be shipped (for
example - to a store).</li>
</ul>
<p>Navigate to the <code>platformer</code> directory and run <code>cargo run --package editor --release</code>, after some time you should see the editor:</p>
<p><img src="tutorials/platformer/editor.png" alt="editor" /></p>
<p>Great! Now we can start making our game. Go to <code>game/src/lib.rs</code> - it is where your game logic is located, as you can see
the <code>fyrox-template</code> generate quite some code for you. There are tiny comments about which place is for what. For more info
about each method, please refer <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">to the docs</a>.</p>
<h2 id="using-the-editor-4"><a class="header" href="#using-the-editor-4">Using the Editor</a></h2>
<p>For now, we don't even need to write a single line of code, we can create a scene entirely in the editor. This section will guide
you through the process of scene creation, as a final result we'll get something similar to this:</p>
<p><img src="tutorials/platformer/editor_with_scene.png" alt="editor with scene" /></p>
<p>At first, we need some assets, I prepared all required (and some more) in a separate zip archive, so you don't need to search
assets all over the internet. Download assets from <a href="tutorials/platformer/assets.zip">here</a> and unpack them in a <code>data</code> folder in the root folder of
your project.</p>
<p>Let's start filling the scene. Run the editor and remove all content from the generated scene. Since we're making a 2D game, switch the editor's
camera mode to <code>2D</code> at the top toolbar of the scene preview window. Now we need to populate the scene with some objects,
we'll start by adding a simple ground block. Right-click on <code>__ROOT__</code> of the scene in <code>World Viewer</code> and select
<code>Add Child -&gt; Physics2D -&gt; Rigid Body</code>. This will create a rigid body for the ground block, select the rigid body, and
set <code>Body Type</code> to <code>Static</code> in <code>Inspector</code>, by doing this we're telling the physics engine that our ground block should not move
and be rock-solid. Every rigid body requires a collider, otherwise, the physics engine will not know how to handle collisions,
right-click on the rigid body in <code>Inspector</code> and click <code>Add Child -&gt; Physics2D -&gt; Collider</code>. We've just added a new collider to the rigid
body, by default it has a <code>Cuboid</code> shape with a <code>1.0</code> meter in height and width. Finally, we need to add some graphics to the rigid body,
right-click on the rigid body and click <code>Add Child -&gt; 2D -&gt; Rectangle</code>. This adds a simple 2D sprite, select it and set a texture
to it by finding the <code>Material</code> property in the Inspector, clicking <code>Edit</code> button near it and setting the <code>diffuseTexture</code>
property by simply drag'n'dropping the texture from the asset browser to the property. For my scene, I'm gonna be using
three sprites.</p>
<ul>
<li><code>data/tiles/13.png</code> - left ground block</li>
<li><code>data/tiles/14.png</code> - center ground block</li>
<li><code>data/tiles/15.png</code> - right ground block</li>
</ul>
<p>You can use any other textures and build your level as you like. After doing all these steps you should get something like this:</p>
<p><img src="tutorials/platformer/editor_step1.png" alt="editor_step1" /></p>
<p>Clone the block by selecting its rigid body and pressing <code>Ctrl+C</code> followed by <code>Ctrl+V</code>, navigate to sprite in the copy and change its
texture to either the left or right end of the block. Use <code>Move Tool</code> to move the block somewhere you like (you can also use grid-snapping
by going to <code>File -&gt; Setting</code> and setting <code>Snap To Grid</code> for <code>Move Interaction Mode</code>). Do this one more time for the opposite end and you
should get something like this:</p>
<p><img src="tutorials/platformer/editor_step2.png" alt="editor_step2" /></p>
<p>Repeat these steps if you like, to add more platforms. You can also add some background objects, by creating a new sprite
(right click <code>__ROOT__</code> and click <code>Add Child -&gt; 2D -&gt; Rectangle</code>) and assigning a texture to it:</p>
<p><img src="tutorials/platformer/editor_step3.png" alt="editor_step3" /></p>
<p>As the last step of world editing, let's add some dynamic objects, like boxes. Pick some random ground block, select its rigid body, and
clone it. Switch body type of the copy to <code>Dynamic</code>. Now change its sprite texture to a box (drag'n'drop <code>data/objects/Crate.png</code> to
<code>Texture</code> field) and clone the box a few times, you should get something like this:</p>
<p><img src="tutorials/platformer/editor_step4.png" alt="editor_step4" /></p>
<p>Now for the player. As always, let's start by creating a new rigid body, adding a 2D collider to it, and setting its shape to capsule with the following
parameters - <code>Begin = 0.0, 0.0</code> and <code>End = 0.0, 0.3</code>. Add a 2D sprite (rectangle) to the rigid body and set its texture to
<code>data/characters/adventurer/adventurer-Sheet.png</code>. Set its uv rect to <code>(0.0, 0.0, 0.143, 0.091)</code> to see only one frame.
We also need a camera, otherwise, we won't see anything. Add it as a child to a player's rigid body. By default, our
camera will have no background, there'll be a black "void", this is not great and let's fix that. Select the camera
and set the <code>Skybox</code> property to <code>Some</code>. Now go to asset browser and find <code>data/background/BG.png</code>, drag'n'drop it to
the <code>Front</code> field of the <code>Skybox</code> property. Don't forget to adjust the far plane distance to something like <code>20.0</code>,
otherwise, you'll see just a portion of the background image. If everything is done correctly, you should get something like this:</p>
<p><img src="tutorials/platformer/editor_step5.png" alt="editor_step5" /></p>
<p>Save your scene by goint to <code>File -&gt; Save Scene</code>. Now we can run the game using the <code>Play/Stop</code> button at the top of the
scene previewer. You should see pretty much the same as in the scene preview, except
for service graphics, such as rigid body shapes, node bounds, and so on. Now we can start writing scripts.</p>
<p>As the last preparation step, let's import all entities at the beginning, so you don't need to find them manually, add the following code
at the beginning of the <code>game/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::bot::Bot;
use fyrox::{
    core::{
        algebra::{Vector2, Vector3},
        pool::Handle,
        reflect::prelude::*,
        type_traits::prelude::*,
        visitor::prelude::*,
    },
    event::{ElementState, Event, WindowEvent},
    keyboard::{KeyCode, PhysicalKey},
    plugin::{Plugin, PluginContext, PluginRegistrationContext},
    scene::{
        animation::spritesheet::SpriteSheetAnimation,
        dim2::{rectangle::Rectangle, rigidbody::RigidBody},
        node::Node,
        Scene,
    },
    script::{ScriptContext, ScriptTrait},
};
use std::path::Path;
<span class="boring">}</span></code></pre></pre>
<h2 id="scripts---player"><a class="header" href="#scripts---player">Scripts - Player</a></h2>
<p>Our scene has pretty much everything we need to start adding scripts, we'll start from the <code>Player</code> script and make our character
move. Navigate to <code>game/src/lib.rs</code> and at the end of the file add the following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug, Clone, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "c5671d19-9f1a-4286-8486-add4ebaadaec")]
#[visit(optional)]
struct Player;

impl ScriptTrait for Player {
    // Called once at initialization.
    fn on_init(&amp;mut self, context: &amp;mut ScriptContext) {}

    // Put start logic - it is called when every other script is already initialized.
    fn on_start(&amp;mut self, context: &amp;mut ScriptContext) {}

    // Called whenever there is an event from OS (mouse click, keypress, etc.)
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: &amp;mut ScriptContext) {}

    // Called every frame at fixed rate of 60 FPS.
    fn on_update(&amp;mut self, context: &amp;mut ScriptContext) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This is a typical "skeleton" of any script, for now, its methods are pretty much empty, we'll fill it with actual code very soon.
Let's go over the most important parts. The snippet starts from the <code>Player</code> structure definition which has <code>#[derive(Visit, Inspect, Debug, Clone, Default)]</code>
attributes:</p>
<ul>
<li><code>Visit</code> - implements serialization/deserialization functionality, it is used by the editor to save your object to a scene file.</li>
<li><code>Inspect</code> - generates metadata for the fields of your type - in other words, it allows the editor to "see" what's inside
your structure and show additional information attached to the fields via proc-macro attributes.</li>
<li><code>Reflect</code> - implements compile-time reflection that allows the editor to mutate your objects.</li>
<li><code>Debug</code> - provides debugging functionality, it is mostly for the editor to let it print stuff into the console.</li>
<li><code>Clone</code> - makes your structure clone-able, why do we need this? We can clone objects, and we also want the script instance to be
copied.</li>
<li><code>Default</code> implementation is very important - the scripting system uses it to create your scripts in the default state.
This is necessary to set some data to it and so on. If it's a special case, you can always implement your own <code>Default</code>'s
implementation if it's necessary for your script.</li>
<li><code>TypeUuidProvider</code> is used to attach some unique id for your type, every script *<em>must</em> have a unique ID, otherwise, the engine will
not be able to save and load your scripts. To generate a new UUID, use <a href="https://www.uuidgenerator.net/">Online UUID Generator</a> or
any other tool that can generate UUIDs.</li>
</ul>
<p>Finally, we implement <code>ScriptTrait</code> for the <code>Player</code>. It has a bunch of methods, their names speak for themselves. Learn more about
every method in <a href="https://docs.rs/fyrox/latest/fyrox/script/trait.ScriptTrait.html">documentation</a></p>
<p>Before we can use the script in the editor, we must tell the engine that our script exists - we must register it. Remember that
<code>register</code> method in the <code>PluginConstructor</code> trait implementation? It is exactly for script registration, replace its implementation with the following
code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Plugin for Game {
    fn register(&amp;self, context: PluginRegistrationContext) {
        let script_constructors = &amp;context.serialization_context.script_constructors;
        script_constructors.add::&lt;Player&gt;("Player");
        // ...
<span class="boring">}</span></code></pre></pre>
<p>Now the engine knows about our script and will be able to use it. It is pretty much useless in the current state, but we can already
assign it to the player. Select the player's rigid body node and find <code>Script</code> in the <code>Inspector</code>, select <code>Player</code> from the respective
drop-down list and that's pretty much it - now the script is assigned:</p>
<p><img src="tutorials/platformer/script_selection.png" alt="script_selection" /></p>
<p>Let's learn how to edit script properties from the editor. In the next section, we'll be adding keyframe animation for your character,
it is a perfect opportunity to learn how the engine and the editor operate with user-defined properties in scripts. To animate the player
we need to get its sprite first. Let's start by adding the required field in the <code>Player</code> structure:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug, Clone, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "c5671d19-9f1a-4286-8486-add4ebaadaec")]
#[visit(optional)]
struct Player {
    sprite: Handle&lt;Node&gt;,
    // ... 
<span class="boring">}</span></code></pre></pre>
<p>After adding this, the editor will be able to see the field and give you the ability to edit it in the Inspector.
To assign the correct handle of the sprite to the respective field in script properties, hold <code>Alt</code> and start dragging
the sprite node from the world viewer to the respective field in the player script. Release the mouse button and if
everything is ok, the field should "say" something different than "Unassigned".</p>
<p>Alright, at this point we know how to work with script properties, now we can start adding basic movement for the player.
Go to the <code>Player</code> structure and add the following fields:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    move_left: bool,
    move_right: bool,
    jump: bool,
<span class="boring">}</span></code></pre></pre>
<p>These fields will store the state of keyboard keys responsible for player movement. Now for <code>on_os_event</code>, add the following code there:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Called everytime when there is an event from OS (mouse click, key press, etc.)
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, _context: &amp;mut ScriptContext) {
        if let Event::WindowEvent { event, .. } = event {
            if let WindowEvent::KeyboardInput { event, .. } = event {
                if let PhysicalKey::Code(keycode) = event.physical_key {
                    let is_pressed = event.state == ElementState::Pressed;

                    match keycode {
                        KeyCode::KeyA =&gt; self.move_left = is_pressed,
                        KeyCode::KeyD =&gt; self.move_right = is_pressed,
                        KeyCode::Space =&gt; self.jump = is_pressed,
                        _ =&gt; (),
                    }
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>The code responds to OS events and modifies internal movement flags accordingly. Now we need to use the flags somehow, it's time for
<code>on_update</code>. The method is called each frame and allows you to put game logic there:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_update(&amp;mut self, context: &amp;mut ScriptContext) {
        // The script can be assigned to any scene node, but we assert that it will work only with
        // 2d rigid body nodes.
        if let Some(rigid_body) = context.scene.graph[context.handle].cast_mut::&lt;RigidBody&gt;() {
            let x_speed = if self.move_left {
                3.0
            } else if self.move_right {
                -3.0
            } else {
                0.0
            };

            if self.jump {
                rigid_body.set_lin_vel(Vector2::new(x_speed, 4.0))
            } else {
                rigid_body.set_lin_vel(Vector2::new(x_speed, rigid_body.lin_vel().y))
            };
            // ...
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Finally, some interesting code. At first, we check if the node to which the script is assigned is a 2d rigid body, next
we're checking movement flags and form horizontal speed, and applying velocity to the body. Velocity is applied in two ways: if
the jump button was pressed - apply horizontal velocity and some vertical velocity for jumping. If the jump button wasn't pressed -
just change horizontal velocity - this will allow the player to free fall.</p>
<p>Run the editor and enter play mode, press <code>[A][D][Space]</code> buttons to check if everything works correctly - the player should move
horizontally and be able to jump. You can jump to the boxes on the right and push them off the ledge.</p>
<p>The movement is working, but the player does not change orientation, if we'll go to the left - it looks ok (despite the lack of animation),
but if we'll move to the right - it looks like the player moves backward. Let's fix that by changing the horizontal scaling of the player's
sprite. Add the following code at the end of the <code>if let ...</code> block of the code above:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            // It is always a good practice to check whether the handles are valid, at this point we don't know
            // for sure what's the value of the `sprite` field. It can be unassigned and the following code won't
            // execute. A simple `context.scene.graph[self.sprite]` would just panicked in this case.
            if let Some(sprite) = context.scene.graph.try_get_mut(self.sprite) {
                // We want to change player orientation only if he's moving.
                if x_speed != 0.0 {
                    let local_transform = sprite.local_transform_mut();

                    let current_scale = **local_transform.scale();

                    local_transform.set_scale(Vector3::new(
                        // Just change X scaling to mirror player's sprite.
                        current_scale.x.copysign(-x_speed),
                        current_scale.y,
                        current_scale.z,
                    ));
                }
            }
<span class="boring">}</span></code></pre></pre>
<p>The comments should clarify what's going on here, but in short, we're changing the horizontal scaling of the player's sprite if the player is
moving. The line <code>current_scale.x.copysign(-x_speed)</code> could be confusing, what it does? It replaces the sign of current horizontal scaling
using the opposite sign of <code>x_speed</code>.</p>
<p>Now if you run the game, the player will "look" in correct direction depending on the velocity vector.</p>
<h2 id="animation-5"><a class="header" href="#animation-5">Animation</a></h2>
<p>Since we're making a 2D game, we'll be using simple animations based on the continuous change of keyframes. In other words, we'll be changing
the texture of the player's body sprite. Luckily for us, the engine has built-in sprite sheet animations. Just add the
following fields to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    animations: Vec&lt;SpriteSheetAnimation&gt;,
    current_animation: u32,
<span class="boring">}</span></code></pre></pre>
<p>Currently, we just pass default values.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for Player {
    fn default() -&gt; Self {
        Self {
            // ...
            animations: Default::default(),
            current_animation: 0,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The Player will use multiple animations in future tutorials, but for now, it will use only two - idle and run.
Now we need to somehow switch animations. Go to <code>on_update</code> in <code>Player</code> and add the following lines after
the <code>x_speed</code> declaration:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            if x_speed != 0.0 {
                self.current_animation = 0;
            } else {
                self.current_animation = 1;
            }
<span class="boring">}</span></code></pre></pre>
<p>Here we assume that the run animation will be at index <code>1</code> and the idle animation at index <code>0</code>. We also need to
apply the texture from the current animation to the player's sprite, and add the following lines at the end of <code>on_update</code></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Some(current_animation) = self.animations.get_mut(self.current_animation as usize) {
            current_animation.update(context.dt);

            if let Some(sprite) = context
                .scene
                .graph
                .try_get_mut(self.sprite)
                .and_then(|n| n.cast_mut::&lt;Rectangle&gt;())
            {
                // Set new frame to the sprite.
                sprite
                    .material()
                    .data_ref()
                    .bind("diffuseTexture", current_animation.texture());
                sprite.set_uv_rect(
                    current_animation
                        .current_frame_uv_rect()
                        .unwrap_or_default(),
                );
            }
        }
<span class="boring">}</span></code></pre></pre>
<p>The code is pretty straightforward - we start by trying to get a reference to the current animation by its index,
and if we're succeeded, we update it. At the next step, we're getting sprite and assigning a current frame of
the current animation.</p>
<p>Now we need to go to the editor again and add the animations to the <code>Player</code>, select the player's rigid body, and
find the <code>Script</code> section in the <code>Inspector</code>. Add two animations there like so:</p>
<p><img src="tutorials/platformer/editor_step6.png" alt="editor_step6" /></p>
<p>After filling in the animations and turning them on, you can run the game and your character should play animations
correctly.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial, we've learned the basics of the new scripting system of the engine. The game we've built it very
simple, but it is just the beginning. It is easy to add more scripts for enemies, weapons, collectible items, and so on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bots-and-ai"><a class="header" href="#bots-and-ai">Bots and AI</a></h1>
<p>In this tutorial we'll add bots and a simple AI system to our 2D platformer. In the end we'll get something like this:</p>
<p><img src="tutorials/platformer/attack.gif" alt="attack" /></p>
<h2 id="bot-prefab"><a class="header" href="#bot-prefab">Bot Prefab</a></h2>
<p>Let's start by creating a prefab for our bots. Prefab is a separate scene, that can be instantiated at any time in some
other scene. It allows us to make reusable and well isolated parts of the game. At first, we need a sprite sheet for the
bot, we'll use <a href="https://astrobob.itch.io/animated-pixel-art-skeleton">this one</a>. It contains attack, hit, death, walk, idle animations. In this tutorial we'll use only
walk and attack animations, other animations will be used in the next tutorial. The sprite sheet looks like this - 13x5
sprites where every sprite is 64x64px:</p>
<p><img src="tutorials/platformer/skeleton.png" alt="skeleton" /></p>
<p>Save this image in the <code>data/characters</code> folder as <code>skeleton.png</code>. Open the editor and create a new scene, right-click on
the <code>__ROOT__</code> scene node and click on <code>Replace With -&gt; Physics 2D -&gt; Rigid Body</code>. Rename this node to <code>Skeleton</code> and then
create a <code>Rectangle</code> child node by right-clicking on the <code>Skeleton</code> node and doing <code>Create Child -&gt; 2D -&gt; Rectangle</code>,
select the new rectangle node and set its scale to <code>2.0, 2.0, 1.0</code> (default scale of 1.0 is too small and the skeleton
will be half of the height of our player). Now let's apply a texture to the rectangle, find <code>skeleton.png</code> in the asset
browser, select it, set its properties like on the screenshot below - all filtration modes to <code>Nearest</code> (to make its
pixels sharp, not blurry) and wrapping to <code>Clamp To Edge</code> (to prevent potential seams on the edges). Find the <code>Material</code>
property in the inspector and open the material editor, drag the <code>skeleton.png</code> texture from the asset browser to
<code>diffuseTexture</code> property in the material editor. Set the <code>UV Rect -&gt; Size</code> property to <code>0.077; 0.2</code> to select a single
sprite from the sprite sheet, and you should see something similar to this:</p>
<p><img src="tutorials/platformer/skeleton_prefab.png" alt="skeleton prefab" /></p>
<p>If you look closely at the world viewer, you should notice a small warning sign near the rigid body - the editor tells
us that we've forgotten to add a collider to the rigid body. Let's fix this by right-clicking on the rigid body, then
select <code>Create Child -&gt; Physics 2D -&gt; Collider</code>. Select the collider and set its shape to <code>Capsule</code> in the properties
like so:</p>
<p><img src="tutorials/platformer/capsule.png" alt="capsule" /></p>
<p>We're almost finished with our prefab, the last step is to configure properties of the rigid body. Currently, we
have a simple rigid body, that will rotate freely during collisions and will also "sleep" on inactivity, which will prevent
the body from moving. Let's fix this by selecting the rigid body in the inspector and disable rotational movement and
prevent it from sleeping:</p>
<p><img src="tutorials/platformer/rigid_body.png" alt="rigid body" /></p>
<p>The "skeleton" of our skeleton (pun intended) prefab is finished, and now we can start writing some code.</p>
<h2 id="script"><a class="header" href="#script">Script</a></h2>
<p>Now on to the code part, run the following command in the root folder of your game: <code>fyrox-template script --name=bot</code> and add
the <code>mod bot;</code> line at the beginning of <code>lib.rs</code> of the <code>game</code> package. The code for the script will look something like
this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Default, Debug, Clone, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "d2786d36-a0af-4e67-916a-438af62f818b")]
#[visit(optional)]
pub struct Bot {
    // Add fields here.
}

impl ScriptTrait for Bot {
    fn on_init(&amp;mut self, context: &amp;mut ScriptContext) {
        // Put initialization logic here.
    }

    fn on_start(&amp;mut self, context: &amp;mut ScriptContext) {
        // There should be a logic that depends on other scripts in scene.
        // It is called right after **all** scripts were initialized.
    }

    fn on_deinit(&amp;mut self, context: &amp;mut ScriptDeinitContext) {
        // Put de-initialization logic here.
    }

    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: &amp;mut ScriptContext) {
        // Respond to OS events here.
    }

    fn on_update(&amp;mut self, context: &amp;mut ScriptContext) {
        // Put object logic here.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We need only <code>on_update</code> method, and the rest methods can be removed. Register the script by adding
<code>script_constructors.add::&lt;Bot&gt;("Bot");</code> line near the <code>script_constructors.add::&lt;Player&gt;("Player");</code>
line in <code>lib.rs</code> (as we did in the previous part of the tutorial). We also need to import all required types for the bot,
replace all the imports at the beginning of the <code>bot.rs</code> with the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::Game;
use fyrox::{
    core::{
        algebra::{Vector2, Vector3},
        pool::Handle,
        reflect::prelude::*,
        type_traits::prelude::*,
        variable::InheritableVariable,
        visitor::prelude::*,
    },
    graph::{BaseSceneGraph, SceneGraph},
    scene::{
        animation::spritesheet::SpriteSheetAnimation,
        dim2::{
            collider::Collider, physics::RayCastOptions, rectangle::Rectangle, rigidbody::RigidBody,
        },
        node::Node,
        rigidbody::RigidBodyType,
    },
    script::{ScriptContext, ScriptTrait},
};
<span class="boring">}</span></code></pre></pre>
<p>We need to store a handle to the sprite in our script, add the following field in the <code>Bot</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    rectangle: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Open the skeleton prefab and assign the script to the root rigid body. Set the <code>rectangle</code> field to <code>Sprite (2D)</code> and
save the prefab. Great, now let's begin writing the actual AI code of the bot.</p>
<h3 id="patrol"><a class="header" href="#patrol">Patrol</a></h3>
<p>By default, when there's no target nearby the bot will patrol in available bounds. Basically, it will walk from one "wall"
to another. Add the following fields to the <code>Bot</code> script:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    speed: InheritableVariable&lt;f32&gt;,
    direction: f32,
    front_obstacle_sensor: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
    back_obstacle_sensor: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p><code>speed</code> field will define overall movement speed of the bot and <code>direction</code> will be used to alternate movement direction
along X axis. Open the skeleton prefab and set the speed to <code>1.2</code> and the direction to <code>-1.0</code>. Add the movement handling
code somewhere in the <code>impl Bot</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn do_move(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let Some(rigid_body) = ctx.scene.graph.try_get_mut_of_type::&lt;RigidBody&gt;(ctx.handle) else {
            return;
        };

        let y_vel = rigid_body.lin_vel().y;

        rigid_body.set_lin_vel(Vector2::new(-*self.speed * self.direction, y_vel));

        // Also, inverse the sprite along the X axis.
        let Some(rectangle) = ctx.scene.graph.try_get_mut(*self.rectangle) else {
            return;
        };

        rectangle.local_transform_mut().set_scale(Vector3::new(
            2.0 * self.direction.signum(),
            2.0,
            1.0,
        ));
    }
<span class="boring">}</span></code></pre></pre>
<p>This code is quite straightforward - at first, we're doing a checked borrow of the node that contains the script. It must
be of <code>dim2::RigidBody</code> type. Then we're setting horizontal speed of body using <code>speed</code> and <code>direction</code> variables we've
added earlier. As the last step we're changing horizontal scale of the sprite using sign of the current direction. This
way we're flipping the sprite in the current direction. Now we need to call <code>do_move</code> method in <code>on_update</code> like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        self.do_move(ctx);
<span class="boring">}</span></code></pre></pre>
<p>Open the main scene (<code>scene.rgs</code> by default) and find the skeleton prefab in the asset browser, drag'n'drop it in the
scene and adjust its position to get something like this:</p>
<p><img src="tutorials/platformer/skeleton_on_scene.png" alt="skeleton on scene" /></p>
<p>Run the game, and you should see the skeleton moving away from the player to the right. Cool, but the bot will be stuck
immediately when it hits a wall, so we also need a way of detecting obstacles along the way, so the bot could "understand"
when it should change movement direction. We'll use sensor collider for this purpose. Open the skeleton prefab and create
two new 2D colliders under the root <code>Skeleton</code> node, adjust their sizes to be something similar to the following screenshot:</p>
<p><img src="tutorials/platformer/obstacle_sensor.png" alt="obstacle sensor" /></p>
<p>It is very important to have <code>Is Sensor</code> property checked on both colliders, we don't need the collider to participate
in actual collision detection - it will be used only in intersection checks with the environment. Do not forget to assign
handles of both <code>FrontObstacleSensor</code> and <code>BackObstacleSensor</code> to the respective fields in the <code>Bot</code> script instance on
the root rigid body.</p>
<p>Now onto the movement algorithm, it is quite simple: move the bot horizontally in the current direction until one of the
obstacle sensors intersects with an obstacle. In this case all we need to do is to switch the current direction to opposite
(from 1.0 to -1.0 and vice versa). This way the bot will patrol arbitrary level parts quite easily and reliably and
there's no need to manually place any way points.</p>
<p>Obstacles checking algorithms is quite simple, add the following code in the <code>impl Bot</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn has_obstacles(&amp;mut self, ctx: &amp;mut ScriptContext) -&gt; bool {
        let graph = &amp;ctx.scene.graph;

        // Select the sensor using current walking direction.
        let sensor_handle = if self.direction &lt; 0.0 {
            *self.back_obstacle_sensor
        } else {
            *self.front_obstacle_sensor
        };

        // Check if it intersects something.
        let Some(obstacle_sensor) = graph.try_get_of_type::&lt;Collider&gt;(sensor_handle) else {
            return false;
        };

        for intersection in obstacle_sensor
            .intersects(&amp;ctx.scene.graph.physics2d)
            .filter(|i| i.has_any_active_contact)
        {
            for collider_handle in [intersection.collider1, intersection.collider2] {
                let Some(other_collider) = graph.try_get_of_type::&lt;Collider&gt;(collider_handle)
                else {
                    continue;
                };

                let Some(rigid_body) = graph.try_get_of_type::&lt;RigidBody&gt;(other_collider.parent())
                else {
                    continue;
                };

                if rigid_body.body_type() == RigidBodyType::Static {
                    return true;
                }
            }
        }

        false
    }
<span class="boring">}</span></code></pre></pre>
<p>At first, it selects the sensor using the current movement direction, then it fetches all intersection events from it
and checks if there's at least one static rigid body intersected. Remember, that we've set static rigid bodies for our
level tiles. As the final step, add the following code to the <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if self.has_obstacles(ctx) {
            self.direction = -self.direction;
        }
<span class="boring">}</span></code></pre></pre>
<p>This code is very simple - if there's an obstacle, then change movement direction to opposite. Now run the game and the
bot should change its direction when it detects an obstacle before it. It should look like this:</p>
<p><img src="tutorials/platformer/obstacle_checks.gif" alt="obstacle checks" /></p>
<p>There's no animations yet, but the basic movement works ok. We'll add animations later in this tutorial.</p>
<h3 id="ground-checks"><a class="header" href="#ground-checks">Ground Checks</a></h3>
<p>At this moment, our bot can move, but it can easily fall off the ledge into "abyss" and die. Let's prevent that by adding
ground check, that will be used to switch movement direction also. How will we check for ground presence anyway? We'll do
this using simple ray casting. At first, add the following fields to the bot script:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ground_probe: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
    ground_probe_distance: InheritableVariable&lt;f32&gt;,
    ground_probe_timeout: f32,
<span class="boring">}</span></code></pre></pre>
<p><code>ground_probe</code> field will be used to store a handle of a point scene node, that will be used as a starting point for ray
casting. <code>ground_probe_distance</code> field is used to define maximum distance, after which ray casting considered failed.
Now add the following code in the <code>impl Bot</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Bot {
    fn has_ground_in_front(&amp;self, ctx: &amp;ScriptContext) -&gt; bool {
        // Do ground check using ray casting from the ground probe position down at some distance.
        let Some(ground_probe) = ctx.scene.graph.try_get(*self.ground_probe) else {
            return false;
        };

        let ground_probe_position = ground_probe.global_position().xy();

        let mut intersections = Vec::new();
        ctx.scene.graph.physics2d.cast_ray(
            RayCastOptions {
                ray_origin: ground_probe_position.into(),
                // Cast the ray
                ray_direction: Vector2::new(0.0, -*self.ground_probe_distance),
                max_len: *self.ground_probe_distance,
                groups: Default::default(),
                // Make sure the closest intersection will be first in the list of intersections.
                sort_results: true,
            },
            &amp;mut intersections,
        );

        for intersection in intersections {
            let Some(collider) = ctx.scene.graph.try_get(intersection.collider) else {
                continue;
            };

            let Some(rigid_body) = ctx
                .scene
                .graph
                .try_get_of_type::&lt;RigidBody&gt;(collider.parent())
            else {
                continue;
            };

            if rigid_body.body_type() == RigidBodyType::Static
                &amp;&amp; intersection
                    .position
                    .coords
                    .metric_distance(&amp;ground_probe_position)
                    &lt;= *self.ground_probe_distance
            {
                return true;
            }
        }

        false
    }
<span class="boring">}</span></code></pre></pre>
<p>Open the skeleton prefab and create the ground probe like so:</p>
<p><img src="tutorials/platformer/ground_probe.png" alt="ground probe" /></p>
<p>Do not forget to assign its handle to the bot script as well. Add the final piece of code to <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        self.ground_probe_timeout -= ctx.dt;
        if self.ground_probe_timeout &lt;= 0.0 {
            if !self.has_ground_in_front(ctx) {
                self.direction = -self.direction;
            }
            self.ground_probe_timeout = 0.3;
        }
<span class="boring">}</span></code></pre></pre>
<p>Open the editor and add another skeleton somewhere, where it can easily fall off the ledge. Run the game and the skeleton
should avoid such place and walk back and forth on a platform.</p>
<h3 id="targets"><a class="header" href="#targets">Targets</a></h3>
<p>When the bot is patrolling, it will search for a target to attack. Bots will be able to attack only the player, so we just
need to check if the player is in front of a bot and close enough to it. We need a way to get player's handle, we could just
iterate over the scene and search for it at every frame, but that's inefficient and there's a better way. All we need to
do is to slightly modify the plugin and the player script. Add the following field to the plugin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    player: Handle&lt;Node&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Now we need to set this handle somehow, the ideal place for it is <code>on_start</code> method of the <code>Player</code> script:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        ctx.plugins.get_mut::&lt;Game&gt;().player = ctx.handle;
    }
<span class="boring">}</span></code></pre></pre>
<p>Great, now when the player script is created and initialized, it will register itself in the plugin. Now we can use this handle
in the bot's target searching routine. Add the following code to the <code>impl Bot</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn search_target(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let game = ctx.plugins.get::&lt;Game&gt;();

        let self_position = ctx.scene.graph[ctx.handle].global_position();

        let Some(player) = ctx.scene.graph.try_get(game.player) else {
            return;
        };

        let player_position = player.global_position();

        let signed_distance = player_position.x - self_position.x;
        if signed_distance.abs() &lt; 3.0 &amp;&amp; signed_distance.signum() != self.direction.signum() {
            self.target = game.player;
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This code is very straightforward - at first, we're fetching a reference to the plugin (in which we've just stored player's
handle). Then we're getting self position of the bot and player's position. Finally, to check if the bot can "see" the
player we're calculating horizontal distance between the player and the bot, checking its absolute value to be less than
some sensible threshold and also checking the sign of the distance. If the sign of the distance is opposite to the sign of
the direction, then the bot can see the player. As the last step, call this method in the <code>on_update</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        self.search_target(ctx);
<span class="boring">}</span></code></pre></pre>
<p>If there's a target, then the bot will follow it and try to attack when it is close enough. To implement this, all we need
to do is to alternate movement direction according to a target position. Add the following code in <code>on_update</code>, but after
any other direction modifications - target following will have priority over any other actions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if self.target.is_some() {
            let target_position = ctx.scene.graph[self.target].global_position();
            let self_position = ctx.scene.graph[ctx.handle].global_position();
            self.direction = (self_position.x - target_position.x).signum();

            // Stand still while attacking.
            if target_position.metric_distance(&amp;self_position) &gt; 1.1 {
                self.speed.set_value_and_mark_modified(1.2);
            } else {
                self.speed.set_value_and_mark_modified(0.0);
            }
        }
<span class="boring">}</span></code></pre></pre>
<h2 id="animations"><a class="header" href="#animations">Animations</a></h2>
<p>Our bot can patrol, search and follow targets, but all of this is not properly visualized since we're not using any animations
for such actions. Let's fix this, add the following fields to the <code>Bot</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    animations: Vec&lt;SpriteSheetAnimation&gt;,
    current_animation: InheritableVariable&lt;u32&gt;,
<span class="boring">}</span></code></pre></pre>
<p>As with the player from the previous tutorial, we'll use sprite sheet animations. Open the bot prefab and select the rigid
body, add five animations and fill every slot. For example, attack animation will look like this:</p>
<p><img src="tutorials/platformer/attack_animation.png" alt="attack animation" /></p>
<p>If you have any issues with this, see previous part of the tutorial to learn how to use sprite sheet animations editor.
Remember, that we have 5 animations and their indices are the following: 0 - attack, 1 - death, 2 - walk, 3 - idle, 4 - hit
reaction. Now on to the animation switching. We need to handle just two animations for now - walking and attacking. Add
the following code somewhere in the <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if self.direction != 0.0 {
            self.current_animation.set_value_and_mark_modified(2);
        }
        if self.target.is_some() {
            let target_position = ctx.scene.graph[self.target].global_position();
            let self_position = ctx.scene.graph[ctx.handle].global_position();
            if target_position.metric_distance(&amp;self_position) &lt; 1.1 {
                self.current_animation.set_value_and_mark_modified(0);
            }
        }
<span class="boring">}</span></code></pre></pre>
<p>Here we just switch current animation index. If the bot is moving, then movement animation is selected (with index 2) and
if there's a target (and it is close enough), then the attack animation is selected (with index 0). The last step is to
apply the animation to the bot's sprite. Add the following code at the end of <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Some(current_animation) = self.animations.get_mut(*self.current_animation as usize) {
            current_animation.update(ctx.dt);

            if let Some(sprite) = ctx
                .scene
                .graph
                .try_get_mut_of_type::&lt;Rectangle&gt;(*self.rectangle)
            {
                // Set new frame to the sprite.
                sprite
                    .material()
                    .data_ref()
                    .bind("diffuseTexture", current_animation.texture());
                sprite.set_uv_rect(
                    current_animation
                        .current_frame_uv_rect()
                        .unwrap_or_default(),
                );
            }
        }
<span class="boring">}</span></code></pre></pre>
<p>Run the game and you should see something like this:</p>
<p><img src="tutorials/platformer/attack.gif" alt="attack" /></p>
<p>You can create multiple instances of the skeleton and place them in different places on your level, to make the game more
interesting. This tutorial teaches about technical details, not game design, so use your imagination and experiment with
different approaches.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>In this tutorial we've learned how to create basic AI, that can patrol an area, search for a target, follow and attack it.
In the next tutorial we'll add damage system, ability to attack for the player and the bot and various items, such as
healing potions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="role-playing-game-tutorial"><a class="header" href="#role-playing-game-tutorial">Role-Playing Game Tutorial</a></h1>
<p>This tutorial starts the series of tutorials about writing a role-playing game in Rust using Fyrox game engine. Strangely,
but Fyrox has a reputation of an engine for 3D shooters. In this series I'll try to prove that it is a general purpose
game engine.</p>
<h2 id="source-code-1"><a class="header" href="#source-code-1">Source Code</a></h2>
<p>Source code for the entire tutorial is <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main/src/code/tutorials/rpg">available here</a>.</p>
<h2 id="engine-version-2"><a class="header" href="#engine-version-2">Engine Version</a></h2>
<p>This tutorial is made using Fyrox 0.34.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpg-tutorial-part-1---character-controller"><a class="header" href="#rpg-tutorial-part-1---character-controller">RPG Tutorial Part 1 - Character Controller</a></h1>
<p><strong>Source code</strong>: <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main/src/code/tutorials/rpg">GitHub</a></p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#introduction">Introduction</a></li>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#assets">Assets</a></li>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#player-prefab">Player Prefab</a>
<ul>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#camera">Camera</a></li>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#animations">Animations</a></li>
</ul>
</li>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#player-script">Player Script</a>
<ul>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#event-handling">Event Handling</a></li>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#logic">Logic</a></li>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#binding">Binding</a></li>
</ul>
</li>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#game-level">Level</a></li>
<li><a href="tutorials/rpg/tutorial-1/tutorial-part-1.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>In this series of tutorials we will make a game similar to The Elder Scrolls series (but much, much smaller indeed),
we'll have a main character, a simple world with intractable items and a few kind of enemies. In this series you'll
understand how to add an inventory, a quests journal, and the quests itself. This series should have at least 5
tutorials, but this might change. At the end of the series we'll have a playable RPG which you will be able to use to
continue making your own game. It is very ambitious, but totally doable with the current state of the engine.</p>
<p>Most of the role-playing games (RPGs for short) using 3rd person camera which allows you to see your character entirely.
In this tutorial we'll make something similar. Check the video with final result of the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/l2ZbDpoIdqk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>As you can see, at the end of the tutorial we'll be able to walk and explore a small fantasy world. Let's start by
creating a new game project, by running the following command:</p>
<p><code>fyrox-template init --name=rpg --style=3d</code></p>
<p>This command will create a new cargo workspace with a few projects inside, we're interested only in <code>game</code> folder
in this tutorial.</p>
<pre><code class="language-text">rpg
├───data
├───editor
│   └───src
├───executor
│   └───src
├───executor-android
│   └───src
├───executor-wasm
│   └───src
└───game
    └───src
</code></pre>
<p>Learn more about <code>fyrox-template</code> command <a href="tutorials/rpg/tutorial-1/../../../beginning/scripting.html">here</a>. Now we can run
the game using <code>cargo run --package executor</code> command, and you should see a white cube floating in blue space.</p>
<blockquote>
<p>️⚠️ There are two important commands:<br />
To run the game use: <code>cargo run --package executor</code> command<br />
To run the editor use: <code>cargo run --package editor</code> command.</p>
</blockquote>
<h2 id="assets-1"><a class="header" href="#assets-1">Assets</a></h2>
<p>For any kind of game you need a lot of various assets, in our case we need a 3D model for our character, a set of
animations, a level, a set of textures for terrain, trees and bushes, barrels, etc. I prepared all assets as a single
ZIP archive which can be downloaded <a href="tutorials/rpg/tutorial-1/./data.zip">here</a>. Once you've downloaded it, unpack it in <code>./data</code> folder.</p>
<h2 id="player-prefab"><a class="header" href="#player-prefab">Player Prefab</a></h2>
<p>Let's start from assembling our player prefab, that will also have a camera controller in it. At first, let's find out
what the prefab is - prefab a scene, that contains some scene nodes, which can be instantiated to some other scene
while preserving "connection" between all properties of the nodes. It means, that if you change something in a prefab,
the changes will be reflected on every instance of it; on those properties that weren't modified. This is a condensed
explanation, that may look a bit complicated - <a href="tutorials/rpg/tutorial-1/../../../scene/prefab.html">read this</a> to learn more about prefabs.</p>
<p>Now let's open the editor (<code>cargo run --package editor</code>) and start making our prefab by creating a new scene. Save the
scene to <code>data/models/paladin/paladin.rgs</code> by going to <code>File -&gt; Save</code>. In the opened window, find the path and click
<code>Save</code>:</p>
<p><img src="tutorials/rpg/tutorial-1/save_prefab.png" alt="save prefab" /></p>
<p>Let's rename the root node of the scene to <code>Paladin</code> and change its type to <code>RigidBody</code>:</p>
<p><img src="tutorials/rpg/tutorial-1/replace_root.png" alt="replace root" /></p>
<p>We need this so out root node of the prefab could move in a scene to which it will be instantiated later. Make sure, that
the <code>X/Y/Z Rotation Locked</code> property is set to <code>true</code>. Also <code>Can Sleep</code> must be false, otherwise the rigid body will
be excluded from the physical simulation when it does not move. As you can see, the editor shows a small warning icon
near the root node - it warns us, that the rigid body does not have a collider and won't be able to participate in
physical simulation. Let's fix it by adding a capsule collider to it and setting its <code>Begin</code>, <code>End</code>, <code>Radius</code> properties
accordingly:</p>
<p><img src="tutorials/rpg/tutorial-1/capsule_collider.png" alt="capsule colliders" /></p>
<p>The next step is to add an actual character 3D model, this is very easy - find <code>paladin.fbx</code> in the asset browser using
its searching functionality and then drag'n'drop (click on the asset, and while holding the button, move the mouse in
the scene, then release the button) it to the scene:</p>
<p><img src="tutorials/rpg/tutorial-1/model.png" alt="model" /></p>
<p>Now we need to adjust its <code>Local Scale</code> property, because the model is too big. Set it to <code>0.01</code> for all 3 axes, like on
the screenshot above. Also, adjust position of the capsule collider, so it will fully enclose 3d model. Create a new
<code>Pivot</code> node called <code>ModelPivot</code> and attach the <code>paladin.fbx</code> node to it by drag'n'dropping the <code>paladin.fbx</code> node onto
<code>ModelPivot</code>. The reason why we need to do this will be explained later in the tutorial.</p>
<p><img src="tutorials/rpg/tutorial-1/model_pivot.png" alt="model pivot" /></p>
<h3 id="camera-1"><a class="header" href="#camera-1">Camera</a></h3>
<p>It is the time to add camera controller scene nodes. We need to add three nodes in a chain:</p>
<p><img src="tutorials/rpg/tutorial-1/camera_nodes_chain.png" alt="camera nodes chain" /></p>
<p>There are three nodes added:</p>
<ol>
<li><code>CameraPivot</code> (<code>Pivot</code> node type) - it will serve a pivot point around which we will rotate the camera around Y axis.
(horizontal camera rotation). It should be placed right at the center of the Paladin's head.</li>
<li><code>CameraHinge</code> (<code>Pivot</code> node type) - it will also be a pivot point, but for X axis (vertical camera rotation)</li>
<li><code>Camera</code> (<code>Camera</code> node type) - the camera itself, it should be placed on some distance from the Paladin's back.</li>
</ol>
<p>This nodes configuration will allow us to create some sort of "orbital" (also called arcball) camera as in many 3rd person
games nowadays.</p>
<h3 id="animations-1"><a class="header" href="#animations-1">Animations</a></h3>
<p>The next step is to add animations. Create a new <code>Animation Player</code> node, click <code>Open Animation Editor</code> near its
<code>Animations</code> property in the inspector to open the animation editor:</p>
<p><img src="tutorials/rpg/tutorial-1/animation_editor.png" alt="animation editor" /></p>
<p>Dock the animation editor below the scene preview - this way it will be much comfortable to use. Now we need to import
two animations <code>run.fbx</code> and <code>idle.fbx</code> from the <code>data/models/paladin</code> folder. To do this, click on the button with
arrow at the tool strip in the animation editor:</p>
<p><img src="tutorials/rpg/tutorial-1/animation_import_1.png" alt="animation import step 1" /></p>
<p>The editor asks us for the root node to which import the animation - it our case it is <code>paladin.fbx</code>. Select it in the
window and click <code>OK</code>. Another window opens and asks us about the animation we want to import - find <code>idle.fbx</code> in the
tree and click <code>Open</code>. You should see something like this as a result:</p>
<p><img src="tutorials/rpg/tutorial-1/idle_animation.png" alt="idle animation" /></p>
<p>Click on <code>Preview</code> check box in the tool strip and the animation should play without artifacts. Now repeat the previous
steps and import <code>running.fbx</code>. Click <code>Preview</code> again, and you'll see that the character is running, but not in-place as
we'd like it to. Let's fix that by applying a Root Motion settings. Click on the <code>RM</code> button and set it up like so:</p>
<p><img src="tutorials/rpg/tutorial-1/root_motion.png" alt="root motion" /></p>
<p>Now if you click on <code>Preview</code> again, you'll see that the character is now moving in-place. But what we did by applying
the root motion? We forced the engine to extract movement vector from the hips of the character that could be later used
to move the capsule rigid body we've made early. This way the animation itself will drive the character and the actual
movement will perfectly match the physical movement.</p>
<p>At this point we have two separate animations that work independently. But what if we want to add a smooth transition
between the two (or more)? This is where animation blending state machines comes into play. Create a new state machine
and assign an animation player to it:</p>
<p><img src="tutorials/rpg/tutorial-1/absm.png" alt="absm" /></p>
<p>The animation player will be used as a source of animations for our state machine. Now open the <code>ABSM Editor</code> by clicking
the <code>Open ABSM Editor...</code> button in the inspector (right above the animation player property). Dock the editor and select
a <code>Base Layer</code> in the dropdown list in the toolbar. Next, we need to add two states - <code>Idle</code> and <code>Running</code>. This can be
done by right-clicking on in the <code>State Graph</code> and selecting <code>Create State</code>:</p>
<p><img src="tutorials/rpg/tutorial-1/states.png" alt="states" /></p>
<p>A state requires animation source to be usable, we can specify it by double-clicking on it (or right-click -&gt; <code>Enter State</code>)
and creating a <code>Play Animation</code> pose node in the <code>State Viewer</code> (right-click -&gt; <code>Play Animation</code>):</p>
<p><img src="tutorials/rpg/tutorial-1/animation_source.png" alt="img.png" /></p>
<p>Select the <code>Play Animation</code> node and in the <code>Inspector</code> select the <code>Idle</code> animation from the dropdown list near the
<code>Animation</code> property. Repeat the same steps for the <code>Running</code> state, but in this case set <code>Running</code> animation.</p>
<p>Now when we two states ready, we need to create transitions between the two. Transition is a "rule", that defines whether
a current active state can be switched to another one. While doing so, the engine will blend an animation coming from
two states. To create a transition, right-click on a state and click <code>Create Transition</code>. Do the same in the opposite
direction. As a result, you should have something like this:</p>
<p><img src="tutorials/rpg/tutorial-1/transition.png" alt="transition" /></p>
<p>A transition requires a boolean value to "understand" whether an actual transition is possible or not. Let's add one
in the <code>Parameters</code> section of the editor. Click on the small <code>+</code> button and change the name to <code>Running</code> and the type
to the <code>Rule</code>:</p>
<p><img src="tutorials/rpg/tutorial-1/parameters.png" alt="parameters" /></p>
<p>Let's assign the rule to our transitions, select the <code>Idle -&gt; Running</code> transition and in the Inspector set its condition
to the following:</p>
<p><img src="tutorials/rpg/tutorial-1/condition.png" alt="condition" /></p>
<p><code>Running -&gt; Idle</code> requires a reverse condition, the engine has a computational graph for this purpose (to compute
boolean expressions). Set the condition of it to the following:</p>
<p><img src="tutorials/rpg/tutorial-1/not_condition.png" alt="not condition" /></p>
<p>As you can see we negate (using the <code>Not</code> boolean operator) the value of the <code>Running</code> parameter and use it compute the
final value for the transition. At this point we can check how our animation blending works. Click on <code>Preview</code> check box,
and you should see that the character is currently being in the <code>Idle</code> state, now click at the checkbox in the <code>Running</code>
parameter, and you'll see that the <code>Idle -&gt; Running</code> transition started and ended shortly after. If you uncheck the
parameter, the character will switch back to idle.</p>
<p>This was the last step in this long procedure or making the prefab. As you can see, we haven't written a single line of
code and saw the results immediately, without a need to compile anything.</p>
<h2 id="player-script"><a class="header" href="#player-script">Player Script</a></h2>
<p>Finally, we can start writing some code. There won't be much of it, but it is still required. Fyrox allows you to add
custom game logic to scene nodes using scripts. Scripts "skeleton" contains quite a lot of boilerplate code and to
prevent this tedious work, <code>fyrox-template</code> offers a sub-command called <code>script</code>, which allows you to generate a script
skeleton in a single command. Go to root folder of your project and execute the following command there:</p>
<pre><code class="language-shell">fyrox-template script --name=player
</code></pre>
<p>The CLI tool will create the new module in <code>game/src</code> folder called <code>player.rs</code> and all you need to do is to register
the module in two places. The first place is to add <code>mod player;</code> line somewhere at the beginning of the <code>game/src/lib.rs</code>.
The second place is <code>PluginConstructor::register</code> method - every script must be registered before use. Let's do so by adding
the following code to the method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Plugin for Game {
    fn register(&amp;self, context: PluginRegistrationContext) {
        context
            .serialization_context
            .script_constructors
            .add::&lt;Player&gt;("Player");
    }
<span class="boring">}</span></code></pre></pre>
<p>Preparation steps are now finished, and we can start filling the script with some useful code. Navigate to the <code>player.rs</code>
and you'll see quite a lot of code. Most of the methods, however, can be removed, and we're only interested in <code>on_update</code>
and <code>on_os_event</code>. But for now, let's add the following fields in the <code>Player</code> struct:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Default, Debug, Clone)]
#[visit(optional)]
pub struct Player {
    camera_pivot: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,

    camera_hinge: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,

    state_machine: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,

    model_pivot: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,

    model: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,

    model_yaw: InheritableVariable&lt;SmoothAngle&gt;,

    #[reflect(hidden)]
    #[visit(skip)]
    walk_forward: bool,

    #[reflect(hidden)]
    #[visit(skip)]
    walk_backward: bool,

    #[reflect(hidden)]
    #[visit(skip)]
    walk_left: bool,

    #[reflect(hidden)]
    #[visit(skip)]
    walk_right: bool,

    #[reflect(hidden)]
    #[visit(skip)]
    yaw: f32,

    #[reflect(hidden)]
    #[visit(skip)]
    pitch: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>There are quite a lot of them, but all of them will be in use. The first four fields will contain handles to scene nodes
we've made earlier, the <code>model_yaw</code> field contains a <code>SmoothAngle</code> which is used for smooth angle interpolation we'll
use later in tutorial. Please note that these fields marked with <code>#[visit(optional)]</code> attribute, which tells the engine
that these fields can be missing and should be replaced with default values in this case. This is very useful attribute
if you're adding new fields to some existing script, it will prevent serialization error. The rest of the fields contains
runtime information about movement state (<code>move_forward</code>, <code>move_backward</code>, <code>walk_left</code>, <code>walk_right</code>) and the
camera orientation (<code>yaw</code> and <code>pitch</code> fields).</p>
<p>A few notes why the first five fields are wrapped in the <code>InheritableVariable</code> - it is to support property inheritance
mechanism for these fields. The engine will save the values for these variables only if they're manually modified, on
loading, however, it will replace non-modified values with the ones from parent prefab. If it sounds too complicated for
you, then you should probably read <a href="tutorials/rpg/tutorial-1/../../../scene/prefab.html#property-inheritance">this chapter</a>.</p>
<p>Let's start writing player controller's logic.</p>
<h3 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h3>
<p>We'll start from keyboard and mouse event handling, add the following code to the <code>impl ScriptTrait for Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, ctx: &amp;mut ScriptContext) {
        match event {
            Event::WindowEvent { event, .. } =&gt; {
                if let WindowEvent::KeyboardInput { event, .. } = event {
                    if let PhysicalKey::Code(code) = event.physical_key {
                        let pressed = event.state == ElementState::Pressed;
                        match code {
                            KeyCode::KeyW =&gt; self.walk_forward = pressed,
                            KeyCode::KeyS =&gt; self.walk_backward = pressed,
                            KeyCode::KeyA =&gt; self.walk_left = pressed,
                            KeyCode::KeyD =&gt; self.walk_right = pressed,
                            _ =&gt; (),
                        }
                    }
                }
            }
            Event::DeviceEvent { event, .. } =&gt; {
                if let DeviceEvent::MouseMotion { delta } = event {
                    let mouse_sens = 0.2 * ctx.dt;
                    self.yaw -= (delta.0 as f32) * mouse_sens;
                    self.pitch = (self.pitch + (delta.1 as f32) * mouse_sens)
                        .clamp(-90.0f32.to_radians(), 90.0f32.to_radians());
                }
            }
            _ =&gt; (),
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This code consists of two major sections: <code>KeyboardInput</code> event handling and <code>MouseMotion</code> event handling. Let's start
from <code>KeyboardInput</code> event. At the beginning of it we're checking if a key was pressed or not and saving it to the
<code>pressed</code> flag, then we check for <code>W</code>, <code>S</code>, <code>A</code>, <code>D</code> keys and set each movement flag accordingly.</p>
<p>The <code>MouseMotion</code> event handling is different: we're using mouse movement delta to calculate new yaw and pitch values
for our camera. Pitch calculation also includes angle clamping in <code>-90.0..90.0</code> degree range.</p>
<h3 id="logic"><a class="header" href="#logic">Logic</a></h3>
<p>The next important step is to apply all the data we have to a bunch of scene nodes the player consists of. Let's fill
the <code>on_update</code> method with the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Step 1. Fetch the velocity vector from the animation blending state machine.
        let transform = ctx.scene.graph[*self.model].global_transform();
        let mut velocity = Vector3::default();
        if let Some(state_machine) = ctx
            .scene
            .graph
            .try_get(*self.state_machine)
            .and_then(|node| node.component_ref::&lt;AnimationBlendingStateMachine&gt;())
        {
            if let Some(root_motion) = state_machine.machine().pose().root_motion() {
                velocity = transform
                    .transform_vector(&amp;root_motion.delta_position)
                    .scale(1.0 / ctx.dt);
            }
        }

        // Step 2. Apply the velocity to the rigid body and lock rotations.
        if let Some(body) = ctx.scene.graph.try_get_mut_of_type::&lt;RigidBody&gt;(ctx.handle) {
            body.set_ang_vel(Default::default());
            body.set_lin_vel(Vector3::new(velocity.x, body.lin_vel().y, velocity.z));
        }

        // Step 3. Rotate the model pivot according to the movement direction.
        let quat_yaw = UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.yaw);

        if velocity.norm_squared() &gt; 0.0 {
            // Since we have free camera while not moving, we have to sync rotation of pivot
            // with rotation of camera so character will start moving in look direction.
            if let Some(model_pivot) = ctx.scene.graph.try_get_mut(*self.model_pivot) {
                model_pivot.local_transform_mut().set_rotation(quat_yaw);
            }

            // Apply additional rotation to model - it will turn in front of walking direction.
            let angle: f32 = if self.walk_left {
                if self.walk_forward {
                    45.0
                } else if self.walk_backward {
                    135.0
                } else {
                    90.0
                }
            } else if self.walk_right {
                if self.walk_forward {
                    -45.0
                } else if self.walk_backward {
                    -135.0
                } else {
                    -90.0
                }
            } else if self.walk_backward {
                180.0
            } else {
                0.0
            };

            self.model_yaw.set_target(angle.to_radians()).update(ctx.dt);

            if let Some(model) = ctx.scene.graph.try_get_mut(*self.model) {
                model
                    .local_transform_mut()
                    .set_rotation(UnitQuaternion::from_axis_angle(
                        &amp;Vector3::y_axis(),
                        self.model_yaw.angle,
                    ));
            }
        }

        if let Some(camera_pivot) = ctx.scene.graph.try_get_mut(*self.camera_pivot) {
            camera_pivot.local_transform_mut().set_rotation(quat_yaw);
        }

        // Rotate camera hinge - this will make camera move up and down while look at character
        // (well not exactly on character - on characters head)
        if let Some(camera_hinge) = ctx.scene.graph.try_get_mut(*self.camera_hinge) {
            camera_hinge
                .local_transform_mut()
                .set_rotation(UnitQuaternion::from_axis_angle(
                    &amp;Vector3::x_axis(),
                    self.pitch,
                ));
        }

        // Step 4. Feed the animation blending state machine with the current state of the player.
        if let Some(state_machine) = ctx
            .scene
            .graph
            .try_get_mut(*self.state_machine)
            .and_then(|node| node.component_mut::&lt;AnimationBlendingStateMachine&gt;())
        {
            let moving =
                self.walk_left || self.walk_right || self.walk_forward || self.walk_backward;

            state_machine
                .machine_mut()
                .get_value_mut_silent()
                .set_parameter("Running", Parameter::Rule(moving));
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>That's a big chunk of code, but it mostly consists of a set of separate steps. Let's try to understand what each step does.</p>
<p>Step 1 extracts the root motion vector from the animation blending state machine: at first, we're getting the current
transformation matrix of the Paladin's model. Then we're trying to borrow the ABSM node from the scene. If it is
successful, then we're trying to extract the root motion vector from the final pose of the ABSM. If we have one, then
we need to transform it from the local space to the world space - we're doing this using matrix-vector multiplication.
And as the last step, we're scaling the vector by delta time to get the final velocity in world coordinates that can
be used to move the rigid body.</p>
<p>Step 2 uses the root motion vector to move the rigid body. The body is the node to which the script is assigned to,
so we're using <code>ctx.handle</code> to borrow a "self" reference and setting the new linear and angular velocities.</p>
<p>Step 3 is the largest (code-wise) step, yet very simple. All we do here is rotating the camera and the model pivot in
according to pressed keys. The code should be self-explanatory.</p>
<p>Step 4 feeds the animation blending state machine with the variables it needs to perform state transitions. Currently,
we have only one variable - <code>Running</code> and to set it, we're trying to borrow the ABSM using its handle, then we're
using the state of four of our movement variable to combine them into one and use this flag to set the value in the
ABSM.</p>
<h3 id="binding"><a class="header" href="#binding">Binding</a></h3>
<p>Now, when we have finished coding part, we can open <code>paladin.rgs</code> in the editor again and assign the script to it:</p>
<p><img src="tutorials/rpg/tutorial-1/assigned_script.png" alt="assigned script" /></p>
<p>Make sure to correctly set the script fields (as on the screenshot above), otherwise it won't work correctly.</p>
<h2 id="game-level"><a class="header" href="#game-level">Game Level</a></h2>
<p>Use your imagination to create a game level (or just use the one from the assets pack for this tutorial). Level design
is not covered by this tutorial. You can create a simple level using a Terrain, a few 3D models from the assets pack:</p>
<p><img src="tutorials/rpg/tutorial-1/simple_level.png" alt="simple level" /></p>
<p>The most important part, however, is to add a player instance to the level:</p>
<p><img src="tutorials/rpg/tutorial-1/player_on_level.png" alt="player on level" /></p>
<p>Now all you need to do is to click on the green <code>&gt;</code> button and run the game. "Production" build could be created by
running <code>cargo run --package executor --release</code>.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>In this tutorial we've learned how to set up physics for humanoid characters, how to create simple 3rd person camera
controllers, how to import and blend multiple animation into one, how to use root motion to extract motion vector from
animations. We also learned how to create prefabs and use them correctly. Finally, we have created a simple level and
instantiated the character prefab on it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-person-shooter-tutorial"><a class="header" href="#first-person-shooter-tutorial">First-person Shooter Tutorial</a></h1>
<p>This tutorial series will guide your through a process of creation a simple 3D shooter, that will have basic
character controller, weapons, projectiles, bots, animation, and simple AI.</p>
<p>Keep in mind, that every tutorial part expects that you've read every previous part. It is needed to not explain
all required actions over and over again.</p>
<h2 id="source-code-2"><a class="header" href="#source-code-2">Source Code</a></h2>
<p>Source code for the entire tutorial is <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main/src/code/tutorials/fps">available here</a>.</p>
<h2 id="engine-version-3"><a class="header" href="#engine-version-3">Engine Version</a></h2>
<p>This tutorial is made using Fyrox 0.34.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-person-shooter-tutorial-1"><a class="header" href="#first-person-shooter-tutorial-1">First-Person Shooter Tutorial</a></h1>
<p>In this tutorial, we'll create a first-person shooter game.</p>
<p>Before we begin, make sure you know how to create projects and run the game and the editor. Read
<a href="tutorials/fps/tutorial-1/../../../beginning/scripting.html">this chapter</a> first and let's start by creating a new project by executing the following
command in some directory:</p>
<pre><code class="language-shell">fyrox-template init --name=fps --style=3d
</code></pre>
<p>This command will create a new cargo workspace with a few projects inside, we're interested only in <code>game</code> folder
in this tutorial.</p>
<pre><code class="language-text">fps
├───data
├───editor
│   └───src
├───executor
│   └───src
├───executor-android
│   └───src
├───executor-wasm
│   └───src
└───game
    └───src
</code></pre>
<h2 id="player-prefab-1"><a class="header" href="#player-prefab-1">Player Prefab</a></h2>
<p>Let's start by creating a <a href="tutorials/fps/tutorial-1/../../../scene/prefab.html">prefab</a> for the player. First-person shooters use quite simple
layouts for characters - usually, it is just a physical capsule with a camera on top of it. Run the editor using the
following command:</p>
<pre><code class="language-shell">cargo run --package editor
</code></pre>
<p><img src="tutorials/fps/tutorial-1/editor_1.png" alt="editor startup" /></p>
<p>By default, <code>scene.rgs</code> scene is loaded, and it is our main scene, but for our player prefab we need a separate scene.
Go to <code>File</code> menu and click <code>New Scene</code>. Save the scene in <code>data/player</code> folder as <code>player.rgs</code>.</p>
<p>Great, now we are ready to create the prefab. Right-click on the <code>__ROOT__</code> node in the World Viewer and find <code>Replace Node</code>
and select <code>Physics -&gt; Rigid Body</code> there. By doing this, we've replaced the root node of the scene to be a rigid body.
This is needed because our player will be moving.</p>
<p><img src="tutorials/fps/tutorial-1/editor_2.png" alt="replace node" /></p>
<p>Select rigid body and set the <code>X/Y/Z Rotation Locked</code> properties to <code>true</code>, <code>Can Sleep</code> - to <code>false</code>. The first three
properties prevents the rigid body from any undesired rotations and the last one prevents the rigid body from being excluded
from simulations.</p>
<p><img src="tutorials/fps/tutorial-1/rigid_body_props.png" alt="rigid body props" /></p>
<p>As you may notice, the editor added a small "warning" icon near the root node - it tells us that the rigid body does not
have a collider. Let's fix that:</p>
<p><img src="tutorials/fps/tutorial-1/editor_3.png" alt="collider node" /></p>
<p>By default, the editor creates a cube collider, but we need a capsule. Let's change that in the Inspector:</p>
<p><img src="tutorials/fps/tutorial-1/editor_4.png" alt="change collider type" /></p>
<p>Now let's change the size of the collider, because default values are disproportional for a humanoid character:</p>
<p><img src="tutorials/fps/tutorial-1/editor_5.png" alt="collider properties" /></p>
<p>This way the capsule is thinner and taller, which roughly corresponds to a 1.8m tall person. Now we need to add a
<a href="tutorials/fps/tutorial-1/../../../scene/camera_node.html">camera</a>, because without it, we couldn't see anything.</p>
<p><img src="tutorials/fps/tutorial-1/editor_6.png" alt="camera" /></p>
<p>Put the camera at the top of the capsule like so:</p>
<p><img src="tutorials/fps/tutorial-1/editor_7.png" alt="camera position" /></p>
<p>Awesome, at this point we're almost done with this prefab. Save the scene (<code>File -&gt; Save Scene</code>) and let's start writing
some code.</p>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<p>Now we can start writing some code, that will drive our character. Game logic is located in <a href="tutorials/fps/tutorial-1/../../../scripting/script.html">scripts</a>.
Navigate to the <code>fps</code> directory and execute the following command there:</p>
<pre><code class="language-shell">fyrox-template script --name=player
</code></pre>
<p>This command creates a new script for our player in <code>game/src</code> folder. Next, Replace the imports in the <code>lib.rs</code> with the ones below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use crate::{player::Player};
use fyrox::{
    core::pool::Handle,
    core::{reflect::prelude::*, visitor::prelude::*},
    plugin::{Plugin, PluginContext, PluginRegistrationContext},
    scene::Scene,
    event::Event,
    gui::message::UiMessage,
};

use std::path::Path;
<span class="boring">}</span></code></pre></pre>
<p>and then add the new module to the <code>lib.rs</code> module by adding the <code>pub mod player;</code> after the imports:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this line
pub mod player;

<span class="boring">}</span></code></pre></pre>
<p>All scripts must be registered in the engine explicitly, otherwise they won't work. To do that, add the following
lines to the <code>register</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        context
            .serialization_context
            .script_constructors
            .add::&lt;Player&gt;("Player");
<span class="boring">}</span></code></pre></pre>
<p>Great, now the new script is registered, we can head over to the <code>player.rs</code> module and start writing a basic character controller.
First replace the import to the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fyrox::graph::SceneGraph;
use fyrox::{
    core::{
        algebra::{UnitQuaternion, UnitVector3, Vector3},
        pool::Handle,
        reflect::prelude::*,
        type_traits::prelude::*,
        variable::InheritableVariable,
        visitor::prelude::*,
    },
    event::{DeviceEvent, ElementState, Event, MouseButton, WindowEvent},
    keyboard::{KeyCode, PhysicalKey},
    scene::{node::Node, rigidbody::RigidBody},
    script::{ScriptContext, ScriptTrait, ScriptDeinitContext},
    
};

<span class="boring">}</span></code></pre></pre>
<p>Let's start by input
handling. At first, add the following fields to the <code>Player</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[reflect(hidden)]
    move_forward: bool,

    #[reflect(hidden)]
    move_backward: bool,

    #[reflect(hidden)]
    move_left: bool,

    #[reflect(hidden)]
    move_right: bool,

    #[reflect(hidden)]
    yaw: f32,

    #[reflect(hidden)]
    pitch: f32,
<span class="boring">}</span></code></pre></pre>
<p>The first four fields are responsible for movement in four directions and the last two responsible for camera rotation.
The next thing that we need to do is properly react to incoming OS events to modify the variables that we've just
defined. Add the following code to the <code>on_os_event</code> method like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, _ctx: &amp;mut ScriptContext) {
        match event {
            // Raw mouse input is responsible for camera rotation.
            Event::DeviceEvent {
                event:
                    DeviceEvent::MouseMotion {
                        delta: (dx, dy), ..
                    },
                ..
            } =&gt; {
                // Pitch is responsible for vertical camera rotation. It has -89.9..89.0 degree limits,
                // to prevent infinite rotation.
                let mouse_speed = 0.35;
                self.pitch = (self.pitch + *dy as f32 * mouse_speed).clamp(-89.9, 89.9);
                self.yaw -= *dx as f32 * mouse_speed;
            }
            // Keyboard input is responsible for player's movement.
            Event::WindowEvent {
                event: WindowEvent::KeyboardInput { event, .. },
                ..
            } =&gt; {
                if let PhysicalKey::Code(code) = event.physical_key {
                    let is_pressed = event.state == ElementState::Pressed;
                    match code {
                        KeyCode::KeyW =&gt; {
                            self.move_forward = is_pressed;
                        }
                        KeyCode::KeyS =&gt; {
                            self.move_backward = is_pressed;
                        }
                        KeyCode::KeyA =&gt; {
                            self.move_left = is_pressed;
                        }
                        KeyCode::KeyD =&gt; {
                            self.move_right = is_pressed;
                        }
                        _ =&gt; (),
                    }
                }
            }
            _ =&gt; {}
        }
        // ...
<span class="boring">}</span></code></pre></pre>
<p>This code consists from two major parts:</p>
<ul>
<li>Raw mouse input handling for camera rotations: we're using horizontal movement to rotate the camera around vertical
axis and vertical mouse movement is used to rotate the camera around horizontal axis.</li>
<li>Keyboard input handling for movement.</li>
</ul>
<p>This just modifies the internal script variables, and basically does not affect anything else.</p>
<p>Now let's add camera rotation, at first we need to know the camera handle. Add the following field to the <code>Player</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    camera: Handle&lt;Node&gt;,
<span class="boring">}</span></code></pre></pre>
<p>We'll assign this field later in the editor, for let's focus on the code. Add the following piece of code at the start of
the <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut look_vector = Vector3::default();
        let mut side_vector = Vector3::default();
        if let Some(camera) = ctx.scene.graph.try_get_mut(self.camera) {
            look_vector = camera.look_vector();
            side_vector = camera.side_vector();

            let yaw = UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), self.yaw.to_radians());
            let transform = camera.local_transform_mut();
            transform.set_rotation(
                UnitQuaternion::from_axis_angle(
                    &amp;UnitVector3::new_normalize(yaw * Vector3::x()),
                    self.pitch.to_radians(),
                ) * yaw,
            );
        }
<span class="boring">}</span></code></pre></pre>
<p>This piece of code is relatively straightforward: at first we're trying to borrow the camera in the scene graph using
its handle, if it is succeeded, we form two quaternions that represent rotations around Y and X axes and combine them
using simple multiplication.</p>
<p>Next thing we'll add movement code. Add the following code to the end of <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Borrow the node to which this script is assigned to. We also check if the node is RigidBody.
        if let Some(rigid_body) = ctx.scene.graph.try_get_mut_of_type::&lt;RigidBody&gt;(ctx.handle) {
            // Form a new velocity vector that corresponds to the pressed buttons.
            let mut velocity = Vector3::new(0.0, 0.0, 0.0);
            if self.move_forward {
                velocity += look_vector;
            }
            if self.move_backward {
                velocity -= look_vector;
            }
            if self.move_left {
                velocity += side_vector;
            }
            if self.move_right {
                velocity -= side_vector;
            }

            let y_vel = rigid_body.lin_vel().y;
            if let Some(normalized_velocity) = velocity.try_normalize(f32::EPSILON) {
                let movement_speed = 240.0 * ctx.dt;
                rigid_body.set_lin_vel(Vector3::new(
                    normalized_velocity.x * movement_speed,
                    y_vel,
                    normalized_velocity.z * movement_speed,
                ));
            } else {
                // Hold player in-place in XZ plane when no button is pressed.
                rigid_body.set_lin_vel(Vector3::new(0.0, y_vel, 0.0));
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This code is responsible for movement when any of WSAD keys are pressed. At first, it tries to borrow the node to which
this script is assigned to, then it checks if any of the WSAD keys are pressed, and it forms a new velocity vector using
the basis vectors of node. As the last step, it normalizes the vector (makes it unity length) and sets it to the rigid
body velocity.</p>
<p>Our script is almost ready, now all we need to do is to assign it to the player's prefab. Open the <code>player.rgs</code> prefab
in the editor, select <code>Player</code> node and assign the Player script to it. Do not forget to set Camera handle (by clicking
on the small green button and selecting Camera from the list):</p>
<p><img src="tutorials/fps/tutorial-1/script_instance.png" alt="script instance" /></p>
<p>Great, now we're done with the player movement. We can test it our main scene, but at first let's create a simple level.
Open <code>scene.rgs</code> and create a rigid body with a collider. Add a cube as a child of the rigid body and squash it to some
floor-like shape. Select the collider and set its <code>Shape</code> to <code>Trimesh</code>, add a geometry source there and point it to the
floor. Select the rigid body and set its type to <code>Static</code>. You can also add some texture to the cube to make it look
much better.</p>
<p>Now we can instantiate our player prefab in the scene. To do that, find the <code>player.rgs</code> in the Asset Browser, click
on it, hold the button, move the mouse over the scene and release the button. After that the prefab should be instantiated
at the cursor position like so:</p>
<p><img src="tutorials/fps/tutorial-1/prefab_instance.png" alt="prefab instance" /></p>
<p>After that you can click <code>Play</code> button (green triangle above the scene preview) and you should see something like this:</p>
<p><img src="tutorials/fps/tutorial-1/running_game_1.png" alt="running game" /></p>
<p>It should be possible to walk using WSAD keys and rotate the camera using mouse.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>In this tutorial we've created a basic character controller, that allows you to move using keyboard and look around
using mouse. This tutorial showed the main development strategies used in the engine, that should help you to build your
own game. In the next tutorial we'll add weapons.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weapons"><a class="header" href="#weapons">Weapons</a></h1>
<p>In the <a href="tutorials/fps/tutorial-2/../tutorial-1/fps-tutorial.html">previous tutorial</a> we've added basic character controller, but what is a
first-person shooter without weapons? Let's add them. In the end of the tutorial you should get something like this:</p>
<p><img src="tutorials/fps/tutorial-2/recoil.gif" alt="recoil" /></p>
<h2 id="weapon-prefab"><a class="header" href="#weapon-prefab">Weapon Prefab</a></h2>
<p>At first, we need a 3D model for our weapon -  use this <a href="tutorials/fps/tutorial-2/m4.zip">ZIP-archive</a> - it contains an M4 rifle 3D model that is
prepared for direct usage in the engine. Unzip this archive in <code>data/models</code> folder. Now we can start by making a prefab
for our weapon. Create a new scene (<code>File -&gt; NewScene</code>) and find the <code>m4.FBX</code> 3D model in the Asset Browser and instantiate
it in the scene by dragging it using mouse. Make sure to set location position of the weapon to <code>(0, 0, 0)</code>. You
should get something like this:</p>
<p><img src="tutorials/fps/tutorial-2/weapon_prefab.png" alt="weapon prefab" /></p>
<p>This prefab is almost ready, all we need to do is to create a script for it that will contain a code for shooting.</p>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<p>As usual, we need a script that will "drive" our weapons, run the following command at the root folder of your game:</p>
<pre><code class="language-shell">fyrox-template script --name=weapon
</code></pre>
<p>Add the <code>weapon</code> mod to the <code>lib.rs</code> module using <code>pub mod weapon;</code>. This script will spawn projectiles and play shooting
animation when we'll shoot the weapon. Let's add a "reference" to our projectile prefab that will be used for shooing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    projectile: InheritableVariable&lt;Option&lt;ModelResource&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>This field has quite complex type: <code>InheritableVariable</code> is used for <a href="tutorials/fps/tutorial-2/../../../scene/inheritance.html">property inheritance</a>,
<code>Option</code> is used to allow the field to be unassigned, and finally <code>ModelResource</code> is a reference to some projectile prefab.
We'll assign this field later in the tutorial.</p>
<p>Next thing we need to define is a point from which the weapon will shoot. We can't just use the position of the weapon,
because it will look unnatural if a projectile appear at a handle of the weapon or at some other place other than the
barrel of the weapon. We'll use a child scene node of the weapon to define such point. Let's add the following field
to the <code>Weapon</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    shot_point: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>We'll assign this field later in the tutorial as well as projectile prefab.</p>
<p>Now we need some mechanism to "tell" the weapon to shoot, we could directly access the weapon script and call some <code>shoot</code>
method, but in more or less complex game would almost certainly lead to lots of complaints from borrow checker. Instead
of this, we'll use <a href="tutorials/fps/tutorial-2/../../../scripting/script.html#message-passing">message passing mechanism</a> - this will allow us to
send a request for the weapon to shoot and the weapon will shoot when it will receive the message. Let's add a message
for shooting in <code>weapon.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct ShootWeaponMessage {}
<span class="boring">}</span></code></pre></pre>
<p>To actually be able to receive this message, we need to explicitly "subscribe" out script to it. Add the following code
to the <code>on_start</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_start(&amp;mut self, context: &amp;mut ScriptContext) {
        context
            .message_dispatcher
            .subscribe_to::&lt;ShootWeaponMessage&gt;(context.handle);
    }
<span class="boring">}</span></code></pre></pre>
<p>Every script has <code>on_message</code> method that is used for a message processing, we'll use it for shooting. Add the following
code in the <code>impl ScriptTrait for Weapon</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_message(
        &amp;mut self,
        message: &amp;mut dyn ScriptMessagePayload,
        ctx: &amp;mut ScriptMessageContext,
    ) {
        // Check if we've received an appropriate message. This is needed because message channel is
        // common across all scripts.
        if message.downcast_ref::&lt;ShootWeaponMessage&gt;().is_some() {
            if let Some(projectile_prefab) = self.projectile.as_ref() {
                // Try to get the position of the shooting point.
                if let Some(shot_point) = ctx
                    .scene
                    .graph
                    .try_get(*self.shot_point)
                    .map(|point| point.global_position())
                {
                    // Shooting direction is just a direction of the weapon (its look vector)
                    let direction = ctx.scene.graph[ctx.handle].look_vector();

                    // Finally instantiate our projectile at the position and direction.
                    projectile_prefab.instantiate_at(
                        ctx.scene,
                        shot_point,
                        math::vector_to_quat(direction),
                    );
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This code is pretty straightforward: at first, we're checking the message type, then we're checking if we have a prefab
for projectiles. If so, we're fetching a position of the shot point scene node and finally instantiating the projectile
prefab.</p>
<p>All is left to do is to register this script and assign it in the editor. To register the script, add the following
code to the <code>register</code> method in <code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        context
            .serialization_context
            .script_constructors
            .add::&lt;Weapon&gt;("Weapon");
<span class="boring">}</span></code></pre></pre>
<p>Start the editor and open <code>m4.rgs</code> prefab that we made at the beginning. Select the root node of the scene add <code>Weapon</code>
script to it. Assign a <code>Weapon:ShotPoint</code> node to the <code>Shot Point</code> property:</p>
<p><img src="tutorials/fps/tutorial-2/weapon_prefab_final.png" alt="weapon prefab final" /></p>
<p>The next thing we need to do is to create a prefab for projectile, that will be used for shooting.</p>
<h2 id="projectile"><a class="header" href="#projectile">Projectile</a></h2>
<p>You may ask - why we need a prefab for projectiles, why not just make a ray-based shooting? The answer is very simple -
flexibility. Once we'll finish with this "complex" system, we'll get very flexible weapon system that will allow you
to create weapons of any kind - it could be simple bullets, grenades, rockets, plasma, etc.</p>
<p>As usual, we need a prefab for our projectile. Create a new scene and add a Cylinder mesh scene node there, make sure
to orient it along the Z axis (blue one) and adjust its XY scale to make it thin enough - this will be our "projectile".
It will represent a bullet trail, but in reality the "bullet" will be represented by a simple ray cast and the trail
will be extended to a point of impact. Overall your prefab should look like this:</p>
<p><img src="tutorials/fps/tutorial-2/bullet_prefab.png" alt="bullet prefab" /></p>
<p>Select the root node of the prefab and set its lifetime to <code>Some(0.1)</code> - this will force the engine to remove the
projectile automatically after 100 ms.</p>
<p>The projectile also needs its own script which will do a ray casting and other actions later in the tutorial, such as
hit testing with enemies, etc. Create a new script by a well known command:</p>
<pre><code class="language-shell">fyrox-template script --name=projectile
</code></pre>
<p>Add the <code>projectile</code> mod to the <code>lib.rs</code> module using <code>pub mod projectile;</code> and register it in <code>register</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        context
            .serialization_context
            .script_constructors
            .add::&lt;Projectile&gt;("Projectile");
<span class="boring">}</span></code></pre></pre>
<p>Go to <code>projectile.rs</code> and add the following field to the <code>Projectile</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    trail: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>This field will hold a handle to the trail (the red cylinder on the screenshot about) and we'll use this handle to
borrow the node and modify the trail's length after ray casting.</p>
<p>The ray casting itself is the core of our projectiles, add the following code to the <code>on_start</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        let this_node = &amp;ctx.scene.graph[ctx.handle];
        let this_node_position = this_node.global_position();

        // Cast a ray in from the node in its "look" direction.
        let mut intersections = Vec::new();
        ctx.scene.graph.physics.cast_ray(
            RayCastOptions {
                ray_origin: this_node_position.into(),
                ray_direction: this_node.look_vector(),
                max_len: 1000.0,
                groups: Default::default(),
                // Sort results of the ray casting so the closest intersection will be in the
                // beginning of the list.
                sort_results: true,
            },
            &amp;mut intersections,
        );

        let trail_length = if let Some(intersection) = intersections.first() {
            // If we got an intersection, scale the trail by the distance between the position of the node
            // with this script and the intersection position.
            this_node_position.metric_distance(&amp;intersection.position.coords)
        } else {
            // Otherwise the trail will be as large as possible.
            1000.0
        };

        if let Some(trail_node) = ctx.scene.graph.try_get_mut(*self.trail) {
            let transform = trail_node.local_transform_mut();
            let current_trail_scale = **transform.scale();
            transform.set_scale(Vector3::new(
                // Keep x scaling.
                current_trail_scale.x,
                trail_length,
                // Keep z scaling.
                current_trail_scale.z,
            ));
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This code is pretty straightforward - at first we're borrowing the node of the projectile, saving its global position
in a variable and then casting a ray from the position and in the "look" direction of the projectile. Finally, we're
taking the first intersection from the list (it will be the closest one) and adjusting the trail's length accordingly.</p>
<p>The final step is to assign the script and its variables in the editor. Run the editor, open <code>bullet.rgs</code> (or how your
prefab is called) prefab and select the root node, set <code>Projectile</code> script to it and set <code>trail</code> field to the Trail node.
It should look like so:</p>
<p><img src="tutorials/fps/tutorial-2/bullet_properties.png" alt="bullet properties" /></p>
<h2 id="gluing-everything-together"><a class="header" href="#gluing-everything-together">Gluing Everything Together</a></h2>
<p>We have everything ready for final tuning - in this section of the tutorial we'll finish putting everything together and
will have a fully functioning weapon. Let's start from our weapon prefab, we need to "inform" it about the projectile
prefab we've just made. Open the <code>m4.rgs</code> prefab of our weapon and find <code>projectile</code> field in the Weapon script there.
Now find the <code>bullet.rgs</code> prefab of the projectile and drag'n'drop it onto the <code>projectile</code> field to set the value of it:</p>
<p><img src="tutorials/fps/tutorial-2/weapon_prefab_projectile.png" alt="weapon prefab projectile" /></p>
<p>The last step is to add the weapon to the player. Open the <code>player.rgs</code> prefab and find the <code>m4.rgs</code> prefab in the
Asset Browser, instantiate it in the scene and make it a child of the camera node. Overall it should look like this:</p>
<p><img src="tutorials/fps/tutorial-2/weapon_in_player.png" alt="weapon in player" /></p>
<p>We almost finished our final preparations, you can even open <code>scene.rgs</code> and hit <code>Play</code> and see the weapon in game:</p>
<p><img src="tutorials/fps/tutorial-2/weapon_in_game.png" alt="weapon in game" /></p>
<p>However, it won't shoot just yet - we need to send a message to the weapon for it to shoot. To do that, at first, we
need to know to which weapon we'll send a request to shoot. It is very easy to do by using weapon's node handle. Add
the following field to the <code>Player</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    current_weapon: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>We'll send a request to shoot in reaction to left mouse button clicks. To do that, go to <code>player.rs</code> and add the
following code to the <code>on_os_event</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Event::WindowEvent {
            event:
                WindowEvent::MouseInput {
                    state,
                    button: MouseButton::Left,
                    ..
                },
            ..
        } = event
        {
            self.shoot = *state == ElementState::Pressed;
        }
<span class="boring">}</span></code></pre></pre>
<p>And the following code to the <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if self.shoot {
            ctx.message_sender
                .send_to_target(*self.current_weapon, ShootWeaponMessage {});
        }
<span class="boring">}</span></code></pre></pre>
<p>The last step is to assign the handle to the current weapon in the player's prefab. Open the <code>player.rgs</code> prefab in
the editor and in the Player script find the <code>Current Weapon</code> field and assign to the Weapon node like so:</p>
<p><img src="tutorials/fps/tutorial-2/current_weapon_assignment.png" alt="current weapon assignment" /></p>
<p>Run the game, and you should be able to shoot from the weapon, but it shoots way too fast. Let's make the weapon to
shoot with desired interval while we're holding the mouse button. Add the two timer variables to the <code>Weapon</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    shot_interval: InheritableVariable&lt;f32&gt;,

    #[reflect(hidden)]
    shot_timer: f32,
<span class="boring">}</span></code></pre></pre>
<p>The <code>shot_timer</code> variable will be used to measure time between shots and the <code>shot_interval</code> will set the
desired period of shooting (in seconds). We'll handle one of these variables in <code>on_update</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_update(&amp;mut self, context: &amp;mut ScriptContext) {
        self.shot_timer -= context.dt;
    }
<span class="boring">}</span></code></pre></pre>
<p>This code is very simple - it just decreases the timer and that's all. Now let's add a new condition to the
<code>on_message</code> method right after <code>if message.downcast_ref::&lt;ShootWeaponMessage&gt;().is_some() {</code> line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            if self.shot_timer &gt;= 0.0 {
                return;
            }
            // Reset the timer, this way the next shot cannot be done earlier than the interval.
            self.shot_timer = *self.shot_interval;
<span class="boring">}</span></code></pre></pre>
<p>Open the <code>m4.rgs</code> prefab in the editor and set the interval in the <code>Weapon</code> script to 0.1. Run the game and the
weapon should shoot less fast.</p>
<h2 id="bells-and-whistles"><a class="header" href="#bells-and-whistles">Bells and Whistles</a></h2>
<p>We can improve overall feeling of our weapon by adding various effects.</p>
<h3 id="trail-dissolving"><a class="header" href="#trail-dissolving">Trail Dissolving</a></h3>
<p>Our shot trails disappear instantly and this looks unnatural. It can be fixed very easy by using animations.
Read the docs about the <a href="tutorials/fps/tutorial-2/../../../animation/anim_editor.html">animation editor</a> first to get familiar with it.
Open the <code>bullet.rgs</code> prefab, add <code>Animation Player</code> node to the prefab and open the animation editor.
Add a new track that binds to the alpha channel of the color of the trail's material:</p>
<p><img src="tutorials/fps/tutorial-2/trail_animation.png" alt="trail animation" /></p>
<p>Also, make sure the <code>Unique Material</code> check box is checked in the material property of the trail's mesh. Otherwise,
all trails will share the same material and once the animation is finished, you won't see the trail anymore.
Run the game and shot trails should disappear smoothly.</p>
<h3 id="impact-effects"><a class="header" href="#impact-effects">Impact Effects</a></h3>
<p>Right now our projectiles does not interact with world, we can improve that by creating sparks effect
at the point of impact. Download <a href="tutorials/fps/tutorial-2/bullet_impact.zip">this</a> pre-made effect and unzip it in <code>data/effects</code> folder.</p>
<p>Add the following field to the <code>Projectile</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impact_effect: InheritableVariable&lt;Option&lt;ModelResource&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>This is a "link" to particle effect, that we'll spawn at the impact position. Let's add this code to the end
of <code>on_start</code> of <code>impl ScriptTrait for Projectile</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Some(intersection) = intersections.first() {
            if let Some(effect) = self.impact_effect.as_ref() {
                effect.instantiate_at(
                    ctx.scene,
                    intersection.position.coords,
                    math::vector_to_quat(intersection.normal),
                );
            }
        }
<span class="boring">}</span></code></pre></pre>
<p>The last thing we need to do is to assign <code>Impact Effect</code> property in <code>bullet.rgs</code> to the pre-made effect.
Run the game, and you should see something like this when shooting:</p>
<p><img src="tutorials/fps/tutorial-2/shooting.gif" alt="shooting" /></p>
<h3 id="world-interaction"><a class="header" href="#world-interaction">World Interaction</a></h3>
<p>In this section we'll add an ability to push physical objects by shooting. All we need to do is to add the
following code to at the end of <code>on_start</code> of <code>impl ScriptTrait for Projectile</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Some(intersection) = intersections.first() {
            if let Some(collider) = ctx.scene.graph.try_get(intersection.collider) {
                let rigid_body_handle = collider.parent();
                if let Some(rigid_body) = ctx
                    .scene
                    .graph
                    .try_get_mut_of_type::&lt;RigidBody&gt;(rigid_body_handle)
                {
                    if let Some(force_dir) = (intersection.position.coords - this_node_position)
                        .try_normalize(f32::EPSILON)
                    {
                        let force = force_dir.scale(200.0);

                        rigid_body.apply_force_at_point(force, intersection.position.coords);
                        rigid_body.wake_up();
                    }
                }
            }
        }
<span class="boring">}</span></code></pre></pre>
<p>This code is very straightforward: at first, we're taking the closest intersection and by using its info about
collider taking a reference to the rigid body we've just hit by the ray. Next, we're applying force at the point
of impact, which will push the rigid body.</p>
<p>To check how it works, unzip <a href="tutorials/fps/tutorial-2/barrel.zip">this prefab</a> to <code>data/models</code> and add some instances of it to the <code>scene.rgs</code>
and run the game. You should see something like this:</p>
<p><img src="tutorials/fps/tutorial-2/pushing.gif" alt="pushing" /></p>
<h3 id="recoil"><a class="header" href="#recoil">Recoil</a></h3>
<p>The final improvement that we could do is to add a recoil to our weapon. We'll use animation for that, like
we did for <a href="tutorials/fps/tutorial-2/fps-tutorial-2.html#trail-dissolving">trails</a>. Instead of animation the color, we'll animation position of the weapon
model. Open <code>m4.rgs</code> prefab, add an animation player, create a new animation, add a binding to <code>Position</code>
property of <code>m4.FBX</code> node with the following parameters:</p>
<p><img src="tutorials/fps/tutorial-2/recoil_animation.png" alt="recoil animation" /></p>
<p>Now we need a way to enable this animation when shooting, to do that we need to know a handle of the animation
player in the weapon script. Let's add it to the <code>Weapon</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    animation_player: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Add the following code to the <code>on_message</code> in <code>weapon.rs</code>, right after the shooting condition (<code>if self.shot_timer &gt;= 0.0 { ...</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            if let Some(animation_player) = ctx
                .scene
                .graph
                .try_get_mut_of_type::&lt;AnimationPlayer&gt;(*self.animation_player)
            {
                if let Some(animation) = animation_player
                    .animations_mut()
                    .get_value_mut_silent()
                    .iter_mut()
                    .next()
                {
                    animation.rewind();
                    animation.set_enabled(true);
                }
            }
<span class="boring">}</span></code></pre></pre>
<p>Run the game, and you should see something like this when shooting:</p>
<p><img src="tutorials/fps/tutorial-2/recoil.gif" alt="recoil" /></p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>In this tutorial part we've added weapons that can shoot projectiles, which in their turn can interact with the
environment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bots-and-ai-1"><a class="header" href="#bots-and-ai-1">Bots and AI</a></h1>
<p>In the <a href="tutorials/fps/tutorial-3/../tutorial-2/fps-tutorial-2.html">previous</a> we've added weapons and projectiles, but we still do not have
anything to shoot at. In this tutorial part we'll add bots with simple AI:</p>
<p><img src="tutorials/fps/tutorial-3/bot.gif" alt="bot" /></p>
<h2 id="bot-prefab-1"><a class="header" href="#bot-prefab-1">Bot Prefab</a></h2>
<p>Let's start by zombie 3D model and animations for it, grab it from <a href="tutorials/fps/tutorial-3/zombie.zip">here</a> and unpack into
<code>data/models/zombie</code> folder. Open the editor and create <code>zombie.rgs</code> scene. Instantiate a <code>zombie.FBX</code> 3D model
in the scene and make sure it is located at (0, 0, 0) coordinates. Scale it down to have 0.01 scale in both axes.
You should get something like this:</p>
<p><img src="tutorials/fps/tutorial-3/zombie.png" alt="zombie" /></p>
<p>Next thing that we'll add is animations. Create a new Animation Player scene node, open the animation editor
and add three animations (use <a href="tutorials/fps/tutorial-3/../../../animation/anim_editor.html#animation-importing">this chapter</a> to learn how to
do this) - <code>zombie_attack</code>, <code>zombie_idle</code>, <code>zombie_running</code>. You should get something like this:</p>
<p><img src="tutorials/fps/tutorial-3/zombie_animation.png" alt="zombie animation" /></p>
<p>Do not forget to disable looping for <code>zombie_attack</code> animation, otherwise our zombie will attack infinitely.
Also, make sure to set up the root motion for the <code>zombie_running</code> animation, read
<a href="tutorials/fps/tutorial-3/../../../animation/root_motion/root_motion.html">this chapter</a> for more info. Root motion will allow us to get
nice animation of movement, which will also serve as a source velocity for our bot.</p>
<p>You can select each animation from the list and see how it plays by clicking the "Preview" check box at the
toolbar. Animations by their own are not very useful for us, because our bot can be in multiple states in the
game:</p>
<ul>
<li>Idle - when there's no one around and the bot is just standing still; looking for potential targets.</li>
<li>Run - when the bot spotted someone and walks towards it.</li>
<li>Attack - when the bot is close enough to a target and can attack it.</li>
</ul>
<p>We need to somehow manage all these states and do smooth transition between the states. Fyrox has a special
tool for this called <a href="tutorials/fps/tutorial-3/../../../animation/blending.html">animation blending state machine</a> (ABSM). Let's create a new
ABSM scene node and add the three states mentioned above (if you don't know how -
<a href="tutorials/fps/tutorial-3/../../../animation/absm_editor.html">read this chapter</a>):</p>
<p><img src="tutorials/fps/tutorial-3/absm_states.png" alt="absm states" /></p>
<p>Connect them with bidirectional transitions and set transition time for them to 0.3s. Select the Animation Blending
State Machine node and assign <code>Animation Player</code> property in the Inspector.</p>
<p>Now add <code>Play Animation</code> pose node for each of the states (double-click on a state, right-click, Play Animation)
and set an appropriate animation from the list in the inspector. For example, for <code>Idle</code> state it could look
like this:</p>
<p><img src="tutorials/fps/tutorial-3/pose_node.png" alt="pose node" /></p>
<p>Click <code>Preview</code> check box, and you should see the bot with <code>Idle</code> animation playing. Let's add two parameters
that will be used for transitions:</p>
<p><img src="tutorials/fps/tutorial-3/parameters.png" alt="parameters" /></p>
<p>All we need to do now is to thoroughly set these variables in all six transitions. Select the <code>Idle -&gt; Attack</code>
transition and in the Inspector find <code>Condition</code> property and type in <code>Attack</code> parameter name:</p>
<p><img src="tutorials/fps/tutorial-3/attack_transition.png" alt="attack transition" /></p>
<p>For the opposite transition you need to add almost the same, but with additional <code>Not</code> computational node:</p>
<p><img src="tutorials/fps/tutorial-3/attack_rev_transition.png" alt="attack reverse transition" /></p>
<p>Do the same for the rest of four transitions, all six transitions should have these values set:</p>
<ul>
<li><code>Idle -&gt; Attack</code> - Parameter(Attack)</li>
<li><code>Attack -&gt; Idle</code> - Not(Parameter(Attack))</li>
<li><code>Idle -&gt; Run</code> - And(Parameter(Run), Not(Parameter(Attack)))</li>
<li><code>Run -&gt; Idle</code> - Not(Parameter(Run))</li>
<li><code>Run -&gt; Attack</code> - And(Parameter(Run), Parameter(Attack))</li>
<li><code>Attack -&gt; Run</code> - And(Parameter(Run), Not(Parameter(Attack)))</li>
</ul>
<p>Click <code>Preview</code> and click on some parameters, you should see transitions between states.</p>
<p>You may probably notice that there's something off with <code>Attack</code> state, sometimes it enters it in mid-attack
state. This happens because the attack animation could be in arbitrary play time. It could be fixed by adding
a <code>Rewind Animation</code> action when entering <code>Attack</code> state. Select the <code>Attack</code> state, find <code>On Enter Actions</code> in
the Inspector and add a new action by clicking <code>+</code> button, select <code>Rewind Animation</code> and select <code>zombie_attack</code>
from the list.</p>
<p>Great, now we have all animations working, and now we can add a physical capsule for the bot, so it won't fall
through the ground. Replace the root node of the prefab with a Rigid Body, add a capsule collider child node to
it, adjust its size to fully enclose the bot (we did the same in the first tutorial, but for player):</p>
<p><img src="tutorials/fps/tutorial-3/rigid_body.png" alt="rigid body" /></p>
<p>Do not forget to disable rotations for the rigid body (<code>X/Y/Z Rotation Locked</code> properties must be checked) and
disable sleeping for it (uncheck <code>Can Sleep</code>). For now, our prefab is more or less finished. As usual, we need to
write some code, that will drive the bot.</p>
<h2 id="code-3"><a class="header" href="#code-3">Code</a></h2>
<p>Add a new script using the following command:</p>
<pre><code class="language-shell">fyrox-template script --name=bot
</code></pre>
<p>Add this module to the <code>lib.rs</code> module as we did in the previous tutorials. Register the bot in the <code>register</code>
method like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        context
            .serialization_context
            .script_constructors
            .add::&lt;Bot&gt;("Bot");
<span class="boring">}</span></code></pre></pre>
<p>At first, our bot needs an ability "to see". In games such ability can be represented by a simple frustum with
its top at the head of the bot and the base oriented forward. We can construct such frustum from a pair of
matrices - view and projection. After that the frustum can be used for simple frustum-point intersection check.
We'll check if the player's position intersects with the bot's viewing frustum and if so, the bot will start
chasing the player. On to the code we go, add the following field to the <code>Bot</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[visit(skip)]
    #[reflect(hidden)]
    frustum: Frustum,
<span class="boring">}</span></code></pre></pre>
<p>To construct the frustum, add the following code somewhere in the <code>bot.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update_frustum(
        &amp;mut self,
        position: Vector3&lt;f32&gt;,
        look_vector: Vector3&lt;f32&gt;,
        up_vector: Vector3&lt;f32&gt;,
        max_observing_distance: f32,
    ) {
        // Calculate an average head position.
        let head_pos = position + Vector3::new(0.0, 0.4, 0.0);
        let look_at = head_pos + look_vector;

        // View matrix is constructed using three parameters - observer position, target point,
        // and an up vector (usually it is just (0,1,0) vector).
        let view_matrix =
            Matrix4::look_at_rh(&amp;Point3::from(head_pos), &amp;Point3::from(look_at), &amp;up_vector);

        // Build the perspective projection matrix.
        let projection_matrix = Matrix4::new_perspective(
            // Aspect ratio
            16.0 / 9.0,
            // Field of view of the bot
            90.0f32.to_radians(),
            0.1,
            max_observing_distance,
        );
        self.frustum =
            Frustum::from_view_projection_matrix(projection_matrix * view_matrix).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p>We'll call this method every frame to keep the frustum updated with the current location and orientation of
the bot. Add the following code to the <code>on_update</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Some(rigid_body) = ctx.scene.graph.try_get_mut_of_type::&lt;RigidBody&gt;(ctx.handle) {
            let position = rigid_body.global_position();
            let up_vector = rigid_body.up_vector();
            let look_vector = rigid_body.look_vector();

            // Update the viewing frustum.
            self.update_frustum(position, look_vector, up_vector, 20.0);
        }
<span class="boring">}</span></code></pre></pre>
<p>Now we need to check if the player's position intersects with the frustum. Add the following code at the beginning
of <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // Look for targets only if we don't have one.
        if self.target.is_none() {
            for (handle, node) in ctx.scene.graph.pair_iter() {
                if node.has_script::&lt;Player&gt;()
                    &amp;&amp; self.frustum.is_contains_point(node.global_position())
                {
                    self.target = handle;
                    break;
                }
            }
        }

        // A helper flag, that tells the bot that it is close enough to a target for melee
        // attack.
        let close_to_target = ctx
            .scene
            .graph
            .try_get(self.target)
            .map_or(false, |target| {
                target
                    .global_position()
                    .metric_distance(&amp;ctx.scene.graph[ctx.handle].global_position())
                    &lt; 1.25
            });
<span class="boring">}</span></code></pre></pre>
<p>In this code we're iterating over the all available scene nodes and check if a node has <code>Player</code> script and
if the node's position intersects with the bot's frustum. If so, we're remembering this node as a target.
Do not forget to add this code to the <code>Bot</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[visit(skip)]
    #[reflect(hidden)]
    target: Handle&lt;Node&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Now we need to add movement for the bot, we'll use <a href="tutorials/fps/tutorial-3/../../../animation/root_motion/root_motion.html#how-to-use">root motion</a>
for that. Root motion will be extracted from the animation blending state machine we've made earlier. Let's
add this code to the <code>Bot</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    absm: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
    model_root: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>The first field will hold a handle to the ABSM and the second - a handle to the 3D model root. We'll assign
these field later, now we need to add the code that will extract velocity vector for the bot movement and apply
this vector to the rigid body of the bot:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let model_transform = ctx
            .scene
            .graph
            .try_get(*self.model_root)
            .map(|model| model.global_transform())
            .unwrap_or_default();

        let mut velocity = Vector3::default();
        if let Some(state_machine) = ctx
            .scene
            .graph
            .try_get_mut(*self.absm)
            .and_then(|node| node.component_mut::&lt;AnimationBlendingStateMachine&gt;())
        {
        }
<span class="boring">}</span></code></pre></pre>
<p>At first, we're getting current world-space transform of the 3D model's root and saving it into a local variable.
Then we're borrowing the ABSM we've made earlier and extracting the root motion offset vector. As a final step
we're scaling it by <code>1.0 / dt</code> factor to convert it to velocity. This final velocity vector needs to be set to
the rigid body of the bot. To do that, add the following code at the end of the last <code>if</code> statement (where
we're borrowing the rigid body):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            let y_vel = rigid_body.lin_vel().y;
            rigid_body.set_lin_vel(Vector3::new(velocity.x, y_vel, velocity.z));
<span class="boring">}</span></code></pre></pre>
<p>Next we need to somehow inform the ABSM about the current state of the bot. Remember that we have two parameters
in the ABSM? We need to set them from the code, it could be done like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            let y_vel = rigid_body.lin_vel().y;
            rigid_body.set_lin_vel(Vector3::new(velocity.x, y_vel, velocity.z));
<span class="boring">}</span></code></pre></pre>
<p>Now it's time to do small adjustments to our prefabs. Open the <code>zombie.rgs</code> prefab and assign the <code>Bot</code>
script to the root node of the prefab, set its properties like so:</p>
<p><img src="tutorials/fps/tutorial-3/bot_properties.png" alt="bot properties" /></p>
<p>Open the <code>scene.rgs</code>, find the <code>zombie.rgs</code> prefab in the asset browser and instantiate it in the scene:</p>
<p><img src="tutorials/fps/tutorial-3/bot_instance.png" alt="bot instance" /></p>
<p>Now you can run the game and walk in front of the bot, it should run, but it runs straight and does not follow
the target (the player). Let's fix that. At first, we need to calculate an angle between a target and the bot.
We'll calculate it using <code>atan2</code> trigonometric function, add the following code somewhere in <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let angle_to_target = ctx.scene.graph.try_get(self.target).map(|target| {
            let self_position = ctx.scene.graph[ctx.handle].global_position();
            let look_dir = target.global_position() - self_position;
            look_dir.x.atan2(look_dir.z)
        });
<span class="boring">}</span></code></pre></pre>
<p>This code calculates a vector between the bot's position and a target, and then calculates an angle in XZ plane,
using <code>atan2(x, z)</code> trigonometric function. Let's use this angle, add the following code the end of the
last <code>if</code> statement (where we're borrowing the rigid body):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            if let Some(angle) = angle_to_target {
                rigid_body
                    .local_transform_mut()
                    .set_rotation(UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), angle));
            }
<span class="boring">}</span></code></pre></pre>
<p>This code is trivial - we're making a rotation quaternion, that rotates the bot around Y axis using the angle
we've calculated.</p>
<p>Run the game and the bot should follow you as long as it sees you:</p>
<p><img src="tutorials/fps/tutorial-3/bot.gif" alt="bot" /></p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>In this tutorial part we've added bots with animation and simple AI. In the next tutorial we'll add an ability to
kill the bots.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-interface-tutorial-wip"><a class="header" href="#user-interface-tutorial-wip">User Interface Tutorial (WIP)</a></h1>
<p>This tutorial shows how to create a user interface.</p>
<p>Work-in-progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community-tutorials"><a class="header" href="#community-tutorials">Community Tutorials</a></h1>
<p>This page contains links to the tutorials made by the community.</p>
<ul>
<li><a href="https://bocksdincoding.com/blog/game-development-with-fyrox-and-rust-pt-1">Game Development with Fyrox and Rust (Pt 1: Project Setup)</a></li>
<li><a href="https://bocksdincoding.com/blog/game-development-with-fyrox-and-rust-pt-2">Game Development with Fyrox and Rust (Pt 2: Player Controller)</a></li>
<li><a href="https://bocksdincoding.com/blog/game-development-with-fyrox-and-rust-pt-3">Game Development with Fyrox and Rust (Pt 3: Game Terrain)</a></li>
<li><a href="https://bocksdincoding.com/blog/game-development-with-fyrox-and-rust-pt-4">Game Development with Fyrox and Rust (Pt 4: Enemy Spawner)</a></li>
<li><a href="https://bocksdincoding.com/blog/game-development-with-fyrox-and-rust-pt-5">Game Development with Fyrox and Rust (Pt 5: Enemy Movement and Attack)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-12"><a class="header" href="#performance-12">Performance</a></h1>
<p>This section of the book covers very specific cases of extreme performance, that is suitable for some exceptional cases.
For the vast majority of cases, standard engine approaches are perfectly fine.</p>
<h2 id="ecs"><a class="header" href="#ecs">ECS</a></h2>
<p>Theoretically, the ECS approach <em>can</em> give you better performance, but lets at first see where ECS is beneficial,
and why classic approach is still viable. The ECS is beneficial <em>only</em> in cases where you have to process
<strong>ten or hundreds thousands</strong> objects every frame, the performance gain of cache friendliness can be significant
in such cases. But let's stop for a second and ask ourselves again: how <em>often</em> games have such huge number of objects
that has to be processed every frame? There are very few examples of such games:</p>
<ul>
<li>Strategy games - at some extent, because there are very few games that allows you to control tens of thousands
units at the same time. More often you have a range from five hundreds up to few thousands.</li>
<li>Sandboxes - there could be lots of tiny objects that has to be processed every frame.</li>
<li>Specific genres - games with destructible environment and so on.</li>
</ul>
<p>Note that the list does not include games with vast worlds, why so? The reason is that such games does <strong>not</strong>
process every tiny object in the world at once, instead they split the world in small chunks and process only
few chunks at once, those where the player is present.</p>
<p>The rest of genres operate on a tiny number of objects compared to those up above, maybe a few hundreds at max.
One might say - hey, each object could contain lots of tiny "moving parts", what's about them? Usually each
object contains up to 10-15 sub-parts, which leads us to few thousands of "atomic" object. Is it much? Not really.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p>One might also think that ECS is a silver bullet for borrow checker in Rust, which "shuts its noisy mouth" once
and for all leaving you only with your game code. That's not quite true, it somewhat solves the problem of unique
mutable access to data, but interaction between systems can still be painful. Standard OOP-approach is always being
criticized by allowing you to create spaghetti-code for which borrow checker will yell at you (which is indeed
reasonable). We should consider borrow checker not as our enemy, that prevents us from writing code, but as
our friend that tells us - "dude, this won't work without potential crashes, memory issues, etc.". What borrow
checker tries to tell us is that we need to re-think the architecture of our game.</p>
<p>So how does Fyrox solve the problem of unique mutable access? It forces you to use a "top-down" flow in your game.
What does that mean? In short, you have to change the data only by going from top to bottom on a call tree. But
isn't that too restrictive, what if I want to call some higher-level function while being in lower-level function?
This is a very good question, and a short answer for it: <em>no</em>. It isn't restrictive at all, because you can always
invert the "bottom-to-top" flow to "top-down". The "bottom-to-top" calls are prohibited, because they're violating
unique mutable borrow rules.</p>
<p>The flow can be easily inverted by <em>deferring</em> actions for later, not for a next frame, but for a moment after
the place where "bottom-to-top" call was required. How this can be achieved? All you should do is to collect the
info that is needed to perform inverted "bottom-to-top" call and do a call right after that place where it was
required, but starting from the top level of your game. One of the most common approaches for this is to use
message passing with Rust's channels (MPSC queue). The receiver should be polled at the top level of your game
and every other place that needs "bottom-to-top" call should just queue desired actions by providing required info
in respective message.</p>
<p>This is a very simple, yet powerful mechanism to satisfy make your code clearer and satisfy borrow checker. One
may argue that such approach has some performance impact. It is indeed has performance impact, but it is tiny, in
most cases it can't be even measured.</p>
<p>Borrowing issues cannot be fully prevented, even the right architecture can't help borrow checker to prove that
your code is safe in some cases (graph data structure for example). To solve this problem, the engine uses
generational arenas (<em>pool</em> in Fyrox's terminology) and handles. Instead of storing the objects in various places,
you put all your objects in a pool, and it gives you handles which can later be used to borrow a reference to
that object. This approach allows you to build any data structures that may hold "references" to other objects.
The references replaced with handles, which can be treated (very roughly) as just an index. See
<a href="performance/../beginning/data_management.html">separate chapter</a> in the book for more info.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
