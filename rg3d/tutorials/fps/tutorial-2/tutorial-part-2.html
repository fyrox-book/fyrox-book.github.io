<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Weapons - rg3d Cheat Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../../favicon.svg">
        <link rel="shortcut icon" href="../../../../favicon.png">
        <link rel="stylesheet" href="../../../../css/variables.css">
        <link rel="stylesheet" href="../../../../css/general.css">
        <link rel="stylesheet" href="../../../../css/chrome.css">
        <link rel="stylesheet" href="../../../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../../highlight.css">
        <link rel="stylesheet" href="../../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/introduction.html"><strong aria-hidden="true">2.</strong> rg3d</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/getting_started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/framework.html"><strong aria-hidden="true">2.1.1.</strong> Framework</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/custom_game_loop.html"><strong aria-hidden="true">2.1.2.</strong> Custom game loop</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/scene_and_scene_graph.html"><strong aria-hidden="true">2.1.3.</strong> Scene and scene graph</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/beginning/data_management.html"><strong aria-hidden="true">2.1.4.</strong> Data management</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/animation/animation.html"><strong aria-hidden="true">2.2.</strong> Animation</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/rendering/rendering.html"><strong aria-hidden="true">2.3.</strong> Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/rendering/shaders.html"><strong aria-hidden="true">2.3.1.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/rendering/materials.html"><strong aria-hidden="true">2.3.2.</strong> Materials</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/sound/sound.html"><strong aria-hidden="true">2.4.</strong> Sound</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/physics/physics.html"><strong aria-hidden="true">2.5.</strong> Physics</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/ui/ui.html"><strong aria-hidden="true">2.6.</strong> User Interface</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/resources/resources.html"><strong aria-hidden="true">2.7.</strong> Resource Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../.rg3d/resources/sound.html"><strong aria-hidden="true">2.7.1.</strong> 3D Models</a></li><li class="chapter-item expanded "><a href="../../../../.rg3d/resources/texture.html"><strong aria-hidden="true">2.7.2.</strong> Textures</a></li><li class="chapter-item expanded "><a href="../../../../.rg3d/resources/sound.html"><strong aria-hidden="true">2.7.3.</strong> Sound Buffers</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/tutorials.html"><strong aria-hidden="true">2.8.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/fps/intro.html"><strong aria-hidden="true">2.8.1.</strong> FPS Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.8.1.1.</strong> Character controller</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/fps/tutorial-2/tutorial-part-2.html" class="active"><strong aria-hidden="true">2.8.1.2.</strong> Weapons</a></li><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html"><strong aria-hidden="true">2.8.1.3.</strong> Bots and AI</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/rpg/intro.html"><strong aria-hidden="true">2.8.2.</strong> RPG Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../rg3d/tutorials/rpg/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.8.2.1.</strong> Character controller</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../../rusty-editor/introduction.html"><strong aria-hidden="true">3.</strong> rusty-editor</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rg3d Cheat Book</h1>

                    <div class="right-buttons">
                        <a href="../../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><strong>Source code</strong>: <a href="https://github.com/rg3dengine/rg3d-tutorials/tree/main/tutorial2-character-controller">GitHub</a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#adding-weapons">Adding weapons</a></li>
<li><a href="#game-architecture">Game architecture</a></li>
<li><a href="#recoil">Recoil</a></li>
<li><a href="#impact-effects">Impact effects</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Of course for a shooter game we need weapons and targets to shoot at. In this tutorial we'll add weapons to the game.
For simplicity, we'll add only one weapon, as you'll see later it is pretty easy to add more weapons yourself. This 
is the result we're aiming in the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GmVAdBdnqeM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="adding-weapons"><a class="header" href="#adding-weapons">Adding weapons</a></h2>
<p>Let's begin by changing version of the engine first, as I wrote in the previous tutorial, the engine changes rapidly:</p>
<pre><code class="language-toml">rg3d = &quot;0.20&quot;
</code></pre>
<p>Next, add new module <code>weapon.rs</code> near your <code>main.rs</code> and use it somewhere after other imports:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod weapon;
...
use weapon::Weapon;
<span class="boring">}
</span></code></pre></pre>
<p>Switch to <code>weapon.rs</code> and paste this code into it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rg3d::{
    core::pool::Handle,
    engine::resource_manager::ResourceManager,
    scene::{node::Node, Scene},
};

pub struct Weapon {
    model: Handle&lt;Node&gt;,
    shot_point: Handle&lt;Node&gt;,
    shot_timer: f32,
}

impl Weapon {
    pub async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self {
        // Yeah, you need only few lines of code to load a model of any complexity.
        let model = resource_manager
            .request_model(&quot;data/models/m4.fbx&quot;)
            .await
            .unwrap()
            .instantiate_geometry(scene);

        let shot_point = scene.graph.find_by_name(model, &quot;Weapon:ShotPoint&quot;);

        Self {
            model,
            shot_point,
            shot_timer: 0.0,
        }
    }

    pub fn model(&amp;self) -&gt; Handle&lt;Node&gt; {
        self.model
    }

    pub fn shot_point(&amp;self) -&gt; Handle&lt;Node&gt; {
        self.shot_point
    }

    pub fn update(&amp;mut self, dt: f32) {
        self.shot_timer = (self.shot_timer - dt).min(0.0);
    }

    pub fn can_shoot(&amp;self) -&gt; bool {
        self.shot_timer &lt;= 0.0
    }

    pub fn shoot(&amp;mut self) {
        self.shot_timer = 1.0;
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>This piece of code just loads a <a href="./m4.zip">weapon model</a> and saves an instance handle for 
further use. Also, each weapon should contain a helper node that tells from where it will &quot;emit&quot; bullets, the node 
was added in a 3D editor and has name <code>Weapon:ShotPoint</code>. Weapon implementation has helper methods that provide read-only
access to inner fields (<code>model</code>, <code>shot_point</code>). <code>update</code> method just decreases the timer's value which is used to change
the pace of shooting. You may ask &quot;why <code>shoot</code> method just modifies timer's value and does not create bullets, etc.?&quot; -
please be patient, I will explain this later in <a href="#game-architecture">game architecture</a> section of the tutorial.
OK, now we need to make a point where every weapon will be &quot;mounted&quot; on, go to <code>Player::new</code> and add these lines in 
the <code>CameraBuilder</code> instance:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_children(&amp;[{
	weapon_pivot = BaseBuilder::new()
		.with_local_transform(
			TransformBuilder::new()
				.with_local_position(Vector3::new(-0.1, -0.05, 0.015))
				.build(),
		)
		.build(&amp;mut scene.graph);
	weapon_pivot
}]
<span class="boring">}
</span></code></pre></pre>
<p>What is going on here? We're just adding new child node to the camera and offset it by some vector. Every weapon will
be attached to this pivot. Please keep in mind that the offset given in <strong>local</strong> coordinates, which means that weapon
pivot will move with the camera, but with some offset relative to it. Also, do not forget to add this line after 
<code>let camera;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let weapon_pivot;
<span class="boring">}
</span></code></pre></pre>
<p>Finally, add the weapon pivot to <code>Self { ... }</code> (and also add <code>weapon_pivot: Handle&lt;Node&gt;</code> to the <code>Player</code> struct):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    pivot,
    camera,
    weapon_pivot, // &lt;- here
    rigid_body: rigid_body_handle.into(),
    controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Next we need a container for weapons, let's add it to the <code>Game</code> struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player,
    weapons: Pool&lt;Weapon&gt; // Weapons will live in a pool
}
<span class="boring">}
</span></code></pre></pre>
<p>Also do not forget to import <code>Pool</code> from <code>rg3d::core::pool</code> in <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use rg3d::core::pool::{Handle, Pool};
...
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to change <code>Game::new()</code> a bit to add a weapon to the player:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn new(engine: &amp;mut GameEngine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request_model(&quot;data/models/scene.rgs&quot;)
        .await
        .unwrap()
        .instantiate_geometry(&amp;mut scene);

    // Create player first.
    let player = Player::new(&amp;mut scene, engine.resource_manager.clone()).await;

    // Create weapon next.
    let weapon = Weapon::new(&amp;mut scene, engine.resource_manager.clone()).await;

    // &quot;Attach&quot; the weapon to the weapon pivot of the player.
    scene.graph.link_nodes(weapon.model(), player.weapon_pivot);

    // Create a container for the weapons.
    let mut weapons = Pool::new();

    // Put the weapon into it.
    weapons.spawn(weapon);

    Self {
        player,
        scene: engine.scenes.add(scene),
        weapons,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>At first, we're loading the scene, next we're creating player as usual. Next we're creating a weapon and attach it to 
the weapon pivot we've made earlier. Finally, we're creating a container for the weapons: we'll use Pool to be able 
to borrow weapon later on when we need. So, let's run the game, and you should see something like this:</p>
<p><img src="./weapon.jpg" alt="Weapon" /></p>
<p>Alright, now we have a weapon, but it still can't shoot. Let's fix that. </p>
<h3 id="game-architecture"><a class="header" href="#game-architecture">Game architecture</a></h3>
<p>We at the point now where we need to choose correct approach of interaction between parts of the game. We already have
two kinds of entities: player and weapon. In naive approach to shoot a weapon, you'd pass a reference to a weapon in 
<code>Player::update()</code> and would call something like <code>weapon.shoot()</code>. Most likely that at some point you'll end up
in a situation when you need too much of a context in a single method. This is so-called strong coupling, this is
the thing that disappoints borrow checker too much, and it rejects your code because you're trying to borrow same things
multiple times. So we need a way to change strong coupling to loose coupling. To do that we'll use messages to delay 
execution of some actions that require too much of a context. In general, we'll replace direct function call with a 
message that will be put in a common queue and executed later on one by one at the top of call hierarchy (in 
<code>Game::update</code> in our case). Let's begin by adding a MPSC (Multiple Producer Single Consumer) queue to the <code>Game</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player,
    weapons: Pool&lt;Weapon&gt;,
    receiver: Receiver&lt;Message&gt;, // Single receiver, it cannot be cloned.
    sender: Sender&lt;Message&gt;, // Sender can be cloned and used from various places.
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need a <code>Message</code> enumeration, add <code>message.rs</code> module, import it in <code>main.rs</code> (<code>pub mod message;</code>) and fill it
with the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::weapon::Weapon;
use rg3d::core::pool::Handle;

pub enum Message {
    ShootWeapon {
        weapons: Handle&lt;Weapon&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For now, we have only one message kind - <code>ShootWeapon</code> with a single parameter, a handle of a weapon to shoot. We need
a place to handle messages, <code>Game::update</code> seems to be the most suitable - it is on top of &quot;call hierarchy&quot; and has 
most wide context. Let's change <code>Game::update</code> to this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, engine: &amp;mut GameEngine, dt: f32) {
    self.player.update(&amp;mut engine.scenes[self.scene]); 

    // v New code v 
    //
    for weapon in self.weapons.iter_mut() {
        weapon.update(dt);
    }

    // We're using `try_recv` here because we don't want to wait until next message -
    // if the queue is empty just continue to next frame.
    while let Ok(message) = self.receiver.try_recv() {
        match message {
            Message::ShootWeapon { weapon } =&gt; {
                self.shoot_weapon(weapon, engine);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>So, these first three new lines updating every weapon in the game, for now update of a weapon just updates shooting timer.
As you can see we've added new parameter to the function <code>dt: f32</code>, this is the time span from last frame. Do not forget
to pass this parameter in <code>fn main()</code>: <code>game.update(&amp;mut engine, TIMESTEP);</code>. Finally, at the end of the function we're
handling messages from the queue one by one. As you can see we're handling <code>ShootWeapon</code> message, but there is a 
mysterious line <code>self.shoot_weapon(weapon, engine)</code> which is not yet defined, let's fix that, add these lines to 
<code>impl Game</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shoot_weapon(&amp;mut self, weapon: Handle&lt;Weapon&gt;, engine: &amp;mut GameEngine) {
    let weapon = &amp;mut self.weapons[weapon];

    if weapon.can_shoot() {
        weapon.shoot();

        let scene = &amp;mut engine.scenes[self.scene];

        let weapon_model = &amp;scene.graph[weapon.model()];

        // Make a ray that starts at the weapon's position in the world and look toward
        // &quot;look&quot; vector of the weapon.
        let ray = Ray::new(
            scene.graph[weapon.shot_point()].global_position(),
            weapon_model.look_vector().scale(1000.0),
        );

        let mut intersections = Vec::new();

        scene.physics.cast_ray(
            RayCastOptions {
                ray,
                max_len: ray.dir.norm(),
                groups: Default::default(),
                sort_results: true, // We need intersections to be sorted from closest to furthest.
            },
            &amp;mut intersections,
        );

        // Ignore intersections with player's capsule.
        let trail_length = if let Some(intersection) = intersections
            .iter()
            .find(|i| i.collider != self.player.collider)
        {
            //
            // TODO: Add code to handle intersections with bots.
            //

            // For now just apply some force at the point of impact.
            let collider = scene
                .physics
                .colliders
                .get(intersection.collider.into())
                .unwrap();
            scene
                .physics
                .bodies
                .get_mut(collider.parent())
                .unwrap()
                .apply_force_at_point(
                    ray.dir.normalize().scale(10.0),
                    intersection.position,
                    true,
                );

            // Trail length will be the length of line between intersection point and ray origin.
            (intersection.position.coords - ray.origin).norm()
        } else {
            // Otherwise trail length will be just the ray length.
            ray.dir.norm()
        };

        create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Wow! Why is there so much code to shoot a weapon!? Actually, this is not all the code - check the last line</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
<span class="boring">}
</span></code></pre></pre>
<p>This is yet another function we must add, it is a standalone helper function that creates a shot trail:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_shot_trail(
    graph: &amp;mut Graph,
    origin: Vector3&lt;f32&gt;,
    direction: Vector3&lt;f32&gt;,
    trail_length: f32,
) {
    let transform = TransformBuilder::new()
        .with_local_position(origin)
        .with_local_scale(Vector3::new(0.0025, 0.0025, trail_length))
        .with_local_rotation(UnitQuaternion::face_towards(&amp;direction, &amp;Vector3::y()))
        .build();

    // Create unit cylinder with caps that faces toward Z axis.
    let shape = Arc::new(RwLock::new(SurfaceData::make_cylinder(
        6,     // Count of sides
        1.0,   // Radius
        1.0,   // Height
        false, // No caps are needed.
        // Rotate vertical cylinder around X axis to make it face towards Z axis
        &amp;UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), 90.0f32.to_radians()).to_homogeneous(),
    )));

    MeshBuilder::new(
        BaseBuilder::new()
            .with_local_transform(transform)
            // Shot trail should live ~0.25 seconds, after that it will be automatically
            // destroyed.
            .with_lifetime(0.25),
    )
    .with_surfaces(vec![SurfaceBuilder::new(shape)
        // Set yellow-ish color.
        .with_color(Color::from_rgba(255, 255, 0, 120))
        .build()])
    // Do not cast shadows.
    .with_cast_shadows(false)
    // Make sure to set Forward render path, otherwise the object won't be
    // transparent.
    .with_render_path(RenderPath::Forward)
    .build(graph);
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay... Let's disassemble this heap of code line by line. At first, we're borrowing the weapon by its handle and 
check if it can shoot (if the timer has reached zero), and &quot;shoot&quot; (reset the timer) if so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let weapon = &amp;mut self.weapons[weapon];

    if weapon.can_shoot() {
        weapon.shoot();
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Next we're using ray casting to find the target we're shooting at:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

let scene = &amp;mut engine.scenes[self.scene];

let weapon_model = &amp;scene.graph[weapon.model()];

// Make a ray that starts at the weapon's position in the world and look toward
// &quot;look&quot; vector of the weapon.
let ray = Ray::new(
    scene.graph[weapon.shot_point()].global_position(),
    weapon_model.look_vector().scale(1000.0),
);

let mut intersections = Vec::new();

scene.physics.cast_ray(
    RayCastOptions {
        ray,
        max_len: ray.dir.norm(),
        groups: Default::default(),
        sort_results: true, // We need intersections to be sorted from closest to furthest.
    },
    &amp;mut intersections,
);

...
<span class="boring">}
</span></code></pre></pre>
<p>To determine the &quot;target&quot;, we're have to make a ray first. It starts from the &quot;shot point&quot; we've attached to the weapon.
Direction of the ray is the &quot;look&quot; vector of the weapon model scaled by some large value which defines a &quot;length&quot; of the
ray. Finally, we're casting the ray. Next we have to check each intersection and find the target:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ignore intersections with player's capsule.
let trail_length = if let Some(intersection) = intersections
    .iter()
    .find(|i| i.collider != self.player.collider)
{
    //
    // TODO: Add code to handle intersections with bots.
    //

    // For now just apply some force at the point of impact.
    let collider = scene
        .physics
        .colliders
        .get(intersection.collider.into())
        .unwrap();
    scene
        .physics
        .bodies
        .get_mut(collider.parent())
        .unwrap()
        .apply_force_at_point(
            ray.dir.normalize().scale(10.0),
            intersection.position,
            true,
        );

    // Trail length will be the length of line between intersection point and ray origin.
    (intersection.position.coords - ray.origin).norm()
} else {
    // Otherwise trail length will be just the ray length.
    ray.dir.norm()
};
<span class="boring">}
</span></code></pre></pre>
<p>First intersection most likely will be player's capsule, because shot point may be inside player's capsule. We're 
filtering such intersection in the first three lines. To do that, we have to remember the handle of player's capsule
in <code>Player</code>: <code>collider: ColliderHandle</code> and fill the field in <code>Player::new</code> like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add capsule collider for the rigid body.
let collider = scene.physics.add_collider(
    ColliderBuilder::capsule_y(0.25, 0.2).build(),
    rigid_body_handle,
);

...

Self {
    ...
    collider, // &lt;-
    ...
}

<span class="boring">}
</span></code></pre></pre>
<p>Next goes <code>TODO</code> comment, remember this line, it will be replaced when we'll add bots in future tutorial.
Until we have no bots, we should somehow emulate shot impact, to do that we'll just apply some force at the point of
impact. Finally, we're calculating desired shot trail length - it is just distance between point of impact and ray's 
origin. In the <code>else</code> branch we're setting the length to be the length of the ray. Finally, we're creating a shot trail: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
<span class="boring">}
</span></code></pre></pre>
<p>Now let's dive into this function. It starts from the definition of local transform of the trail:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let transform = TransformBuilder::new()
    .with_local_position(origin)
    // Scale the trail in XZ plane to make it thin, and apply `trail_length` scale on Y axis
    // to stretch is out.
    .with_local_scale(Vector3::new(0.0025, 0.0025, trail_length))
    // Rotate the trail along given `direction`
    .with_local_rotation(UnitQuaternion::face_towards(&amp;direction, &amp;Vector3::y()))
    .build();
<span class="boring">}
</span></code></pre></pre>
<p>Its purpose is to shrink cylinder in XZ plane and stretch it out on Y axis to the length of the trail. Next we're making
geometry for the cylinder:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create unit cylinder with caps that faces toward Z axis.
let shape = Arc::new(RwLock::new(SurfaceData::make_cylinder(
    6,     // Count of sides
    1.0,   // Radius
    1.0,   // Height
    false, // No caps are needed.
    // Rotate vertical cylinder around X axis to make it face towards Z axis
    &amp;UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), 90.0f32.to_radians()).to_homogeneous(),
)));
<span class="boring">}
</span></code></pre></pre>
<p>Here we're creating unit vertical cylinder, rotate it to make it face towards Z axis. Finally, we're creating mesh node:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MeshBuilder::new(
    BaseBuilder::new()
        .with_local_transform(transform)
        // Shot trail should live ~0.25 seconds, after that it will be automatically
        // destroyed.
        .with_lifetime(0.25),
)
.with_surfaces(vec![SurfaceBuilder::new(shape)
    // Set yellow-ish color.
    .with_color(Color::from_rgba(255, 255, 0, 120))
    .build()])
// Do not cast shadows.
.with_cast_shadows(false)
// Make sure to set Forward render path, otherwise the object won't be
// transparent.
.with_render_path(RenderPath::Forward)
.build(graph);
<span class="boring">}
</span></code></pre></pre>
<p>The trail will live just 0.25 seconds, rg3d has built-in functionality for short-living objects, you have to just set 
desired lifetime, and an object will be removed at the time. Also, we don't want the trail to cast shadows, and we want 
the trail to be transparent yellow, to do that we have to change render path of the mesh to <code>Forward</code>. In short, every
mesh by default rendered using <code>Deferred</code> renderer which does not support transparent objects due to technical reasons,
but rg3d has <code>Forward</code> renderer for such objects. Check this <a href="https://www.3dgep.com/forward-plus/">article</a> to learn more 
about Deferred and Forward rendering techniques. Ok, now we have to &quot;teach&quot; player how to shoot. At first, let's add new 
field to <code>InputController</code>: <code>shoot: bool</code>. We'll be changing this flag by left mouse click, to do that let's add these lines
at the end of <code>Event::WindowEvent</code> match arm before <code>_ =&gt; {}</code> in <code>Player::process_input_event</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;WindowEvent::MouseInput { button, state, .. } =&gt; {
    if button == MouseButton::Left {
        self.controller.shoot = state == ElementState::Pressed;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need a way to send messages to the game from the player. We need a new field in <code>Player</code> struct 
<code>sender: Sender&lt;Message&gt;</code>. Also, we must change signature of <code>Player::new()</code> to this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
    sender: Sender&lt;Message&gt;,
) -&gt; Self 
<span class="boring">}
</span></code></pre></pre>
<p>Just pass the <code>sender</code> in the <code>Self { .. }</code> like this: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...
    sender, // &lt;- Pass sender 
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Player must know about its weapons, let's fix this by adding new field to the <code>Player</code>: <code>weapon: Handle&lt;Weapon&gt;</code>, we'll
fill this field in the <code>Game::new()</code>, not in <code>Player::new()</code> because at the moment of creation of the player there are
no weapons:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

// Put the weapon into it - this operation moves the weapon in the pool and returns handle.
let weapon = weapons.spawn(weapon);

// &quot;Give&quot; the weapon to the player.
player.weapon = weapon;

...
<span class="boring">}
</span></code></pre></pre>
<p>Finally, at the end of <code>Player::update</code> we will handle the state of the input controller:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.controller.shoot {
    self.sender
        .send(Message::ShootWeapon {
            weapon: self.weapon,
        })
        .unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, at this momemt you should be able to compile the game and as you run it, you should see something like this when
you'll press left mouse button:</p>
<p><img src="./shooting.jpg" alt="Weapon" /></p>
<p>Barrels should react to shots as in the video at the beginning of the tutorial. </p>
<h2 id="recoil"><a class="header" href="#recoil">Recoil</a></h2>
<p>Ok, the weapon shoots but looks kinda unnatural, to fix that we need to add a recoil. This is very simple to do, let's 
start by adding these fields in the <code>Weapon</code> struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recoil_offset: Vector3&lt;f32&gt;,
recoil_target_offset: Vector3&lt;f32&gt;,
<span class="boring">}
</span></code></pre></pre>
<p>Initialize these fields with default values (zero vector):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recoil_offset: Default::default(),
recoil_target_offset: Default::default(),
<span class="boring">}
</span></code></pre></pre>
<p>First vector is the actual recoil offset that will be applied to the weapon model, second - target recoil value which
first vector will follow. Why do we need two vectors instead just one? The answer is very simple, we need to smoothly
change offset over time, and to do that offset will just &quot;follow&quot; target offset which will give us desired smooth 
movement. Let's add the code responsible for the recoil to the <code>Weapon::update</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Notice new `graph` parameter
pub fn update(&amp;mut self, dt: f32, graph: &amp;mut Graph) {  
    self.shot_timer = (self.shot_timer - dt).max(0.0);
    
    // v New code v
        
    // `follow` method defined in Vector3Ext trait and it just increases or
    // decreases vector's value in order to &quot;follow&quot; the target value with 
    // given speed.
    self.recoil_offset.follow(&amp;self.recoil_target_offset, 0.5);

    // Apply offset to weapon's model.
    graph[self.model]
        .local_transform_mut()
        .set_position(self.recoil_offset);

    // Check if we've reached target recoil offset.
    if self
        .recoil_offset
        .metric_distance(&amp;self.recoil_target_offset)
        &lt; 0.001
    {
        // And if so, reset offset to zero to return weapon at
        // its default position.
        self.recoil_target_offset = Default::default();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>At first, in the first line we force the <code>recoil_offset</code> to follow <code>recoil_target_offset</code> with given speed. Next we're 
applying offset to weapon's model. Finally, we're checking if we've reached target offset and if so, just reset target
offset to return a weapon to its default position. Also we have to slightly modify <code>Weapon::shoot</code> to modify target
offset:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn shoot(&amp;mut self) {
    self.shot_timer = 0.1;

    // Set new offset after each shot.
    self.recoil_target_offset = Vector3::new(0.0, 0.0, -0.025); 
}
<span class="boring">}
</span></code></pre></pre>
<p>The last thing we need to do is to slightly modify code at the <code>Game::update</code> to pass new parameter to <code>Weapon::update</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> pub fn update(&amp;mut self, engine: &amp;mut GameEngine, dt: f32) {
    let scene = &amp;mut engine.scenes[self.scene];

    self.player.update(scene);

    for weapon in self.weapons.iter_mut() {
        weapon.update(dt, &amp;mut scene.graph);
    }
        
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Ok, run the game, and the weapon should feel more natural now. </p>
<h2 id="impact-effects"><a class="header" href="#impact-effects">Impact effects</a></h2>
<p>Shooting have become much better after we've added a recoil, but there is still no impact effects like sparks. Let's fix
that! This is the first time when we'll use particle systems. Let's add this function somewhere in <code>main.rs</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_bullet_impact(
    graph: &amp;mut Graph,
    resource_manager: ResourceManager,
    pos: Vector3&lt;f32&gt;,
    orientation: UnitQuaternion&lt;f32&gt;,
) -&gt; Handle&lt;Node&gt; {
    // Create sphere emitter first.
    let emitter = SphereEmitterBuilder::new(
        BaseEmitterBuilder::new()
            .with_max_particles(200)
            .with_spawn_rate(1000)
            .with_size_modifier_range(NumericRange::new(-0.01, -0.0125))
            .with_size_range(NumericRange::new(0.0010, 0.025))
            .with_x_velocity_range(NumericRange::new(-0.01, 0.01))
            .with_y_velocity_range(NumericRange::new(0.017, 0.02))
            .with_z_velocity_range(NumericRange::new(-0.01, 0.01))
            .resurrect_particles(false),
    )
        .with_radius(0.01)
        .build();

    // Color gradient will be used to modify color of each particle over its lifetime.
    let color_gradient = {
        let mut gradient = ColorGradient::new();
        gradient.add_point(GradientPoint::new(0.00, Color::from_rgba(255, 255, 0, 0)));
        gradient.add_point(GradientPoint::new(0.05, Color::from_rgba(255, 160, 0, 255)));
        gradient.add_point(GradientPoint::new(0.95, Color::from_rgba(255, 120, 0, 255)));
        gradient.add_point(GradientPoint::new(1.00, Color::from_rgba(255, 60, 0, 0)));
        gradient
    };

    // Create new transform to orient and position particle system.
    let transform = TransformBuilder::new()
        .with_local_position(pos)
        .with_local_rotation(orientation)
        .build();

    // Finally create particle system with limited lifetime.
    ParticleSystemBuilder::new(
        BaseBuilder::new()
            .with_lifetime(1.0)
            .with_local_transform(transform),
    )
    .with_acceleration(Vector3::new(0.0, -10.0, 0.0))
    .with_color_over_lifetime_gradient(color_gradient)
    .with_emitters(vec![emitter])
    // We'll use simple spark texture for each particle.
    .with_texture(resource_manager.request_texture(Path::new(&quot;data/textures/spark.png&quot;)))
    .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, again a heap of code... As usual, everything here is pretty straightforward. At first, we're creating spherical
emitter - it is a spherical volume that responsible for spawning particles. It has a radius, and a bunch of basic properties
such as spawn rate, maximum amount of particles, initial velocity range, etc. Next we're creating color gradient to make
particles fade over their lifetime. Next, we're creating simple transform that will orient and position particle system 
in world space. Finally, we're creating particle system itself, using pre-made parts. For each particle we'll use simple
<a href="./spark.png">spark texture</a>, it should be placed in <code>data/textures</code>. Now we need to find
correct place to create this particle system. It should be placed right after we're applying force to target we've hit 
in <code>Game::shoot_weapon</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add bullet impact effect.
let effect_orientation = if intersection.normal.normalize() == Vector3::y() {
    // Handle singularity when normal of impact point is collinear with Y axis.
    UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), 0.0)
} else {
    UnitQuaternion::face_towards(&amp;intersection.normal, &amp;Vector3::y())
};

create_bullet_impact(
    &amp;mut scene.graph,
    engine.resource_manager.clone(),
    intersection.position.coords,
    effect_orientation,
);
<span class="boring">}
</span></code></pre></pre>
<p>Ok, now run the game, and you should see something like this:</p>
<p><img src="./impact.jpg" alt="Weapon" /></p>
<p>One more thing that could be added is bullet shells that should come from a weapon when we're shooting, but I think the
tutorial is already pretty big already, and I'll leave this as a &quot;homework&quot;, but I'll just give some hints of how to do 
this. Make or download a shell model in FBX format, then write a function that will load it via resource manager, 
instantiate it and create a physical body for it (with cylinder collider for example), link a model with a body and call 
this function when shooting a weapon.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial we added weapon to the game, added recoil to make shooting more natural, and added impact effects. I 
hope you liked this tutorial, and if so, please consider supporting the project on
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/mrDIMAS/rg3d-tutorials">GitHub</a>. In the next tutorial we'll add sounds to the game and something
special (let it be a surprise).</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/m2055c/writing_a_3d_shooter_using_rg3d_2_adding_shooting/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../../rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../../../rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../../rg3d/tutorials/fps/tutorial-1/tutorial-part-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../../../rg3d/tutorials/fps/tutorial-3/tutorial-part-3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
