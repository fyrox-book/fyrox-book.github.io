<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Text box - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/ui/text_box.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="text-box"><a class="header" href="#text-box">Text Box</a></h1>
<p>TextBox is a text widget that allows you to edit text and create specialized input fields. It has various options like
word wrapping, text alignment, and so on.</p>
<h2 id="how-to-create"><a class="header" href="#how-to-create">How to create</a></h2>
<p>An instance of the TextBox widget could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_box(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="text-alignment-and-word-wrapping"><a class="header" href="#text-alignment-and-word-wrapping">Text alignment and word wrapping</a></h2>
<p>There are various text alignment options for both vertical and horizontal axes. Typical alignment values are:
<code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal axis, and <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical axis. An instance of
centered text could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_centered_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_horizontal_text_alignment(HorizontalAlignment::Center)
        .with_vertical_text_alignment(VerticalAlignment::Center)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Long text is usually needs to wrap on available bounds, there are three possible options for word wrapping:
<code>NoWrap</code>, <code>Letter</code>, <code>Word</code>. An instance of text with word-based wrapping could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_with_word_wrap(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_wrap(WrapMode::Word)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fonts-and-colors"><a class="header" href="#fonts-and-colors">Fonts and colors</a></h2>
<p>To set a color of the text just use <code>.with_foreground(..)</code> of the <code>WidgetBuilder</code> while building the text instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_colored_text_box(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    //                  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    TextBoxBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED).into()))
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>By default, text is created with default font, however it is possible to set any custom font:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_with_font(
    ui: &amp;mut UserInterface,
    text: &amp;str,
    resource_manager: &amp;ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_font(resource_manager.request::&lt;Font&gt;("path/to/your/font.ttf"))
        .with_text(text)
        // You can set any size as well.
        .with_font_size(24.0.into())
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Please refer to <a href="font.html">Font</a> chapter to learn more about fonts.</p>
<h2 id="shadows"><a class="header" href="#shadows">Shadows</a></h2>
<p>TextBox widget supports shadows effect to add contrast to your text, which could be useful to make text readable
independent on the background colors. This effect could be used for subtitles. Shadows are pretty easy to add, all you
need to do is to enable them, setup desired thickness, offset and brush (solid color or gradient).</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_red_text_with_black_shadows(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED).into()))
        .with_text(text)
        // Enable shadows.
        .with_shadow(true)
        // Black shadows.
        .with_shadow_brush(Brush::Solid(Color::BLACK))
        // 1px thick.
        .with_shadow_dilation(1.0)
        // Offset the shadow slightly to the right-bottom.
        .with_shadow_offset(Vector2::new(1.0, 1.0))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>TextBox widget accepts the following list of messages:</p>
<ul>
<li><code>TextBoxMessage::SelectionBrush</code> - change the brush that is used to highlight selection.</li>
<li><code>TextBoxMessage::CaretBrush</code> - changes the brush of the caret (small blinking vertical line).</li>
<li><code>TextBoxMessage::TextCommitMode</code> - changes the <a href="text_box.html#text-commit-mode">text commit mode</a>.</li>
<li><code>TextBoxMessage::Multiline</code> - makes the TextBox either multiline (<code>true</code>) or single line (<code>false</code>)</li>
<li><code>TextBoxMessage::Editable</code> - enables or disables editing of the text.</li>
<li><code>TextMessage::Text</code> - sets or gets the new text.</li>
<li><code>TextMessage::Wrap</code> - sets new <a href="text.html#text-alignment-and-word-wrapping">wrapping mode</a>.</li>
<li><code>TextMessage::Font</code> - sets new <a href="text.html#fonts-and-colors">font</a></li>
<li><code>TextMessage::VerticalAlignment</code> and <code>TextMessage::HorizontalAlignment</code> sets
<a href="text_box.html#text-alignment-and-word-wrapping">vertical and horizontal</a> text alignment respectively.</li>
<li><code>TextMessage::Shadow</code> - enables or disables <a href="text_box.html#shadows">shadow casting</a></li>
<li><code>TextMessage::ShadowDilation</code> - sets "thickness" of the shadows under the tex.</li>
<li><code>TextMessage::ShadowBrush</code> - sets shadow brush (allows you to change color and even make shadow with color gradients).</li>
<li><code>TextMessage::ShadowOffset</code> - sets offset of the shadows.</li>
</ul>
<p>An example of changing text at runtime could be something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn request_change_text(ui: &amp;UserInterface, text_box_widget_handle: Handle&lt;UiNode&gt;, text: &amp;str) {
    ui.send_message(TextMessage::text(
        text_box_widget_handle,
        MessageDirection::ToWidget,
        text.to_owned(),
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>Please keep in mind, that like any other situation when you "changing" something via messages, you should remember
that the change is <strong>not</strong> immediate. The change will be applied on <code>ui.poll_message(..)</code> call somewhere in your
code (or will be done automatically if you're using scripts or Framework (obsolete)).</p>
<h2 id="shortcuts"><a class="header" href="#shortcuts">Shortcuts</a></h2>
<p>There are number of default shortcuts that can be used to speed up text editing:</p>
<ul>
<li><code>Ctrl+A</code> - select all</li>
<li><code>Ctrl+C</code> - copy selected text</li>
<li><code>Ctrl+V</code> - paste text from clipboard</li>
<li><code>Ctrl+Home</code> - move caret to the beginning of the text</li>
<li><code>Ctrl+End</code> - move caret to the beginning of the text</li>
<li><code>Shift+Home</code> - select everything from current caret position until the beginning of current line</li>
<li><code>Shift+End</code> - select everything from current caret position until the end of current line</li>
<li><code>Arrows</code> - move caret accordingly</li>
<li><code>Delete</code> - deletes next character</li>
<li><code>Backspace</code> - deletes previous character</li>
<li><code>Enter</code> - new line (if multiline mode is set) or <code>commit</code> message</li>
</ul>
<h2 id="multiline-text-box"><a class="header" href="#multiline-text-box">Multiline Text Box</a></h2>
<p>By default, text box will not add new line character to the text if you press <code>Enter</code> on keyboard. To enable this
functionality use <code>.with_multiline(true)</code></p>
<h2 id="read-only-mode"><a class="header" href="#read-only-mode">Read-only Mode</a></h2>
<p>You can enable or disable content editing by using read-only mode. Use <code>.with_readonly</code> at build stage.</p>
<h2 id="mask-character"><a class="header" href="#mask-character">Mask Character</a></h2>
<p>You can specify replacement character for every other characters, this is useful option for password fields. Use
<code>.with_mask_char</code> at build stage. For example, you can set replacement character to asterisk <code>*</code> using
<code>.with_mask_char(Some('*'))</code></p>
<h2 id="receiving-text-changes"><a class="header" href="#receiving-text-changes">Receiving Text Changes</a></h2>
<p>TextBox uses <code>TextMessage::Text</code> message to send the new text to a user. To get a text from text box you need to
listen to this message:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_ui_message(my_text_box: Handle&lt;UiNode&gt;, message: &amp;UiMessage) {
    if let Some(TextMessage::Text(text)) = message.data() {
        if message.destination() == my_text_box {
            println!("The text is: {}", text)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="text-commit-mode"><a class="header" href="#text-commit-mode">Text Commit Mode</a></h3>
<p>In many situations you don't need the text box to send <code>new text</code> message every new character, you either want this
message if <code>Enter</code> key is pressed or TextBox has lost keyboard focus (or both). There is <code>with_text_commit_mode</code> on
builder specifically for that purpose. Use one of the following modes:</p>
<ul>
<li><code>TextCommitMode::Immediate</code> - text box will immediately send <code>Text</code> message after any change.</li>
<li><code>TextCommitMode::LostFocus</code> - text box will send <code>Text</code> message only when it loses focus.</li>
<li><code>TextCommitMode::LostFocusPlusEnter</code> - text box will send <code>Text</code> message when it loses focus or if Enter key was
pressed. This is <strong>default</strong> behavior. In case of multiline text box hitting Enter key won't commit text!</li>
</ul>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>It is possible specify custom input filter, it can be useful if you're creating special input fields like numerical or
phone number. A filter can be specified at build stage like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_text_box_with_filter(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        // Specify a filter that will pass only digits.
        .with_filter(Arc::new(Mutex::new(|c: char| c.is_ascii_digit())))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>You can change brush of caret by using <code>.with_caret_brush</code> and also selection brush by using <code>.with_selection_brush</code>,
it could be useful if you don't like default colors.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ui/text.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../ui/tree.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ui/text.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../ui/tree.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
