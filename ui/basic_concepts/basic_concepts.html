<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Basic concepts - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/ui/basic_concepts/basic_concepts.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic concepts</a></h1>
<p>This chapter should help you understand basic concepts lying in the foundation of the GUI in the engine.</p>
<h2 id="stateful"><a class="header" href="#stateful">Stateful</a></h2>
<p>Stateful UI means that we can create and destroy widgets when we need to, it is the opposite approach of
immediate-mode or stateless UIs when you don't have long-lasting state for your widgets
(usually stateless UI hold its state only for one or two frames).</p>
<p>Stateful UI is much more powerful and flexible, it allows you to have complex layout system without having to
create hacks to create complex layout as you'd do in immediate-mode UIs. It is also much faster in terms of
performance.</p>
<p>Stateful UI is a must for complex user interfaces that requires rich layout and high performance. I'm not telling
that you <em>can't</em> do it in immediate mode UI, you can, but using tons of hacks. See <a href="#layout">Layout</a> section for
more info.</p>
<h2 id="model-view-controller"><a class="header" href="#model-view-controller">Model-View-Controller</a></h2>
<p>The UI system is designed to be used in a classic model-view-controller MVC approach. Model in this case is your game
state, view is the UI system, controller is your event handlers. In other words - the UI shows what happens in your game
and does not store any game-related information. This is quite old, yet powerful mechanism that decouples UI code from
game code very efficiently and allows you to change game code and UI code independently.</p>
<h2 id="node-based-architecture"><a class="header" href="#node-based-architecture">Node-based architecture</a></h2>
<p>Every user interface could be represented as a set of small blocks that have hierarchical bonding between each
other. For example a button could be represented using two parts: a background and a foreground. Usually the background
is just a simple rectangle (either a vector or bitmap), and a foreground is a text. The text (the foreground widget)
is a child object of the rectangle (the background widget). These two widgets forms another, more complex widget that
we call button. Graphically it will look like this:</p>
<p><img src="./button.svg" alt="Button" /></p>
<p>On the right side of the image we can see the generic button and on the left side, we can see its hierarchical
structure. Such approach allows us to modify the look of the button as we wish, we can create a button with
image background, or with any vector image, or even other widgets. The foreground can be anything too, it can also
contain its own complex hierarchy, like a pair of an icon with a text and so on.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Every widget in the engine uses composition to build more complex widgets. All widgets (and respective builders) contains
<code>Widget</code> instance inside, it provides basic functionality the widget such as layout information, hierarchy, default
foreground and background brushes (their usage depends on derived widget), render and layout transform and so on.</p>
<h2 id="component-querying"><a class="header" href="#component-querying">Component Querying</a></h2>
<p>Many widgets provide component querying functionality - you can get an immutable reference to inner component by its type. It is
used instead of type casting in many places. Component querying is much more flexible compared to direct type casting.
For example, you may want to build a custom <a href="../tree.html">Tree</a> widget, you want your CustomTree to inherit all the
functionality from the Tree, but add something new. The Tree widget can manage its children subtrees, but it needs to
somehow get required data from subtree. Direct type casting would fail in this case, because now you have something
like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::tree::Tree;
</span>struct CustomTree {
    tree: Tree,
    my_data: u32
}
<span class="boring">}</span></code></pre></pre>
<p>On other hand, component querying will work fine, because you can query inner component (Tree in our case). Please note
that this has nothing similar with ECS and stuff, it is made to circumvent Rust's lack of inheritance.</p>
<h2 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h2>
<p>The engine uses message passing mechanism for any UI logic. What does that mean? Let's see at the button from the
previous section and imagine we want to change its text. To do that we need to explicitly "tell" the button's text
widget to change its content to something new. This is done by sending a message to the widget.</p>
<p>There is no classic callbacks to handle various types of messages, which may come from widgets. Instead, you should write
your own message dispatcher where you'll handle all messages. Why so? At first - decoupling, in this case business logic
is decoupled from the UI. You just receive messages one-by-one and do specific logic. The next reason is that any
callback would require context capturing which could be somewhat restrictive - since you need to share context with the
UI, it would force you to wrap it in <code>Rc&lt;RefCell&lt;..&gt;&gt;</code>/<code>Arc&lt;Mutex&lt;..&gt;&gt;</code>.</p>
<p>Message dispatcher is very easy to write, all you need to do is to handle UI messages in <code>Plugin::on_ui_message</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Debug)]
struct MyPlugin {
    button: Handle&lt;UiNode&gt;,
}

impl Plugin for MyPlugin {
    fn on_ui_message(&amp;mut self, _context: &amp;mut PluginContext, message: &amp;UiMessage) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.button {
                println!("The button was clicked!");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, all you need to do is to check type of incoming message and message destination, which is a node handle
from which a message was come from. Then you do any actions you want.</p>
<h3 id="message-routing-strategies"><a class="header" href="#message-routing-strategies">Message routing strategies</a></h3>
<p>Message passing mechanism works in pair with various routing strategies that allows you to define how the message
will "travel" across the tree of nodes.</p>
<ol>
<li>Bubble - a message starts its way from a widget and goes up on hierarchy until it reaches root node of hierarchy.
Nodes that lies outside that path won't receive the message. This is the most important message routing strategy, that
is used for <strong>every</strong> node by default.</li>
<li>Direct - a message passed directly to every node that are capable to handle it. There is actual routing in this
case. Direct routing is used in rare cases when you need to catch a message outside its normal "bubble" route.</li>
</ol>
<p>Bubble message routing is used to handle complex hierarchies of widgets with ease. Let's take a look at the button
example above - it has text widget as a content and when, for instance, you hover a mouse over the text widget the UI
system creates a "mouse moved" message and sends it to the text. Once it was processed by the text, it "floats" one
level of hierarchy up - to the button widget itself. This way the button widget can process mouse events as well.</p>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>The UI systems uses complex, yet powerful layout system that allows you to build complex user interfaces with
complex layout. Layout pass has two <em>recursive</em> sub-passes:</p>
<ol>
<li>Measurement - the sub-pass is used to fetch the desired size of each widget in hierarchy. Each widget in the hierarchy
"asked" for its desired size with the constraint from a parent widget. This step is recursive - to know a desired size
of a widget root of some hierarchy you need to recursively fetch the desired sizes of every descendant.</li>
<li>Arrangement - the sub-pass is used to set final position and size of each widget in hierarchy. It uses desired size
of every widget from the previous step to set the final size and relative position. This step is recursive.</li>
</ol>
<p>Such separation in two passes is required because we need to know desired size of each node in hierarchy before we can
actually do an arrangement.</p>
<h2 id="code-first-and-editor-first-approaches"><a class="header" href="#code-first-and-editor-first-approaches">Code-first and Editor-first approaches</a></h2>
<p>The UI system supports both ways of making a UI:</p>
<ol>
<li>Code-first approach is used when your user interface is procedural and its appearance is heavily depends on
your game logic. In this case you need to use various widget builder to create UIs.</li>
<li>Editor-first approach is used when you have relatively static (animations does not count) user interface,
that almost does not change in time. In this case you can use built-in WYSIWYG (what-you-see-is-what-you-get)
editor. See <a href="../editor/editor.html">Editor</a> chapter for more info.</li>
</ol>
<p>In case of code-first approach you should prefer so-called <em>fluent syntax</em>: this means that you can create your
widget in series of nested call of other widget builders. In code, it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fancy_button(
    ui: &amp;mut UserInterface,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();
    ButtonBuilder::new(WidgetBuilder::new())
        .with_back(
            ImageBuilder::new(WidgetBuilder::new())
                .with_texture(resource_manager.request::&lt;Texture&gt;("path/to/your/texture"))
                .build(ctx),
        )
        .with_text("Click me!")
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>This code snippet creates a button with an image and a text. Actually it creates <strong>three</strong> widgets, that forms
complex hierarchy. The topmost widget in hierarchy is the <code>Button</code> widget itself, it has two children widgets:
background image and a text. Background image is set explicitly by calling image widget builder with specific
texture. The text is created implicitly, the button builder creates <code>Text</code> widget for you and attaches it to
the button. The structure of the button can contain <em>any</em> number of nodes, for example you can create a button
that contains text with some icon. To do that, replace <code>.with_text("My Button")</code> with this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fancy_button_with_text(
    ui: &amp;mut UserInterface,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    ButtonBuilder::new(WidgetBuilder::new())
        .with_content(
            GridBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ImageBuilder::new(WidgetBuilder::new().on_column(0))
                            .with_texture(resource_manager.request::&lt;Texture&gt;("your_icon"))
                            .build(ctx),
                    )
                    .with_child(
                        TextBuilder::new(WidgetBuilder::new().on_column(1))
                            .with_text("My Button")
                            .build(ctx),
                    ),
            )
            .add_row(Row::stretch())
            .add_column(Column::auto())
            .add_column(Column::stretch())
            .build(ctx),
        )
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Quite often you need to store a handle to a widget in a variable, there is one neat trick to do that preserving
the fluent syntax:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fancy_button_with_shortcut(
    ui: &amp;mut UserInterface,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();
    let image;
    ButtonBuilder::new(WidgetBuilder::new())
        .with_back({
            image = ImageBuilder::new(WidgetBuilder::new())
                .with_texture(resource_manager.request::&lt;Texture&gt;("path/to/your/texture"))
                .build(ctx);
            image
        })
        .with_text("Click me!")
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>UI system uses completely different kind of scenes - UI scenes, which are fully decoupled from game scenes. This means
that you can't incorporate UI widgets in a game scene. As a consequence, you don't have an ability to attach scripts to
widgets - their logic is strictly defined in their backing code. This limitation is intentional, and it is here
only for one reason - decoupling of UI code from game logic. Currently, there's only one right approach to make UIs -
to create widgets in your game plugin and sync the state of the widgets with game entities manually.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ui/ui.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../ui/editor/editor.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ui/ui.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../ui/editor/editor.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
