<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Borrow Checker - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/beginning/borrow_checker.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow Checker</a></h1>
<p>Rust has a <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">famous borrow checker</a>, which has become a
sort of horror story for newcomers. It is often treated like an enemy that prevents you from writing anything
useful in the ways you may be used to in other languages. In fact, it is a very useful part of Rust that proves correctness
of your program and prevents you from doing nasty things like memory corruption, data races, etc. This chapter
explains how Fyrox solves the most common borrowing issues and makes game development as easy as in any other
game engine.</p>
<h2 id="multiple-borrowing"><a class="header" href="#multiple-borrowing">Multiple Borrowing</a></h2>
<p>When writing a script logic there is often a need to do a multiple borrowing of some data, usually it is other scene
nodes. In normal circumstances you can borrow each node one-by-one, but in other cases you can't do an action
without borrowing two or more nodes simultaneously. In this case you can use multi-borrowing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct MyScript {
    some_node: Handle&lt;Node&gt;,
    some_other_node: Handle&lt;Node&gt;,
    yet_another_node: Handle&lt;Node&gt;,
}

impl ScriptTrait for MyScript {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Begin multiple borrowing.
        let mbc = ctx.scene.graph.begin_multi_borrow();

        // Borrow immutably.
        let some_node_ref_1 = mbc.try_get(self.some_node).unwrap();

        // Then borrow other nodes mutably.
        let some_other_node_ref = mbc.try_get_mut(self.some_other_node).unwrap();
        let yet_another_node_ref = mbc.try_get_mut(self.yet_another_node).unwrap();

        // We can borrow the same node immutably pretty much infinite number of times, if it wasn't
        // borrowed mutably.
        let some_node_ref_2 = mbc.try_get(self.some_node).unwrap();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, you can borrow multiple nodes at once with no compilation errors. Borrowing rules in this case
are enforced at runtime. They're the same as standard Rust borrowing rules:</p>
<ol>
<li>You can have infinite number of immutable references to the same object.</li>
<li>You can have only one mutable reference to the same object.</li>
</ol>
<p>Multi-borrow context provides detailed error messages for cases when borrowing has failed. For example, it will
tell you if you're trying to mutably borrow an object that is already borrowed as immutable (and vice versa).
It also provides handle validation and will tell you what's wrong with it. It could be either an invalid index
or generation. The latter means that the object at the handle was changed and therefore the handle is invalid.</p>
<p>The previous example looks kinda synthetic and does not show the real-world code that could lead to borrowing
issues. Let's fix this. Imagine that you're making a shooter, and that you have bots that can follow and attack
targets. Then the code could look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Bot {
    target: Handle&lt;Node&gt;,
    absm: Handle&lt;Node&gt;,
}

impl ScriptTrait for Bot {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Begin multiple borrowing.
        let mbc = ctx.scene.graph.begin_multi_borrow();

        // At first, borrow a node on which this script is running on.
        let this = mbc.get_mut(ctx.handle);

        // Try to borrow the target. It can fail in two cases:
        // 1) `self.target` is invalid or unassigned handle.
        // 2) A node is already borrowed, this could only happen if the bot have itself as the target.
        match mbc.try_get_mut(self.target) {
            Ok(target) =&gt; {
                // Check if we are close enough to target.
                let close_enough = target
                    .global_position()
                    .metric_distance(&amp;this.global_position())
                    &lt; 1.0;

                // Switch animations accordingly.
                let mut absm = mbc
                    .try_get_component_of_type_mut::&lt;AnimationBlendingStateMachine&gt;(self.absm)
                    .unwrap();
                absm.machine_mut()
                    .get_value_mut_silent()
                    .set_parameter("Attack", Parameter::Rule(close_enough));
            }
            Err(err) =&gt; {
                // Optionally, you can print the actual reason why borrowing wasn't successful.
                Log::err(err.to_string())
            }
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, for this code to compile we need to borrow at least two nodes simultaneously: the node with <code>Bot</code>
script and the <code>target</code> node. This is because we're calculating distance between the two nodes to switch
animations accordingly (attack if the target is close enough).</p>
<p>As with pretty much any approach, this one is not ideal and comes with its own pros and cons. The pros are quite
simple:</p>
<ul>
<li>No compilation errors - sometimes Rust is too strict about borrowing rules, and valid code does not pass its
checks.</li>
<li>Better ergonomics - no need to juggle with temporary variable here and there to perform an action.</li>
</ul>
<p>The cons are:</p>
<ul>
<li>Multi-borrowing is slightly slower (~1-4% depending on your use case) - this happens because the
multi-borrowing context checks borrowing rules at runtime.</li>
</ul>
<h2 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h2>
<p>Sometimes the code becomes so convoluted that it is hard to maintain and understand what it is doing.
This happens when code coupling gets to a certain point, which requires very broad context for the code to
be executed. For example, if bots in your game have weapons it is so tempting to just borrow the weapon
and call something like <code>weapon.shoot(..)</code>. When your weapon is simple then it might work fine. However, when
your game gets bigger and weapons get new features, a simple <code>weapon.shoot(..)</code> might be not enough. It could be
because the <code>shoot</code> method gets more and more arguments or some other reason. This is quite common. In
general, when your code becomes tightly coupled it becomes hard to maintain it, and, more importantly, can
easily result in issues with the borrow checker. To illustrate this, let's look at
this code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Weapon {
    bullets: u32,
}

impl Weapon {
    fn shoot(&amp;mut self, self_handle: Handle&lt;Node&gt;, graph: &amp;mut Graph) {
        if self.bullets &gt; 0 {
            let this = &amp;graph[self_handle];
            let position = this.global_position();
            let direction = this.look_vector().scale(10.0);

            // Cast a ray in front of the weapon.
            let mut results = Vec::new();
            graph.physics.cast_ray(
                RayCastOptions {
                    ray_origin: position.into(),
                    ray_direction: direction,
                    max_len: 10.0,
                    groups: Default::default(),
                    sort_results: false,
                },
                &amp;mut results,
            );

            // Try to damage all the bots that were hit by the ray.
            for result in results {
                for node in graph.linear_iter_mut() {
                    if let Some(bot) = node.try_get_script_mut::&lt;Bot&gt;() {
                        if bot.collider == result.collider {
                            bot.health -= 10.0;
                        }
                    }
                }
            }

            self.bullets -= 1;
        }
    }
}

impl ScriptTrait for Weapon {}

#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Bot {
    weapon: Handle&lt;Node&gt;,
    collider: Handle&lt;Node&gt;,
    health: f32,
}

impl ScriptTrait for Bot {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Try to shoot the weapon.
        if let Some(weapon) = ctx
            .scene
            .graph
            .try_get_script_component_of_mut::&lt;Weapon&gt;(self.weapon)
        {
            // !!! This will not compile, because it requires mutable access to the weapon and to
            // the script context at the same time. This is impossible to do safely, because we've
            // just borrowed the weapon from the context.

            // weapon.shoot(ctx.handle, &amp;mut ctx.scene.graph);
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>This is probably one of the typical implementations of shooting in games - you cast a ray from the weapon
and if it hits a bot, you apply some damage to it. In this case bots can also shoot, and this is where
borrow checker again gets in our way. If you try to uncomment the
<code>// weapon.shoot(ctx.handle, &amp;mut ctx.scene.graph);</code> line, you'll get a compilation error that tells you that
<code>ctx.scene.graph</code> is already borrowed. It seems like we are stuck, and we need to somehow fix this issue.
We can't use multi-borrowing in this case, because it still enforces borrowing rules and instead of compilation
error, you'll runtime error.</p>
<p>To solve this, you can use the well-known message passing mechanism. The core idea is to not call methods
immediately, but to collect all the needed data for the call and send it an object, so it can do the call later.
Here's how it will look:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Weapon {
    bullets: u32,
}

impl Weapon {
    fn shoot(&amp;mut self, self_handle: Handle&lt;Node&gt;, graph: &amp;mut Graph) {
        // -- This method is the same
    }
}

#[derive(Debug)]
pub struct ShootMessage;

impl ScriptTrait for Weapon {
    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Subscribe to shooting message.
        ctx.message_dispatcher
            .subscribe_to::&lt;ShootMessage&gt;(ctx.handle);
    }

    fn on_message(
        &amp;mut self,
        message: &amp;mut dyn ScriptMessagePayload,
        ctx: &amp;mut ScriptMessageContext,
    ) {
        // Receive shooting messages.
        if message.downcast_ref::&lt;ShootMessage&gt;().is_some() {
            self.shoot(ctx.handle, &amp;mut ctx.scene.graph);
        }
    }
}

#[derive(Clone, Debug, Reflect, Visit, Default, TypeUuidProvider, ComponentProvider)]
#[type_uuid(id = "a9fb15ad-ab56-4be6-8a06-73e73d8b1f49")]
#[visit(optional)]
struct Bot {
    weapon: Handle&lt;Node&gt;,
    collider: Handle&lt;Node&gt;,
    health: f32,
}

impl ScriptTrait for Bot {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Note, that we know nothing about the weapon here - just its handle and a message that it
        // can accept and process.
        ctx.message_sender.send_to_target(self.weapon, ShootMessage);
    }
}

<span class="boring">}</span></code></pre></pre>
<p>The weapon now subscribes to <code>ShootMessage</code> and listens to it in <code>on_message</code> method and from there it can
perform the actual shooting without any borrowing issues. The bot now just sends the <code>ShootMessage</code> instead of
borrowing the weapon trying to call <code>shoot</code> directly. The messages do not add any one-frame delay as you might
think, they're processed in the same frame so there's no one-or-more frames desynchronization.</p>
<p>This approach with messages has its own pros and cons. The pros are quite significant:</p>
<ul>
<li>Decoupling - coupling is now very loose and done mostly on message side.</li>
<li>Easy to refactor - since the coupling is loose, you can refactor the internals with low chance of breaking
existing code, that could otherwise be done because of intertwined and convoluted code.</li>
<li>No borrowing issues - the method calls are done in different places and thus there are no lifetime collisions.</li>
<li>Easy to write unit and integration tests - this comes from loose coupling.</li>
</ul>
<p>The cons are the following:</p>
<ul>
<li>Message passing is slightly slower than direct method calls (~1-7% depending on your use case) - you should
keep message granularity at a reasonable level. Do not use message passing for tiny changes, as it will most likely make
your game slower.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../beginning/data_management.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../beginning/project_manager.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../beginning/data_management.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../beginning/project_manager.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
