<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Management - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/beginning/data_management.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-management"><a class="header" href="#data-management">Data Management</a></h1>
<p>The engine uses pools to store most objects (scene nodes in a
graph, animations in an animation player, sound sources in an audio context, etc.). Since you'll use them quite often, reading and understanding this chapter is recommended.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Rust ownership system and borrow checker, in particular, dictate the rules of data management. In game development, you
often have the need to reference objects from other objects. In languages like C, this is usually achieved by simply storing a raw
pointer and calling it a day. That works, yet it's remarkably unsafe - you risk either forgetting to destroy an object and leaking
memory or destroying an object still being referenced and then trying to access deallocated memory. Other languages, like C++, allow
you to store <em>shared pointers</em> to your data, which by keeping a reference count, ensures the previous doesn't happen at the cost of
a, most often, negligible overhead. Rust counts with smart pointers similar to this, though not without their limitations. There is the <code>Rc/Arc</code> - they function like <em>shared pointers</em>, except they don't allow mutating their content, only
reading it. If you want mutability, you use either a <code>RefCell</code> for a
single-threaded environment, or a <code>Mutex</code> for a multithreaded environment. That is where the problems begin. For
types such as <code>Rc&lt;RefCell&gt;</code> or <code>Arc&lt;Mutex&gt;</code>, Rust enforces its borrowing rules at runtime, which are unlimited readers but
a single writer. Any attempt to borrow mutably more than once at a time will lead to a runtime error.</p>
<p>Another problem with these shared references is that is very easy to accidentally create cyclical references
that prevent objects from ever being destroyed. While the previous could be lived with, the last problem is especially
severe in the case of games: the overhead of runtime checks. In the case of a <code>Rc&lt;RefCell&gt;</code>, it is a single
reference counter for given accesses to the data, but in the case of a <code>Arc&lt;Mutex&gt;</code>, it is a mutex lock.</p>
<p>The solution to these problems is far from ideal; it certainly has its own downfalls. Instead of scattering objects across memory
and then having to manage the lifetime of each of them through reference counting, we can store all of the objects in a single
and contiguous memory block and then use indices to access each object. Such a structure is called a pool.</p>
<h2 id="technical-details"><a class="header" href="#technical-details">Technical Details</a></h2>
<p>A pool is an efficient method of data management. A pool is a vector with entries that can be either vacant or occupied. Each
entry, regardless of its status, also stores a number called a <em>generation</em> number. This is used
to understand whether an entry has changed over time or not. When an entry is reused, its generation number is
increased, rendering all previously created handles leading to the entry invalid. This is a simple and efficient
algorithm for tracking the lifetime of objects.</p>
<p>To access the data in the entries, the engine uses the previously mentioned <em>handles</em>. A handle is a pair of the index of an entry
and a generation number. When you put an object in the pool, this gives you the handle that leads to the object, as well as the
entry's current generation number. The number remains valid until you "free" the object, which makes the entry vacant again.</p>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<ul>
<li>Since a pool is a contiguous memory block, it is far more CPU cache-friendly. This reduces the occurrences of CPU cache misses, which makes accesses to data blazingly fast.</li>
<li>Almost every entity in Fyrox lives on its own pool, which makes it easy to create data structures
like graphs, where nodes refer to other nodes. In this case, nodes simply need to store a handle to refer to other nodes.</li>
<li>Simple lifetime management. There is no way to leak memory since cross-references can only be done via handles.</li>
<li>Fast random access with a constant complexity.</li>
<li>Handles are the same size as a pointer on a 64-bit architecture, just 8 bytes.</li>
</ul>
<h2 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h2>
<ul>
<li>Pools can contain lots of gaps between currently used memory, which may lead to less efficient memory usage.</li>
<li>Handles are sort of weak references, but worse. Since they do not own any data nor even point to their data, you
need a reference to its pool instance in order to borrow the data a handle leads to.</li>
<li>Handles introduce a level of indirection that can hurt performance in places with high loads that require random
access, though this is not too significant as random access is already somewhat slow because of potential
CPU cache misses.</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>You'll use <code>Handle</code> <em>a lot</em> while working with Fyrox. So where are the main usages of pools and
handles? The largest is in a <a href="../scene/graph.html">scene graph</a>. This stores all the nodes in a pool and gives handles
to each node. Each scene node stores a handle to their parent node and a set of handles to their children nodes. A scene graph
automatically ensures that such handles are valid. In <a href="../scripting/script.html">scripts</a>, you can also store handles
to scene nodes and assign them in the editor.</p>
<p><a href="../animation/animation.html">Animation</a> is another place that stores handles to animated scene nodes.
<a href="../animation/blending.html">Animation Blending State Machine</a> stores its own state graph using a pool; it also takes
handles to animations from an animation player in a scene.</p>
<p>And the list could keep going for a long time. This is why you need to understand the basic concepts of data management, as to
efficiently and fearlessly use Fyrox.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>Once an object is placed in a pool, you have to use its respective handle to get a reference to it. This can
be done with either <code>pool.borrow(handle)</code> or <code>pool.borrow_mut(handle)</code>, or by using the <code>Index</code> trait: <code>pool[handle]</code>. Note that
these methods panic when the handle given is invalid. If you want to be safe, use the <code>try_borrow(handle)</code> or
<code>try_borrow_mut(handle)</code> method.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let obj = pool.borrow_mut(handle);
*obj = 11;

let obj = pool.borrow(handle);
assert_eq!(*obj, 11);
<span class="boring">}</span></code></pre></pre>
<h2 id="freeing"><a class="header" href="#freeing">Freeing</a></h2>
<p>You can extract an object from a pool by calling <code>pool.free(handle)</code>. This will give you the object back and make all current
handles to it invalid.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

pool.free(handle);

let obj = pool.try_borrow(handle);
assert_eq!(obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="take-and-reserve"><a class="header" href="#take-and-reserve">Take and Reserve</a></h2>
<p>Sometimes you may want to temporarily extract an object from a pool, do something with it, and then put it back, yet not want
to break every handle to the object in the process. There are three methods for this:</p>
<ol>
<li><code>take_reserve</code> + <code>try_take_reserve</code> - moves an object out of the pool but leaves the entry in an occupied state. This function returns a tuple with two values <code>(Ticket&lt;T&gt;, T)</code>. The latter one being your object, and the former one being a wrapper over its index that allows you to return the object once you're done with it. This is called a ticket. Note that attempting to borrow a moved object will cause a panic!</li>
<li><code>put_back</code> - moves the object back using the given ticket. The ticket contains information about where in the pool to return the object to.</li>
<li><code>forget_ticket</code> - makes the pool entry vacant again. Useful in cases where you move an object
out of the pool, and then decide you won't return it. If this is the case, you <strong>must</strong> call
this method, otherwise, the corresponding entry will remain unusable.</li>
</ol>
<p>Reservation example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let (ticket, ref mut obj) = pool.take_reserve(handle);

*obj = 123;

// Attempting to fetch while there is an existing reservation, will fail.

let attempt_obj = pool.try_borrow(handle);
assert_eq!(attempt_obj, None);

// Put the object back, allowing borrowing again.

pool.put_back(ticket, *obj);

let obj = pool.borrow(handle);

assert_eq!(obj, &amp;123);
<span class="boring">}</span></code></pre></pre>
<p>Forget example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let (ticket, _obj) = pool.take_reserve(handle);

pool.forget_ticket(ticket);

let obj = pool.try_borrow(handle);

assert_eq!(obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>There are a few possible iterators, each one serving its own purpose:</p>
<ol>
<li><code>iter/iter_mut</code> - creates an iterator over occupied pool entries, returning references to each object.</li>
<li><code>pair_iter/pair_iter_mut</code> - creates an iterator over occupied pool entries, returning tuples of a handle and reference
to each object.</li>
</ol>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let _handle = pool.spawn(1);

let mut iter = pool.iter_mut();

let next_obj = iter.next().unwrap();

assert_eq!(next_obj, &amp;1);

let next_obj = iter.next();

assert_eq!(next_obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="direct-access"><a class="header" href="#direct-access">Direct Access</a></h2>
<p>You have the ability to get an object from a pool using only an index. The methods for that are <code>at</code> and <code>at_mut</code>.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>To check if a handle is valid, you can use the <code>is_valid_handle</code> method.</p>
<h2 id="type-erased-handles"><a class="header" href="#type-erased-handles">Type-erased Handles</a></h2>
<p>The pool module also offers type-erased handles that can be of use in some situations. Still, try to avoid using these, as they may introduce hard-to-reproduce bugs. Type safety is always good :3</p>
<p>A type-erased handle is called an <code>ErasedHandle</code> and can be created either manually or from a strongly-typed handle.
Both handle types are interchangeable; you can use the <code>From</code> and <code>Into</code> traits to convert from one to the other.</p>
<h3 id="getting-a-handle-to-an-object-by-its-reference"><a class="header" href="#getting-a-handle-to-an-object-by-its-reference">Getting a Handle to an Object by its Reference</a></h3>
<p>If you need to get a handle to an object from only having a reference to it, you can use the <code>handle_of</code> method.</p>
<h3 id="iterate-over-and-filter-out-objects"><a class="header" href="#iterate-over-and-filter-out-objects">Iterate Over and Filter Out Objects</a></h3>
<p>The <code>retain</code> method allows you to filter your pool's content using a closure provided by you.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../beginning/assets.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../beginning/borrow_checker.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../beginning/assets.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../beginning/borrow_checker.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
