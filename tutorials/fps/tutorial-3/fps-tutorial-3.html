<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bots and AI - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/tutorials/fps/tutorial-3/fps-tutorial-3.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bots-and-ai"><a class="header" href="#bots-and-ai">Bots and AI</a></h1>
<p>In the <a href="../tutorial-2/fps-tutorial-2.html">previous</a> we've added weapons and projectiles, but we still do not have
anything to shoot at. In this tutorial part we'll add bots with simple AI:</p>
<p><img src="bot.gif" alt="bot" /></p>
<h2 id="bot-prefab"><a class="header" href="#bot-prefab">Bot Prefab</a></h2>
<p>Let's start by zombie 3D model and animations for it, grab it from <a href="zombie.zip">here</a> and unpack into
<code>data/models/zombie</code> folder. Open the editor and create <code>zombie.rgs</code> scene. Instantiate a <code>zombie.FBX</code> 3D model
in the scene and make sure it is located at (0, 0, 0) coordinates. Scale it down to have 0.01 scale in both axes.
You should get something like this:</p>
<p><img src="zombie.png" alt="zombie" /></p>
<p>Next thing that we'll add is animations. Create a new Animation Player scene node, open the animation editor
and add three animations (use <a href="../../../animation/anim_editor.html#animation-importing">this chapter</a> to learn how to
do this) - <code>zombie_attack</code>, <code>zombie_idle</code>, <code>zombie_running</code>. You should get something like this:</p>
<p><img src="zombie_animation.png" alt="zombie animation" /></p>
<p>Do not forget to disable looping for <code>zombie_attack</code> animation, otherwise our zombie will attack infinitely.
Also, make sure to set up the root motion for the <code>zombie_running</code> animation, read
<a href="../../../animation/root_motion/root_motion.html">this chapter</a> for more info. Root motion will allow us to get
nice animation of movement, which will also serve as a source velocity for our bot.</p>
<p>You can select each animation from the list and see how it plays by clicking the "Preview" check box at the
toolbar. Animations by their own are not very useful for us, because our bot can be in multiple states in the
game:</p>
<ul>
<li>Idle - when there's no one around and the bot is just standing still; looking for potential targets.</li>
<li>Run - when the bot spotted someone and walks towards it.</li>
<li>Attack - when the bot is close enough to a target and can attack it.</li>
</ul>
<p>We need to somehow manage all these states and do smooth transition between the states. Fyrox has a special
tool for this called <a href="../../../animation/blending.html">animation blending state machine</a> (ABSM). Let's create a new
ABSM scene node and add the three states mentioned above (if you don't know how -
<a href="../../../animation/absm_editor.html">read this chapter</a>):</p>
<p><img src="absm_states.png" alt="absm states" /></p>
<p>Connect them with bidirectional transitions and set transition time for them to 0.3s. Select the Animation Blending
State Machine node and assign <code>Animation Player</code> property in the Inspector.</p>
<p>Now add <code>Play Animation</code> pose node for each of the states (double-click on a state, right-click, Play Animation)
and set an appropriate animation from the list in the inspector. For example, for <code>Idle</code> state it could look
like this:</p>
<p><img src="pose_node.png" alt="pose node" /></p>
<p>Click <code>Preview</code> check box, and you should see the bot with <code>Idle</code> animation playing. Let's add two parameters
that will be used for transitions:</p>
<p><img src="parameters.png" alt="parameters" /></p>
<p>All we need to do now is to thoroughly set these variables in all six transitions. Select the <code>Idle -&gt; Attack</code>
transition and in the Inspector find <code>Condition</code> property and type in <code>Attack</code> parameter name:</p>
<p><img src="attack_transition.png" alt="attack transition" /></p>
<p>For the opposite transition you need to add almost the same, but with additional <code>Not</code> computational node:</p>
<p><img src="attack_rev_transition.png" alt="attack reverse transition" /></p>
<p>Do the same for the rest of four transitions, all six transitions should have these values set:</p>
<ul>
<li><code>Idle -&gt; Attack</code> - Parameter(Attack)</li>
<li><code>Attack -&gt; Idle</code> - Not(Parameter(Attack))</li>
<li><code>Idle -&gt; Run</code> - And(Parameter(Run), Not(Parameter(Attack)))</li>
<li><code>Run -&gt; Idle</code> - Not(Parameter(Run))</li>
<li><code>Run -&gt; Attack</code> - And(Parameter(Run), Parameter(Attack))</li>
<li><code>Attack -&gt; Run</code> - And(Parameter(Run), Not(Parameter(Attack)))</li>
</ul>
<p>Click <code>Preview</code> and click on some parameters, you should see transitions between states.</p>
<p>You may probably notice that there's something off with <code>Attack</code> state, sometimes it enters it in mid-attack
state. This happens because the attack animation could be in arbitrary play time. It could be fixed by adding
a <code>Rewind Animation</code> action when entering <code>Attack</code> state. Select the <code>Attack</code> state, find <code>On Enter Actions</code> in
the Inspector and add a new action by clicking <code>+</code> button, select <code>Rewind Animation</code> and select <code>zombie_attack</code>
from the list.</p>
<p>Great, now we have all animations working, and now we can add a physical capsule for the bot, so it won't fall
through the ground. Replace the root node of the prefab with a Rigid Body, add a capsule collider child node to
it, adjust its size to fully enclose the bot (we did the same in the first tutorial, but for player):</p>
<p><img src="rigid_body.png" alt="rigid body" /></p>
<p>Do not forget to disable rotations for the rigid body (<code>X/Y/Z Rotation Locked</code> properties must be checked) and
disable sleeping for it (uncheck <code>Can Sleep</code>). For now, our prefab is more or less finished. As usual, we need to
write some code, that will drive the bot.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Add a new script using the following command:</p>
<pre><code class="language-shell">fyrox-template script --name=bot
</code></pre>
<p>Add this module to the <code>lib.rs</code> module as we did in the previous tutorials. Register the bot in the <code>register</code>
method like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        context
            .serialization_context
            .script_constructors
            .add::&lt;Bot&gt;("Bot");
<span class="boring">}</span></code></pre></pre>
<p>At first, our bot needs an ability "to see". In games such ability can be represented by a simple frustum with
its top at the head of the bot and the base oriented forward. We can construct such frustum from a pair of
matrices - view and projection. After that the frustum can be used for simple frustum-point intersection check.
We'll check if the player's position intersects with the bot's viewing frustum and if so, the bot will start
chasing the player. On to the code we go, add the following field to the <code>Bot</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[visit(skip)]
    #[reflect(hidden)]
    frustum: Frustum,
<span class="boring">}</span></code></pre></pre>
<p>To construct the frustum, add the following code somewhere in the <code>bot.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update_frustum(
        &amp;mut self,
        position: Vector3&lt;f32&gt;,
        look_vector: Vector3&lt;f32&gt;,
        up_vector: Vector3&lt;f32&gt;,
        max_observing_distance: f32,
    ) {
        // Calculate an average head position.
        let head_pos = position + Vector3::new(0.0, 0.4, 0.0);
        let look_at = head_pos + look_vector;

        // View matrix is constructed using three parameters - observer position, target point,
        // and an up vector (usually it is just (0,1,0) vector).
        let view_matrix =
            Matrix4::look_at_rh(&amp;Point3::from(head_pos), &amp;Point3::from(look_at), &amp;up_vector);

        // Build the perspective projection matrix.
        let projection_matrix = Matrix4::new_perspective(
            // Aspect ratio
            16.0 / 9.0,
            // Field of view of the bot
            90.0f32.to_radians(),
            0.1,
            max_observing_distance,
        );
        self.frustum =
            Frustum::from_view_projection_matrix(projection_matrix * view_matrix).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
<p>We'll call this method every frame to keep the frustum updated with the current location and orientation of
the bot. Add the following code to the <code>on_update</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Some(rigid_body) = ctx.scene.graph.try_get_mut_of_type::&lt;RigidBody&gt;(ctx.handle) {
            let position = rigid_body.global_position();
            let up_vector = rigid_body.up_vector();
            let look_vector = rigid_body.look_vector();

            // Update the viewing frustum.
            self.update_frustum(position, look_vector, up_vector, 20.0);
        }
<span class="boring">}</span></code></pre></pre>
<p>Now we need to check if the player's position intersects with the frustum. Add the following code at the beginning
of <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // Look for targets only if we don't have one.
        if self.target.is_none() {
            for (handle, node) in ctx.scene.graph.pair_iter() {
                if node.has_script::&lt;Player&gt;()
                    &amp;&amp; self.frustum.is_contains_point(node.global_position())
                {
                    self.target = handle;
                    break;
                }
            }
        }

        // A helper flag, that tells the bot that it is close enough to a target for melee
        // attack.
        let close_to_target = ctx
            .scene
            .graph
            .try_get(self.target)
            .map_or(false, |target| {
                target
                    .global_position()
                    .metric_distance(&amp;ctx.scene.graph[ctx.handle].global_position())
                    &lt; 1.25
            });
<span class="boring">}</span></code></pre></pre>
<p>In this code we're iterating over the all available scene nodes and check if a node has <code>Player</code> script and
if the node's position intersects with the bot's frustum. If so, we're remembering this node as a target.
Do not forget to add this code to the <code>Bot</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[visit(skip)]
    #[reflect(hidden)]
    target: Handle&lt;Node&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Now we need to add movement for the bot, we'll use <a href="../../../animation/root_motion/root_motion.html#how-to-use">root motion</a>
for that. Root motion will be extracted from the animation blending state machine we've made earlier. Let's
add this code to the <code>Bot</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    absm: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
    model_root: InheritableVariable&lt;Handle&lt;Node&gt;&gt;,
<span class="boring">}</span></code></pre></pre>
<p>The first field will hold a handle to the ABSM and the second - a handle to the 3D model root. We'll assign
these field later, now we need to add the code that will extract velocity vector for the bot movement and apply
this vector to the rigid body of the bot:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let model_transform = ctx
            .scene
            .graph
            .try_get(*self.model_root)
            .map(|model| model.global_transform())
            .unwrap_or_default();

        let mut velocity = Vector3::default();
        if let Some(state_machine) = ctx
            .scene
            .graph
            .try_get_mut(*self.absm)
            .and_then(|node| node.query_component_mut::&lt;AnimationBlendingStateMachine&gt;())
        {
        }
<span class="boring">}</span></code></pre></pre>
<p>At first, we're getting current world-space transform of the 3D model's root and saving it into a local variable.
Then we're borrowing the ABSM we've made earlier and extracting the root motion offset vector. As a final step
we're scaling it by <code>1.0 / dt</code> factor to convert it to velocity. This final velocity vector needs to be set to
the rigid body of the bot. To do that, add the following code at the end of the last <code>if</code> statement (where
we're borrowing the rigid body):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            let y_vel = rigid_body.lin_vel().y;
            rigid_body.set_lin_vel(Vector3::new(velocity.x, y_vel, velocity.z));
<span class="boring">}</span></code></pre></pre>
<p>Next we need to somehow inform the ABSM about the current state of the bot. Remember that we have two parameters
in the ABSM? We need to set them from the code, it could be done like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            let y_vel = rigid_body.lin_vel().y;
            rigid_body.set_lin_vel(Vector3::new(velocity.x, y_vel, velocity.z));
<span class="boring">}</span></code></pre></pre>
<p>Now it's time to do small adjustments to our prefabs. Open the <code>zombie.rgs</code> prefab and assign the <code>Bot</code>
script to the root node of the prefab, set its properties like so:</p>
<p><img src="bot_properties.png" alt="bot properties" /></p>
<p>Open the <code>scene.rgs</code>, find the <code>zombie.rgs</code> prefab in the asset browser and instantiate it in the scene:</p>
<p><img src="bot_instance.png" alt="bot instance" /></p>
<p>Now you can run the game and walk in front of the bot, it should run, but it runs straight and does not follow
the target (the player). Let's fix that. At first, we need to calculate an angle between a target and the bot.
We'll calculate it using <code>atan2</code> trigonometric function, add the following code somewhere in <code>on_update</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let angle_to_target = ctx.scene.graph.try_get(self.target).map(|target| {
            let self_position = ctx.scene.graph[ctx.handle].global_position();
            let look_dir = target.global_position() - self_position;
            look_dir.x.atan2(look_dir.z)
        });
<span class="boring">}</span></code></pre></pre>
<p>This code calculates a vector between the bot's position and a target, and then calculates an angle in XZ plane,
using <code>atan2(x, z)</code> trigonometric function. Let's use this angle, add the following code the end of the
last <code>if</code> statement (where we're borrowing the rigid body):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            if let Some(angle) = angle_to_target {
                rigid_body
                    .local_transform_mut()
                    .set_rotation(UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), angle));
            }
<span class="boring">}</span></code></pre></pre>
<p>This code is trivial - we're making a rotation quaternion, that rotates the bot around Y axis using the angle
we've calculated.</p>
<p>Run the game and the bot should follow you as long as it sees you:</p>
<p><img src="bot.gif" alt="bot" /></p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial part we've added bots with animation and simple AI. In the next tutorial we'll add an ability to
kill the bots.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../tutorials/fps/tutorial-2/fps-tutorial-2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../tutorials/ui/ui-tutorial.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../tutorials/fps/tutorial-2/fps-tutorial-2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../tutorials/ui/ui-tutorial.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../../ace.js"></script>
        <script src="../../../editor.js"></script>
        <script src="../../../mode-rust.js"></script>
        <script src="../../../theme-dawn.js"></script>
        <script src="../../../theme-tomorrow_night.js"></script>

        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
