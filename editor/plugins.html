<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Plugins - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/editor/plugins.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="editor-plugins"><a class="header" href="#editor-plugins">Editor Plugins</a></h1>
<p><strong>WARNING: This article is not finished</strong></p>
<p>It is possible to extend editor functionality by custom plugins. This chapter will explain how to create one and how
editor plugins interact with the editor itself.</p>
<h2 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h2>
<p>There are few basic concepts that must be known before start writing an editor plugin.</p>
<ol>
<li>MVC - the editor uses classic <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>
(model-view-controller) pattern. This means that the editor always "renders" the actual state of your data model and
its UI is used only to show the data - it does not store anything. Any user change forces the editor to sync the UI
with the new data.</li>
<li>Commands - the editor usually operates on scenes (there could be multiple opened scenes, but only one active) and any
modification of their content <strong>must</strong> be done via <em>commands</em>. <a href="https://en.wikipedia.org/wiki/Command_pattern">Command</a>
is a standard pattern that encapsulates an action. Command pattern is used for undo/redo functionality.</li>
<li>Preview Mode - sometimes there's a need to preview results in the scene itself, for example if you're making an
animation editor plugin of some sort. Any changes to scene nodes done in the preview mode will be discarded after leaving
this mode.</li>
</ol>
<p>Typical update iteration of the editor looks like this: execute scheduled commands, sync the UI with the new state
of the entities, sleep until new commands. If the preview mode is active, the editor will be always active (see
respective section below for more info).</p>
<h2 id="plugin"><a class="header" href="#plugin">Plugin</a></h2>
<p>As an example, we'll create a plugin that will edit a script of a scene node. The script itself will contain a list
of points which forms a line in 3D space. Our plugin will allow to edit position of these points in 3D space using
movement gizmo, like you move scene nodes. Despite the fact that it is possible to edit the points using Inspector,
is much more comfortable to edit them and see where they're directly in the scene previewer. A good tool is the one that
saves time. Our script looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, TypeUuidProvider, ComponentProvider, Reflect, Visit)]
#[type_uuid(id = "69302f1c-f3c7-4853-801c-552c566948d0")]
pub struct MyScript {
    points: Vec&lt;Vector3&lt;f32&gt;&gt;,
}

impl ScriptTrait for MyScript {}
<span class="boring">}</span></code></pre></pre>
<p>All editor plugins must implement <code>EditorPlugin</code> trait, all methods of which are optional. For our purposes we'll use
only a few of them - <code>on_message</code>, <code>on_update</code>, <code>on_sync_to_model</code>. See the API docs for <code>EditorPlugin</code> for more info
about other methods. Typical plugin definition could look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct MyPlugin {
    node_handle: Handle&lt;Node&gt;,
}
impl EditorPlugin for MyPlugin { 
} 
<span class="boring">}</span></code></pre></pre>
<p>Every plugin must be registered in the editor, it could be done from <code>editor</code> crate of your project. Simply add the
following code after editor's initialization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    editor.add_editor_plugin(MyPlugin::default());
<span class="boring">}</span></code></pre></pre>
<p>Our plugin will work with scene nodes that has particular script type, and we need to know a handle of object that is
suitable for editing via our plugin, this is where <code>on_message</code> could be useful:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_message(&amp;mut self, message: &amp;Message, editor: &amp;mut Editor) {
        // Fetch the active scene.
        let Some(entry) = editor.scenes.current_scene_entry_mut() else {
            return;
        };

        let Some(selection) = entry.selection.as_graph() else {
            return;
        };

        // Try to cast it to GameScene, it could also be UiScene for UI scene plugins.
        let Some(game_scene) = entry.controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut editor.engine.scenes[game_scene.scene];

        // When user clicks on some object in scene, the editor produces `SelectionChanged` message
        // which we can catch and check which object was selected.
        if let Message::SelectionChanged { .. } = message {
            for node_handle in selection.nodes().iter() {
                // An object with our script was selected, remember the handle of it in the
                // plugin.
                if scene
                    .graph
                    .try_get_script_of::&lt;MyScript&gt;(*node_handle)
                    .is_some()
                {
                    self.node_handle = *node_handle;

                    break;
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>It is quite verbose, but in general it is very straightforward. We're fetching the active scene first, then checking
selection type of to be graph selection (there are a number of selection types), then checking that the scene is
game scene (there's also <code>UiScene</code>). All that is left to do is to iterate over selected scene nodes and check if
one of them has our script. Once node selection is done, we can write our own interaction mode to</p>
<h2 id="interaction-modes-and-visualization"><a class="header" href="#interaction-modes-and-visualization">Interaction Modes and Visualization</a></h2>
<p>We need a way to show the points of the line in the scene previewer. The editor uses standard scene nodes for this, and
they all live under a "secret" root node (it is hidden in World Viewer, that's why you can't see it there). The good
approach for visualization is just a custom structure with a few methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct LinePointsGizmo {
    point_nodes: Vec&lt;Handle&lt;Node&gt;&gt;,
}

impl LinePointsGizmo {
    fn sync_to_model(
        &amp;mut self,
        node_handle: Handle&lt;Node&gt;,
        game_scene: &amp;GameScene,
        graph: &amp;mut Graph,
    ) {
        let Some(script) = graph.try_get_script_of::&lt;MyScript&gt;(node_handle) else {
            return;
        };
        let points = script.points.clone();

        if self.point_nodes.len() != points.len() {
            self.remove_points(graph);
            for point in points {
                // Point could be represented via sprite - it will always be facing towards editor's
                // camera.
                let point_node = SpriteBuilder::new(BaseBuilder::new())
                    .with_size(0.1)
                    .build(graph);

                self.point_nodes.push(point_node);

                // Link the sprite with the special scene node - the name of it should clearly state
                // its purpose.
                graph.link_nodes(point_node, game_scene.editor_objects_root);
            }
        }
    }

    fn remove_points(&amp;mut self, graph: &amp;mut Graph) {
        for handle in self.point_nodes.drain(..) {
            graph.remove_node(handle);
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p><code>sync_to_model</code> method can be called on every frame in <code>update</code> method of the interaction mode (see below) - it tracks
the number of scene nodes representing points of the line and if there's mismatch, it recreates the entire set.
<code>remove_points</code> should be used when the gizmo is about to be deleted (usually together with the interaction mode).</p>
<p>All interaction with scene nodes should be performed using interaction modes. Interaction mode is a tiny abstraction layer,
that re-routes input from the scene previewer to the modes. We'll create our own interaction mode that will allow
us to move points of the line. Every interaction mode must implement <code>InteractionMode</code>
<a href="https://docs.rs/fyroxed_base/latest/fyroxed_base/interaction/trait.InteractionMode.html">trait</a>. Unfortunately, the
editor's still mostly undocumented, due to its unstable API. There are quite a lot of methods in this trait:</p>
<ul>
<li><code>on_left_mouse_button_down</code> - called when left mouse button was pressed in the scene viewer.</li>
<li><code>on_left_mouse_button_up</code> - called when left mouse button was released in the scene viewer.</li>
<li><code>on_mouse_move</code> - called when mouse cursor moves in the scene viewer.</li>
<li><code>update</code> - called every frame (only for active mode, inactive modes does are not updated).</li>
<li><code>activate</code> - called when an interaction mode became active.</li>
<li><code>deactivate</code> - called when an interaction mode became inactive (i.e. when you're switched to another mode).</li>
<li><code>on_key_down</code> - called when a key was pressed.</li>
<li><code>on_key_up</code> - called when a key was released.</li>
<li><code>handle_ui_message</code> - called when the editor receives a UI message</li>
<li><code>on_drop</code> - called on every interaction mode before the current scene is destroyed.</li>
<li><code>on_hot_key_pressed</code> - called when a hotkey was pressed. Could be used to switch sub-modes of interaction mode.
For example, tile map editor has single interaction mode, but the mode itself has draw/erase/pick/etc. sub modes which
could be switched using <code>Ctrl</code>/<code>Alt</code>/etc. hotkeys.</li>
<li><code>on_hot_key_released</code> - called when a hotkey was released.</li>
<li><code>make_button</code> - used to create a button, that will be placed.</li>
<li><code>uuid</code> - must return type UUID of the mode.</li>
</ul>
<p>Every method has its particular use case, but we'll use only a handful of them. Let's create a new interaction mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DragContext {
    point_index: usize,
    initial_position: Vector3&lt;f32&gt;,
    plane_kind: PlaneKind,
}

#[derive(TypeUuidProvider)]
#[type_uuid(id = "d7f56947-a106-408a-9c18-d0191ef89925")]
pub struct MyInteractionMode {
    move_gizmo: MoveGizmo,
    node_handle: Handle&lt;Node&gt;,
    drag_context: Option&lt;DragContext&gt;,
    message_sender: MessageSender,
    line_points_gizmo: LinePointsGizmo,
    selected_point_index: Option&lt;usize&gt;,
}

impl MyInteractionMode {
    pub fn new(
        game_scene: &amp;GameScene,
        engine: &amp;mut Engine,
        message_sender: MessageSender,
        node_handle: Handle&lt;Node&gt;,
    ) -&gt; Self {
        Self {
            move_gizmo: MoveGizmo::new(game_scene, engine),
            node_handle,
            drag_context: None,
            message_sender,
            line_points_gizmo: LinePointsGizmo::default(),
            selected_point_index: None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To create an interaction mode all that is needed is to add the following lines in <code>on_message</code>, right after
<code>self.node_handle = *node_handle;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>                    entry.interaction_modes.add(MyInteractionMode::new(
                        game_scene,
                        &amp;mut editor.engine,
                        editor.message_sender.clone(),
                        *node_handle,
                    ));
<span class="boring">}</span></code></pre></pre>
<p>The mode must be deleted when we deselect something else, it could be done on <code>Message::SelectionChanged</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if let Message::SelectionChanged { .. } = message {

            if let Some(mode) = entry.interaction_modes.remove_typed::&lt;MyInteractionMode&gt;() {
                mode.move_gizmo.destroy(&amp;mut scene.graph);
            }
<span class="boring">}</span></code></pre></pre>
<p>Now onto the <code>InteractionMode</code> trait implementation, let's start by adding implementation for <code>make_button</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn make_button(&amp;mut self, ctx: &amp;mut BuildContext, selected: bool) -&gt; Handle&lt;UiNode&gt; {
        make_interaction_mode_button(ctx, include_bytes!("icon.png"), "Line Edit Mode", selected)
    }
<span class="boring">}</span></code></pre></pre>
<p>There's nothing special about it - it uses built-in function, that creates a button with an image and a tooltip. You
could use any UI widget here that sends <code>ButtonMessage::Click</code> messages on interaction. Now onto the <code>on_left_mouse_button_down</code>
method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_left_mouse_button_down(
        &amp;mut self,
        editor_selection: &amp;Selection,
        controller: &amp;mut dyn SceneController,
        engine: &amp;mut Engine,
        mouse_pos: Vector2&lt;f32&gt;,
        frame_size: Vector2&lt;f32&gt;,
        settings: &amp;Settings,
    ) {
        let Some(game_scene) = controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut engine.scenes[game_scene.scene];

        // Pick scene entity at the cursor position.
        if let Some(result) = game_scene.camera_controller.pick(
            &amp;scene.graph,
            PickingOptions {
                cursor_pos: mouse_pos,
                editor_only: true,
                filter: Some(&amp;mut |handle, _| handle != self.move_gizmo.origin),
                ..Default::default()
            },
        ) {
            // The gizmo needs to be fed with input events as well, so it can react to the cursor.
            if let Some(plane_kind) = self.move_gizmo.handle_pick(result.node, &amp;mut scene.graph) {
                // Start point dragging if there's any point selected.
                if let Some(selected_point_index) = self.selected_point_index {
                    self.drag_context = Some(DragContext {
                        point_index: selected_point_index,
                        initial_position: scene.graph
                            [self.line_points_gizmo.point_nodes[selected_point_index]]
                            .global_position(),
                        plane_kind,
                    })
                }
            } else {
                // Handle point picking and remember a selected point.
                for (index, point_handle) in self.line_points_gizmo.point_nodes.iter().enumerate() {
                    if result.node == *point_handle {
                        self.selected_point_index = Some(index);
                    }
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>It is responsible for two things: it handles picking of scene nodes at the cursor position, and it is also changes
currently selected point. Additionally, it creates dragging context if one of the axes of the movement gizmo was clicked
and there's some point selected.</p>
<p>When there's something to drag, we must use new mouse position to determine new location for points in 3D space. There's
<code>on_mouse_move</code> for that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_mouse_move(
        &amp;mut self,
        mouse_offset: Vector2&lt;f32&gt;,
        mouse_position: Vector2&lt;f32&gt;,
        editor_selection: &amp;Selection,
        controller: &amp;mut dyn SceneController,
        engine: &amp;mut Engine,
        frame_size: Vector2&lt;f32&gt;,
        settings: &amp;Settings,
    ) {
        let Some(game_scene) = controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut engine.scenes[game_scene.scene];

        if let Some(drag_context) = self.drag_context.as_ref() {
            let global_offset = self.move_gizmo.calculate_offset(
                &amp;scene.graph,
                game_scene.camera_controller.camera,
                mouse_offset,
                mouse_position,
                frame_size,
                drag_context.plane_kind,
            );

            if let Some(script) = scene
                .graph
                .try_get_script_of_mut::&lt;MyScript&gt;(self.node_handle)
            {
                script.points[drag_context.point_index] =
                    drag_context.initial_position + global_offset;
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>The dragging could be finished simply by releasing the left mouse button:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn on_left_mouse_button_up(
        &amp;mut self,
        editor_selection: &amp;Selection,
        controller: &amp;mut dyn SceneController,
        engine: &amp;mut Engine,
        mouse_pos: Vector2&lt;f32&gt;,
        frame_size: Vector2&lt;f32&gt;,
        settings: &amp;Settings,
    ) {
        let Some(game_scene) = controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut engine.scenes[game_scene.scene];

        if let Some(drag_context) = self.drag_context.take() {
            if let Some(script) = scene
                .graph
                .try_get_script_of_mut::&lt;MyScript&gt;(self.node_handle)
            {
                // Restore the position of the point and use its new position as the value for
                // the command below.
                let new_position = std::mem::replace(
                    &amp;mut script.points[drag_context.point_index],
                    drag_context.initial_position,
                );

                // Confirm the action by creating respective command.
                self.message_sender.do_command(SetPointPositionCommand {
                    node_handle: self.node_handle,
                    point_index: drag_context.point_index,
                    point_position: new_position,
                });
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This is where the action must be "confirmed" - we're creating a new command and sending it for execution in the
command stack of the current scene. The command used in this method could be defined like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct SetPointPositionCommand {
    node_handle: Handle&lt;Node&gt;,
    point_index: usize,
    point_position: Vector3&lt;f32&gt;,
}

impl SetPointPositionCommand {
    fn swap(&amp;mut self, context: &amp;mut dyn CommandContext) {
        // Get typed version of the context, it could also be UiSceneContext for
        // UI scenes.
        let context = context.get_mut::&lt;GameSceneContext&gt;();
        // Get a reference to the script instance.
        let script = context.scene.graph[self.node_handle]
            .try_get_script_mut::&lt;MyScript&gt;()
            .unwrap();
        // Swap the position of the point with the one stored in the command.
        std::mem::swap(
            &amp;mut script.points[self.point_index],
            &amp;mut self.point_position,
        );
    }
}

impl CommandTrait for SetPointPositionCommand {
    fn name(&amp;mut self, context: &amp;dyn CommandContext) -&gt; String {
        "Set Point Position".to_owned()
    }

    fn execute(&amp;mut self, context: &amp;mut dyn CommandContext) {
        self.swap(context)
    }

    fn revert(&amp;mut self, context: &amp;mut dyn CommandContext) {
        self.swap(context)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See the next section for more info about commands and how they interact with the editor.</p>
<p>The next step is to update the gizmo on each frame:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update(
        &amp;mut self,
        editor_selection: &amp;Selection,
        controller: &amp;mut dyn SceneController,
        engine: &amp;mut Engine,
        settings: &amp;Settings,
    ) {
        let Some(game_scene) = controller.downcast_mut::&lt;GameScene&gt;() else {
            return;
        };

        let scene = &amp;mut engine.scenes[game_scene.scene];

        self.line_points_gizmo
            .sync_to_model(self.node_handle, game_scene, &amp;mut scene.graph);
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>As was mentioned previously, any modification to scene node's content (including scripts) must be done using commands.
Commands encapsulates an "atomic" action, this could be simple property or collection modification or something complex,
that involves heavy calculations and so on. The editor has a command stack that executes incoming commands and saves them
for potential undo. The stack has a top command, when new command is added to the stack, it removes all command prior the
top and makes the new command the top one. Every removed command is finalized (see below).</p>
<p>There are two ways of using commands: use reflection-based command, or use custom command. Reflection-based commands
usually used when you need to set a new value to some property. On the other hand, custom commands could perform complex
actions, that cannot be done using reflection-based command. The previous section contains an example of custom command,
they're quite verbose and require decent amount of boilerplate code.</p>
<h3 id="custom-commands"><a class="header" href="#custom-commands">Custom Commands</a></h3>
<p>Custom commands is the best way to get better understanding of command system and how it works. This section explains
how to create custom commands and how they're executed. Each command must implement <code>Command</code> trait which looks like
this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct ExampleCommand {}

impl CommandTrait for ExampleCommand {
    fn name(&amp;mut self, context: &amp;dyn CommandContext) -&gt; String {
        // This method is called to get a name for the command which it will show
        // in the command stack viewer.
        "Command".to_string()
    }

    fn execute(&amp;mut self, context: &amp;mut dyn CommandContext) {
        // This method is called when the editor executes the command.
    }

    fn revert(&amp;mut self, context: &amp;mut dyn CommandContext) {
        // This method is called when the editor undo the command.
    }

    fn finalize(&amp;mut self, _: &amp;mut dyn CommandContext) {
        // This method is called when the command is about to be destroyed.
        // Its main use case is mark some resources as free when they were previously
        // reserved by `execute` or `revert`. Usually it is for reserved handles in Pool.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This chapter already showed an example of a custom command:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct SetPointPositionCommand {
    node_handle: Handle&lt;Node&gt;,
    point_index: usize,
    point_position: Vector3&lt;f32&gt;,
}

impl SetPointPositionCommand {
    fn swap(&amp;mut self, context: &amp;mut dyn CommandContext) {
        // Get typed version of the context, it could also be UiSceneContext for
        // UI scenes.
        let context = context.get_mut::&lt;GameSceneContext&gt;();
        // Get a reference to the script instance.
        let script = context.scene.graph[self.node_handle]
            .try_get_script_mut::&lt;MyScript&gt;()
            .unwrap();
        // Swap the position of the point with the one stored in the command.
        std::mem::swap(
            &amp;mut script.points[self.point_index],
            &amp;mut self.point_position,
        );
    }
}

impl CommandTrait for SetPointPositionCommand {
    fn name(&amp;mut self, context: &amp;dyn CommandContext) -&gt; String {
        "Set Point Position".to_owned()
    }

    fn execute(&amp;mut self, context: &amp;mut dyn CommandContext) {
        self.swap(context)
    }

    fn revert(&amp;mut self, context: &amp;mut dyn CommandContext) {
        self.swap(context)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The main idea is very simple, <code>execute</code> must do the required change and <code>revert</code> must undo it. There's one special
method that has very limited use, but it cannot be avoided. <code>finalize</code> is used to return reserved resources back to
where they were obtained from. Typically, it is pool handles that can be reserved for further use. If they won't be
returned, pool will have empty unused entries forever.</p>
<h3 id="reflection-based-commands"><a class="header" href="#reflection-based-commands">Reflection-based Commands</a></h3>
<p>There are three main types of reflection-based commands that can be used to manipulate scene objects:</p>
<h4 id="setpropertycommand"><a class="header" href="#setpropertycommand"><code>SetPropertyCommand</code></a></h4>
<p>Sets a new value for a property at the given path. This command cannot change the size of collections (add or remove
items), the next two commands are exactly for this (see next subsections). This is how you could use this command to
change position of a point at index 1:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_point_1(node_handle: Handle&lt;Node&gt;, message_sender: &amp;MessageSender) {
    message_sender.do_command(SetPropertyCommand::new(
        "points[1]".to_string(),
        Box::new(Vector3::new(1.0, 2.0, 3.0)),
        // Entity getter supplies a reference to the base object, which will be used
        // to search on for the property with the specified name.
        move |ctx| {
            ctx.get_mut::&lt;GameSceneContext&gt;()
                .scene
                .graph
                .node_mut(node_handle)
                .try_get_script_mut::&lt;MyScript&gt;()
                .unwrap()
        },
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>The first argument is a path to variable, it could be any "depth" and support enum variants, indices, etc:
<code>foo.bar.baz@Some.collection[123].stuff</code>. Enum variants are marked by <code>@</code> sign. The second argument is a new value for
the property. It could be any object that implements <code>Reflect</code> trait, in our case it is <code>Vector3&lt;f32&gt;</code>. The last argument
is entity getter function. Its purpose is to provide a reference to an object in which the reflection system will search
for the property with the given name.</p>
<h4 id="addcollectionitemcommand"><a class="header" href="#addcollectionitemcommand"><code>AddCollectionItemCommand</code></a></h4>
<p>Adds a new collection item command at the given path. The collection could be anything that implements <code>ReflectList</code>
trait (<code>Vec</code>, <code>ArrayVec</code>, custom types) or <code>ReflectHashMap</code> trait (<code>HashMap</code>, <code>FxHashMap</code>, custom types). Typical usage
is something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_collection_element(node_handle: Handle&lt;Node&gt;, message_sender: &amp;MessageSender) {
    message_sender.do_command(AddCollectionItemCommand::new(
        "points".to_string(),
        Box::new(Vector3::new(1.0, 2.0, 3.0)),
        // Entity getter supplies a reference to the base object, which will be used
        // to search on for the property with the specified name.
        move |ctx| {
            ctx.get_mut::&lt;GameSceneContext&gt;()
                .scene
                .graph
                .node_mut(node_handle)
                .try_get_script_mut::&lt;MyScript&gt;()
                .unwrap()
        },
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>The meaning of each argument is the same as in <code>SetPropertyCommand</code> command.</p>
<h4 id="removecollectionitemcommand"><a class="header" href="#removecollectionitemcommand"><code>RemoveCollectionItemCommand</code></a></h4>
<p>Removes an item from a collection by the given index. The collection could be anything that implements <code>ReflectList</code>
trait (<code>Vec</code>, <code>ArrayVec</code>, custom types) or <code>ReflectHashMap</code> trait (<code>HashMap</code>, <code>FxHashMap</code>, custom types). In case of
hash maps, the index cannot be used reliably, because hash maps do not have an ability to be randomly indexed. To remove
the exact element at the index, you must ensure that <code>hash_map.iter().nth(index)</code> corresponds to the item and only then
use this index in the command. Typical usage is something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_collection_element(node_handle: Handle&lt;Node&gt;, message_sender: &amp;MessageSender) {
    message_sender.do_command(RemoveCollectionItemCommand::new(
        "points".to_string(),
        1,
        // Entity getter supplies a reference to the base object, which will be used
        // to search on for the property with the specified name.
        move |ctx| {
            ctx.get_mut::&lt;GameSceneContext&gt;()
                .scene
                .graph
                .node_mut(node_handle)
                .try_get_script_mut::&lt;MyScript&gt;()
                .unwrap()
        },
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>The first argument in this command a name of the collection property, the second - item index, and the third is the
entity getter. See <code>SetPropertyCommand</code> for more info.</p>
<h2 id="contextual-panels"><a class="header" href="#contextual-panels">Contextual Panels</a></h2>
<p>In some cases you may want to have a panel, that opens when you select a node with the script. This panel could contain
any UI elements. For educational purposes, we'll create a contextual panel that will create a line using two points
and a number of segments.</p>
<p>(TODO)</p>
<h2 id="preview-mode"><a class="header" href="#preview-mode">Preview Mode</a></h2>
<p>Preview mode allows you to see objects in dynamic directly in the scene preview window. It is a special mode of the
editor, where it updates and renders every frame and power-saving mode is disabled. It could be useful to preview
various animations.</p>
<p>(TODO)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../editor/settings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../misc/misc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../editor/settings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../misc/misc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
