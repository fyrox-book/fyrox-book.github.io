<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tile Map - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/scene/tilemap.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tile-map"><a class="header" href="#tile-map">Tile Map</a></h1>
<p>Tile map is a 2D "image", made out of a small blocks called tiles. Tile maps used in 2D games to build game worlds
quickly and easily.</p>
<blockquote>
<p>⚠️ This functionality is available only on nightly version of the engine and will be a part of the next stable release.
If you want to use it, read <a href="../beginning/scripting.html#using-the-latest-engine-version">this chapter</a> to learn how to
switch to the nightly version of the engine.</p>
</blockquote>
<p>An example of a tile map could be something like this:</p>
<p><img src="tile_map.png" alt="tile map" /></p>
<h2 id="how-to-create"><a class="header" href="#how-to-create">How to Create</a></h2>
<p>A tile map comes in two pieces: A <code>TileMap</code> node that can be added to a scene, and a <code>TileSet</code> resource that holds the
data required to render each tile.</p>
<p>Tiles in a tile set are organized into pages. Each page has a position on a 2D grid along with all the other pages in the
tile set, and each page contains another 2D grid where the tiles are arranged. Pages and tiles can be positioned anywhere
on their grids according to whatever organizational principles you please. The chosen position for each tile becomes its
handle, called a <code>TileDefinitionHandle</code>, and this handle is what will be stored in the tile map to determine how to render
the tiles.</p>
<p>Here is an example handle: <code>(0,2):(-3,5)</code>. This handle means that the tile is on the page at coordinates
(0,2) and the tile data is at (-3,5) within that page's grid.</p>
<p>Tile set pages come in multiple varieties depending on what data will be stored in each grid cell of the page.</p>
<ul>
<li>
<p><strong>Atlas:</strong> An atlas page renders all of its tiles using a single shared material that acts as a sprite sheet.
The material starts at the upper-left corner of tile (0,-1) and extends down into negative-y cells and right
into positive-x cells. Any tiles that you add to an atlas page will be rendered with their UV-coordinates based
on their position on the page
relative to the material.</p>
</li>
<li>
<p><strong>Freeform:</strong> A freeform page is a collection of tiles with their own independent materials and UV-coordinate positions.
Unlike an atlas page, the positions of tiles in a freeform page does not matter, but each tile needs to have its
material and UV-coordinates specified manually. Tile UV-coordinates are measured in pixels of the texture, not
from 0.0 to 1.0.</p>
</li>
<li>
<p><strong>Transform:</strong> A transform set page stores handles to tiles on other pages and represents how tiles may be flipped
or rotated. The page is divided into 2x4 sets of cells. Within each set, the left 2x2 cells hold tiles that may be
transformed into each other by 90-degree rotations. The right 2x2 cells represent same tiles horizontally mirrored.
The tile set resource can search its transform pages to convert any handle into the handle of a flipped or rotated
version of the tile.</p>
</li>
<li>
<p><strong>Animation:</strong> An animation page stores handles to tiles on other pages and represents how tiles change their appearance
over time. Each animation on the page is represented by a horizontal sequence of tile handles. Any tile whose handle
is on an animation page becomes an animated tile, and its appearance will cycle from left-to-right along its row
until it comes to an empty cell, then it will will start again from the first non-empty cell to its left.
When tiles animate through an animation page, the tile map data does not actually change over time; only the rendering changes.</p>
<p>If the same handle appears in more than one cell on an animation page, then the animation starts at the first occurrence
of the handle, when reading the page from left-to-right and top-to-bottom, as one would read a book.</p>
</li>
</ul>
<p>Once we have a tile set resource, we can create a tile map node and set its <code>tile_set</code> field to point to our resource.
Then we can fill the tile map node with the handles for whatever tiles we want to render.</p>
<p>As usual, there are two major ways of creating a tile map - via code or via the editor. Code-based approach is ideal for
procedural worlds, while the editor-based approach is good for hand-crafted worlds.</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>The following example creates a simple tile map with two tile types - grass and stone. It creates stone foundation and
lays grass on top of it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_tile_map(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    // Each tile could have its own material, for simplicity it is just a standard 2D material.
    let material = MaterialResource::new_ok(ResourceKind::Embedded, Material::standard_tile());

    // Create a tile set - it is a data source for the tile map. Tile map will reference the tiles
    // stored in the tile set by handles. We'll create two tile types with different colors.
    // In order to create a tile set, we must first create a tile set page.
    let mut tiles = TileGridMap::default();
    // Now we decide where we want our tiles to live on that page by creating TileDefinitionHandles for our tiles.
    // Each tile definition handle has four numbers: the (x,y) of the page, and the (x,y) of the tile within the page.
    let stone_tile = TileDefinitionHandle::new(0, 0, 0, 0);
    let grass_tile = TileDefinitionHandle::new(0, 0, 1, 0);
    // Now we insert tile data for each tile in our new page.
    tiles.insert(
        stone_tile.tile(),
        TileDefinition {
            material_bounds: TileMaterialBounds {
                material: material.clone(),
                bounds: TileBounds {
                    left_top_corner: Vector2::new(0, 0),
                    right_top_corner: Vector2::new(16, 0),
                    left_bottom_corner: Vector2::new(0, 16),
                    right_bottom_corner: Vector2::new(16, 16),
                },
            },
            data: TileData {
                color: Color::BROWN,
                properties: FxHashMap::default(),
                colliders: FxHashMap::default(),
            },
        },
    );
    tiles.insert(
        grass_tile.tile(),
        TileDefinition {
            material_bounds: TileMaterialBounds {
                material: material.clone(),
                bounds: TileBounds {
                    left_top_corner: Vector2::new(0, 0),
                    right_top_corner: Vector2::new(16, 0),
                    left_bottom_corner: Vector2::new(0, 16),
                    right_bottom_corner: Vector2::new(16, 16),
                },
            },
            data: TileData {
                color: Color::GREEN,
                properties: FxHashMap::default(),
                colliders: FxHashMap::default(),
            },
        },
    );
    // Finish creating the page.
    let source = TileSetPageSource::Freeform(tiles);
    let page = TileSetPage {
        // The icon is the handle of a tile that would represent the page in the editor.
        icon: stone_tile,
        // The tiles that we've created.
        source,
    };
    // Finally we create our tile set and add our page to it at position (0,0).
    let mut tile_set = TileSet::default();
    tile_set.insert_page(Vector2::new(0, 0), page);
    let tile_set = TileSetResource::new_ok(ResourceKind::Embedded, tile_set);

    // This positions of all the tiles in our tile map using their TileDefinitionHandle
    // to find the tiles in the tile set.
    let mut tiles = Tiles::default();

    // Create stone foundation.
    for x in 0..10 {
        for y in 0..2 {
            tiles.insert(Vector2::new(x, y), stone_tile);
        }
    }

    // Add grass on top of it.
    for x in 0..10 {
        tiles.insert(Vector2::new(x, 2), grass_tile);
    }

    // Finally create the tile map.
    TileMapBuilder::new(BaseBuilder::new())
        .with_tile_set(tile_set)
        .with_tiles(tiles)
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Please refer to the API docs for more info about each method.</p>
<h3 id="editor"><a class="header" href="#editor">Editor</a></h3>
<p>Editor-based approach requires a bit of preparation, yet it is still simple. First you need a tile set, something like this:</p>
<p><img src="tileset.png" alt="tile set" /></p>
<p>It is a 11x11 sprite sheet for a top-down game. Now you need to create a tile set resource from this tile set. Navigate
the asset browser and click on <code>+</code> button near the search bar. Select <code>TileSet</code> resource and click <code>OK</code>. Find the resource
you've just created in the asset browser, then double-click on it to open the tile set editor.</p>
<p><img src="tile_set_editor.png" alt="tile set editor" /></p>
<h4 id="creating-an-atlas-page"><a class="header" href="#creating-an-atlas-page">Creating an Atlas Page</a></h4>
<p>Now it is time to create the first page for our new tile set. Click anywhere in the upper grid to select the position for
the page, then click the "Tile Atlas" button under "Create New Page" on the right side of the editor.</p>
<p>Because the selected page position is no longer empty, the "Create New Page" menu is replaced by an inspector for the
properties of the new atlas page. Here you can edit the material for the tiles and change the size of the tiles as measured
in texture pixels. These properties can be changed at any time, and the resulting changes will affect all the tiles of the page.</p>
<p>Once you have set your sprite sheet as the texture for the material, the texture will become visible in the lower grid of the
editor. Use the scroll wheel to zoom and pan if necessary to see all of it. This is only a <em>preview</em> of what the tiles might
look like; the tiles have not yet been created, and the texture is faded to distinguish it from actual tiles.
You can adjust the fade using the "Material Tint" color field in the top-right of the editor. This has no affect on the tile
set resource; it is purely cosmetic within the editor.</p>
<p>To actually create some tiles, left-click and drag on the lower grid to select whatever areas of the material should have
tiles. Holding shift will allow you to select multiple areas at once. Once you are satisfied with your selection,
press the "Create Tile" button on the right side of the editor. This will fill any empty selected cells with new tiles,
covering the faded material preview with the full-color of actual tiles.</p>
<h4 id="creating-a-freeform-page"><a class="header" href="#creating-a-freeform-page">Creating a Freeform Page</a></h4>
<p>Select any empty cell in the upper grid to cause the "Create New Page" menu to appear. Click "Free Tiles" button to
start creating freeform tiles on your tile set's new page. Unlike the atlas page, a freeform page has very few properties
to edit in the inspector. This is because each tile has its own material and size fields.</p>
<p><img src="freeform_tile_edit.png" alt="Freeform tile edit" /></p>
<p>Select any empty cell in the lower grid and click "Create Tile" to begin editing the properties for a new freeform tile.
At the top is a field for choosing the material for the tile. It will initially be a blank material with the
standard tile shader. Below that are four pairs of coordinates that represent for points on the material's texture as
measured in texture pixels. The left-top point represents the left-top corner of the tile, and so on around all four
corners of the tile.</p>
<p>Below the tile corners are four buttons for performing flips and rotations on the corner coordinates. By changing the
coordinates of the corners of the tile, the tile can be rotated by 90 degrees and flipped horizontally and vertically.</p>
<p>Next there is the tile's color which can be used to apply tinting or transparency to the tile.</p>
<p>It is also possible to add tiles to a freeform page by painting them with tools on the Tile Map Control Panel which will
be discussed later.</p>
<h4 id="creating-a-transform-page"><a class="header" href="#creating-a-transform-page">Creating a Transform Page</a></h4>
<p>Once you have prepared a library of tiles with your tile set, you may want to specify which tiles are mirrored or rotated
versions of other tiles. This will allow the tile set produce a flipped or rotated version of a tile just by giving it
the handle of the tile and the desired transformation. Start by selecting an empty page cell and clicking "Transform"
under "Create New Page."</p>
<p>In the lower grid area you should see that the cells have been divided into 2x4 groups. Each cell of these groups can store
a <code>TileDefinitionHandle</code> and the eight handles together will specify all possible combinations of flips and 90-degree rotations
that may be needed for a tile.</p>
<p><img src="tile_map_rotate.png" alt="Transform page" /></p>
<p>In order to fill this page with tile handles, click the "Palette" button in the upper-right to open the "Tile Map Control Panel" window,
if it is not already open. This is the same window that you will use to edit a tile map, and so it has tools designed for selecting
tile handles and putting them wherever you want them. The panel should already be showing the grid of pages from your tile set.
If the panel is showing something else, then find your tile set in the asset browser and drag it onto the panel.</p>
<p>Use the panel to select a page from your tile set, and then select a tile that you want to put into your transform page.
Click the button with the paint brush icon to activate the brush tool, then click in the tile set editor to paint the handle
for the selected tile into a cell of the transform page. The tools available for painting, moving, copying, and deleting
tile handles will be discussed in more detail later.</p>
<h4 id="creating-an-animation-page"><a class="header" href="#creating-an-animation-page">Creating an Animation Page</a></h4>
<p>In order to make your tiles move over time, first create a sequence of animation frames for your tile, and make a tile
for each from using an atlas page or a freeform page. Now we are ready to create an animation page.</p>
<p><img src="tile_map_animation.png" alt="Animation page" /></p>
<p>While the animation page is selected, choose the frame rate for animations on this page, measured in frames per second.
All animations on the same page share the same frame rate.</p>
<p>Editing an animation page is just like editing a transform page, but instead of organizing the tile handles in groups of eight,
we are creating horizontal sequences of tiles. These sequences can start and end anywhere on the page, so long as there is an
empty cell immediately to the left and right of the sequence to indicate where the sequence begins and ends. The editor will
draw a mark in the empty cells to confirm where the animation starts and ends. When an animation reaches the end of the sequence
it automatically repeats.</p>
<p>As soon as you have finished making your animation page, your tile set will already be animating. The editor may not draw frames
as smoothly as a running game, so put some animated tiles in your tile map and then run your game to see the full effect of the animation.</p>
<h4 id="creating-the-tile-map-node"><a class="header" href="#creating-the-tile-map-node">Creating the Tile Map Node</a></h4>
<p>Now we have the tile set, and we can start creating a tile map using it. Click <code>Create -&gt; 2D -&gt; Tile Map</code> and you should
see something like this:</p>
<p><img src="empty_tile_map.png" alt="empty tile map" /></p>
<p>If you look closely, the editor warns us about missing tile set. Find the tile set you've just made and drag'n'drop it
from the asset browser to the <code>Tile Set</code> field in the inspector.</p>
<h2 id="tile-map-brush"><a class="header" href="#tile-map-brush">Tile Map Brush</a></h2>
<p>There's one more step before we start editing the tile map - we need a brush to paint on the tile map.
Click <code>+</code> button in the asset browser and select <code>TileMapBrush</code>, set a name for it and click <code>OK</code>.
Now select the tile map scene node and drag'n'drop the brush you've just created to "Active Brush" property.
This will make it the default brush whenever you edit this tile map node.</p>
<p>Double-click the brush asset in the asset browser to open the tile set editor again. This time the editor will be
in brush-editing mode, which is simpler because a brush has only one kind of page and it has no tabs for properties
or collision. The purpose of a brush is just to create convenient arrangements of tile handles from some tile set
to streamline the process of tile map editing.</p>
<p>Drag the tile set asset from the asset browser into the "Tile Set" field in the upper-right of the tile set editor to
store a reference to the tile set in the brush asset. The brush needs to know which tile set its tile handles refer to.</p>
<p>Click some empty cell in the upper grid of the editor and then click "Add Page" to add your first page to the brush.</p>
<p>Next, press the "Palette" button to open the Tile Map Control Panel so that you can paint some tile handles into the
new brush. Initially the control panel will show the tiles and pages of the brush you are currently editing, which
is no help when the brush is empty, so click the "Tile Set" button in the control panel to switch to showing the pages
and tiles of the tile set. Select some tiles and paint them into the brush in whatever arrangement is most convenient
for editing.</p>
<p>Unlike a tile set resource, the content of a brush resource is only used in the editor, so you can re-arrange the pages
and tiles of your brush or even delete your brush without any consequences for your tile map or for the running game.
While you can draw tiles to the tile map directly from the tile set, using a brush offers far more flexibility in
how you arrange your tiles, allowing you to create multiple copies of tiles and arrange tiles in convient groups that
gather your most-often-used tiles.</p>
<p>At this point everything is ready for painting. Select the tile map node and click tile map interaction mode button
at the top of the Scene Preview window. You should now see the tile map grid in the Scene Preview. The Tile Map Control Panel
should automatically open if it is not already open, and it should be showing the pages and tiles of your brush.</p>
<p><img src="grid.png" alt="grid" /></p>
<p>Select some tiles on the control panel and start drawing:</p>
<p><img src="drawing.png" alt="drawing" /></p>
<h2 id="drawing-tools"><a class="header" href="#drawing-tools">Drawing Tools</a></h2>
<p>There are number of tools that could be useful while editing tile maps when in the tile map interaction mode.</p>
<h3 id="brush-tool"><a class="header" href="#brush-tool">Brush Tool</a></h3>
<p><img src="tile_map_tools/brush_tool.png" alt="Brush tool" /></p>
<p>The brush tool takes whatever tiles are selected and puts the handles for those tiles wherever you click on the selected tile map.
The selected tiles are called the stamp, and the stamp will be used in one way or another by each of the drawing tools.
You can select any number of tiles and their handles will be drawn in the same relative positions where you click, or you can use
the flip and rotation buttons to flip and rotate the stamp before drawing it. The preview area of the Tile Map Control Panel
shows approximately what the tiles should look like when they are drawn.</p>
<h3 id="erase-tool"><a class="header" href="#erase-tool">Erase Tool</a></h3>
<p><img src="tile_map_tools/erase_tool.png" alt="Erase tool" /></p>
<p>Erases tiles using the shape of the current stamp. Activate it using the <code>2</code> key or by clicking on the
button with eraser icon.</p>
<p><img src="erase.gif" alt="erase" /></p>
<h3 id="flood-fill-tool"><a class="header" href="#flood-fill-tool">Flood Fill Tool</a></h3>
<p><img src="tile_map_tools/flood_tool.png" alt="Flood fill tool" /></p>
<p>Fills a region with the same tile kind (or empty space) using the tiles of the current stamp.
Activate it using the button with paint bucket icon.</p>
<p>Unlike the other tools, the flood fill tool is not implemented for use in the Tile Set Editor,
so in the Tile Set Editor the flood tool will just act like the brush tool.</p>
<p><img src="tile_map_tools/flood_fill.png" alt="flood fill" /></p>
<h3 id="pick-tool"><a class="header" href="#pick-tool">Pick Tool</a></h3>
<p><img src="tile_map_tools/pick_tool.png" alt="Pick tool" /></p>
<p>Picks a rectangular region of tiles from the tile map itself and turns them into the current stamp.
Hold shift to add additional rectangular regions to the stamp.
Activate it using the <code>1</code> key or by clicking the button with pipette icon.</p>
<p>Hold alt to drag the currently selected tiles and move them to a different location in the tile map,
or tile set editor page. You can also use this to change the position of a page in the tile set editor,
but beware that the position of a tile set page is part of a tile's handle, so moving a page can invalidate
any handle that refers to a tile on that page. Handles are not destroyed when they are invalidated this way;
they merely fail to render correctly until a page is added to the tile set with a tile where the handle
is expecting to find tile data.</p>
<h3 id="rectangular-fill-tool"><a class="header" href="#rectangular-fill-tool">Rectangular Fill Tool</a></h3>
<p><img src="tile_map_tools/rect_tool.png" alt="Rect fill tool" /></p>
<p>Fills a rectangular region with the tiles from the current stamp. It tiles the given region using the
tiles from current stamp. Could be activated using <code>3</code> key or by clicking on the button with the tiles icon.</p>
<p>To randomize the order of the tiles within the rectangle, toggle the on the dice button.</p>
<p><img src="rect_fill.gif" alt="rect fill" /></p>
<h3 id="nine-slice-tool"><a class="header" href="#nine-slice-tool">Nine Slice Tool</a></h3>
<p><img src="tile_map_tools/nine_tool.png" alt="Nine slice tool" /></p>
<p>Fills a rectangular region using a rectangluer stamp divided into nine sections: four corners, four sides, and the center.
The corners of the stamp will be placed at the corners of the selected region. The sides of the stamp will fill the sides
of the selected reation, and the center of the stamp will fill the center of the selected region.</p>
<p>To randomize the order of the tiles within the rectangle, toggle the on the dice button.</p>
<p><img src="nine_slice.gif" alt="nine slice" /></p>
<h3 id="line-tool"><a class="header" href="#line-tool">Line Tool</a></h3>
<p><img src="tile_map_tools/line_tool.png" alt="Nine slice tool" /></p>
<p>Drag the mouse from one cell to another to draw a line of tiles between the two cells using the tiles of the current brush.</p>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>Tile maps support physics for tiles, if collision shape data is included in the tile set. Start by opening the
tile set editor, then click on the "Collison" tab at the top of the window. This will allow you to edit
the list of collision layers of the tile set. Each layer allows a collision shape to be added to the tiles,
so with multiple layers a tile may have multiple collison shapes.</p>
<p>Each layer has a name and a color, and in code it can be identified by a UUID. The color is cosmetic, and
controls how the shapes on that layer appear when they are visible. The name is used to identify the layer
for a 2D rigid body.</p>
<p>There are currently three different ways to set the collision shape for each tile:</p>
<p>-None: The tile has no collision shape, the default.
-Full: The tile's full square is covered by a collision shape.
-Custom: The user supplies a list of triangles to construct a collision shape.</p>
<p>In code, custom collision shapes are created using a <code>fyrox::scene::tilemap::CustomTileCollider</code> which is a simple struct like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomTileCollider {
    /// The vertices of the triangles, with the boundaries of the tile being between (0,0) and (1,1).
    pub vertices: Vec&lt;Vector2&lt;f32&gt;&gt;,
    /// The indices of the vertices of each triangle
    pub triangles: Vec&lt;TriangleDefinition&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>To create a custom tile collider in the editor, it is currently required that the user manually types in the information
as a list of vertices and triangle indices, such as "(0,0) (1,1) (1,0) [0,1,2]". This would create a triangle covering the
bottom right half of the tile. The parentheses and brackets are optional and are ignored; only the numbers and commas are parsed
to understand the user's intended triangles.</p>
<p><img src="tile_collider_edit.png" alt="Tile with custom collision shape" /></p>
<p>Click the eye button next to the collision layer to toggle visibility of collision shapes for that layer.
Collisions shapes will be drawn over the tiles in the color you have chosen for that collision layer,
so it is best to choose an alpha value with some transparency.</p>
<h3 id="adding-a-2d-rigid-body"><a class="header" href="#adding-a-2d-rigid-body">Adding a 2D Rigid Body</a></h3>
<p>Enable physics for a tile map by using the collider shape called <code>TileMap</code> and specifying the name of the layer.
In code it could be done something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_tile_map_physics(tile_map: Handle&lt;Node&gt;, graph: &amp;mut Graph) {
    // Create a new collider with tile map shape.
    let collider = ColliderBuilder::new(BaseBuilder::new())
        .with_shape(ColliderShape::TileMap(TileMapShape {
            tile_map: GeometrySource(tile_map),
            layer_name: "MainColliders".into(),
        }))
        .build(graph);

    // Create a static rigid body with the tile map collider.
    let rigid_body = RigidBodyBuilder::new(BaseBuilder::new().with_children(&amp;[collider]))
        .with_body_type(RigidBodyType::Static)
        .build(graph);
}
<span class="boring">}</span></code></pre></pre>
<p>In the editor it could be done by creating a static 2D rigid body with a 2D collider that has the <code>TileMap</code> shape.
Give the shape the tile map and the name of the collision layer that the rigid body is supposed to represent.</p>
<p><img src="tile_map_physics.png" alt="tile map physics" /></p>
<h2 id="layers"><a class="header" href="#layers">Layers</a></h2>
<p>Tile map does not support any layers on its own, but layers could be added very easy by simply creating another tile
map with its own tile set and shifting this new layer by Z axis towards camera on some small value.</p>
<h2 id="tile-properties"><a class="header" href="#tile-properties">Tile Properties</a></h2>
<p>Tile set could contain custom properties for each tile, these properties could be used to attach additional information
to the tiles in your game. This could include surface type (water, lava, dirt, etc.), physics properties (friction,
restitution, etc.) and any other you need.</p>
<p>In the tile set editor, create properties using the "Properties" tab which gives you access to a list of property layers.
Each property layer has a data type, and the type must be chosen when the layer is created, since changing the type of
an already existing layer could cause tiles to have the wrong type of value for the property.</p>
<p><img src="tile_map_properties.png" alt="Tile map properties editor" /></p>
<p>Each property may also have a list of pre-defined values. Each pre-defined value has a name and a color to help the user
visualize which tiles have that value for the property and to help keep track of the meaning of that value.
Once a property has been created in the Properties tab, the value for that property can be set for each tile in the
Tiles tab.</p>
<p>In code, properties can be created, set, and accessed like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SOIL: i32 = 1;
const SLIME: i32 = 2;
const SURFACE_TYPE_UUID: Uuid = uuid!("a70a754b-eed5-4e60-bf8a-3239f0b6004b");

fn create_tile_map_with_props(graph: &amp;mut Graph) {
    let material = MaterialResource::new_ok(ResourceKind::Embedded, Material::standard_2d());

    let mut tiles = TileGridMap::default();
    let stone_tile = TileDefinitionHandle::new(0, 0, 0, 0);
    let grass_tile = TileDefinitionHandle::new(0, 0, 1, 0);
    tiles.insert(
        stone_tile.tile(),
        TileDefinition {
            material_bounds: TileMaterialBounds {
                material: material.clone(),
                bounds: TileBounds {
                    left_top_corner: Vector2::new(0, 0),
                    right_top_corner: Vector2::new(16, 0),
                    left_bottom_corner: Vector2::new(0, 16),
                    right_bottom_corner: Vector2::new(16, 16),
                },
            },
            data: TileData {
                color: Color::BROWN,
                properties: [(SURFACE_TYPE_UUID, TileSetPropertyValue::I32(SLIME))]
                    .into_iter()
                    .collect(),
                colliders: FxHashMap::default(),
            },
        },
    );
    tiles.insert(
        grass_tile.tile(),
        TileDefinition {
            material_bounds: TileMaterialBounds {
                material: material.clone(),
                bounds: TileBounds {
                    left_top_corner: Vector2::new(0, 0),
                    right_top_corner: Vector2::new(16, 0),
                    left_bottom_corner: Vector2::new(0, 16),
                    right_bottom_corner: Vector2::new(16, 16),
                },
            },
            data: TileData {
                color: Color::GREEN,
                properties: [(SURFACE_TYPE_UUID, TileSetPropertyValue::I32(SOIL))]
                    .into_iter()
                    .collect(),
                colliders: FxHashMap::default(),
            },
        },
    );
    let source = TileSetPageSource::Freeform(tiles);
    let page = TileSetPage {
        icon: TileDefinitionHandle::new(0, 0, 0, 0),
        source,
    };
    let mut tile_set = TileSet::default();
    tile_set.insert_page(Vector2::new(0, 0), page);
    tile_set.properties.push(TileSetPropertyLayer {
        name: "SurfaceType".into(),
        uuid: SURFACE_TYPE_UUID,
        prop_type: TileSetPropertyType::F32,
        named_values: Vec::default(),
    });
    let tile_set = TileSetResource::new_ok(ResourceKind::Embedded, tile_set);

    // ..
}

fn calculate_speed_factor(tile_map: &amp;TileMap, player_position: Vector3&lt;f32&gt;) -&gt; f32 {
    let grid_position = tile_map.world_to_grid(player_position);

    match tile_map.tile_property_value(grid_position, SURFACE_TYPE_UUID) {
        Ok(SOIL) =&gt; 1.0,
        Ok(SLIME) =&gt; 0.7,
        Ok(_) =&gt; {
            Log::err("Unknown surface type");
            1.0
        }
        // See fyrox::scene::tilemap::TilePropertyError for a list of possible errors.
        Err(err) =&gt; {
            Log::err(err.to_string());
            1.0
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>Here we have two types of tiles - soil and slime, soil does not have any effect on player's movement speed, while the
slime slows down the player by 30%. This code does not actually use any physical contact information and just uses tile
position, but it could be fixed pretty easily - supply physical contact position to it, and it will return correct results.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../scene/rectangle.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../scene/custom_node.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../scene/rectangle.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../scene/custom_node.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
