<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Terrain Node - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/scene/terrain_node.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="terrain"><a class="header" href="#terrain">Terrain</a></h1>
<p>Terrain is a scene node that represents uniform grid of cells where each cell can have different height. Other, commonly
known name for terrain is heightmap. Terrains used to create maps for open-world games, it is used to create hills,
mountains, plateau, roads, etc.</p>
<p><img src="./terrain.png" alt="terrain" /></p>
<h2 id="basic-concepts"><a class="header" href="#basic-concepts">Basic concepts</a></h2>
<p>There are few basic concepts that you should understand before trying to use terrains. This will help you to understand
design decisions and potential use cases.</p>
<h3 id="heightmap"><a class="header" href="#heightmap">Heightmap</a></h3>
<p>As it was already mentioned, terrain is a uniform grid where X and Z coordinates of cells have fixed values, while Y
can change. In this case we can store only width, height and resolution numerical parameters to calculate X and Z coordinates,
while Y is stored in a separate array which is then used to modify heights of cells. Such array is called <em>heightmap</em>.</p>
<p><img src="./terrain_mesh.png" alt="terrain mesh" /></p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>Layer is a material + mask applied to terrain's mesh. Mask is a separate, greyscale texture that defines in which parts
of the terrain the material should be visible or not. White pixels in the mask makes the material to be visible, black -
completely transparent, everything between helps you to create smooth transitions between layers. Here's a simple
example of multiple layers:</p>
<p><img src="./terrain_layers_layout.png" alt="terrain layers layout" /></p>
<p>There are 3 layers: 1 - dirt, 2 - grass, 3 - rocks and grass. As you can see, there are smooth transitions between each
layer, it is achieved by layer's mask.</p>
<p>Each layer uses separate material, which can be edited from respective property editor in the Inspector:</p>
<p><img src="./terrain_layer_material.png" alt="terrain layer material" /></p>
<h2 id="creating-terrain-in-the-editor"><a class="header" href="#creating-terrain-in-the-editor">Creating terrain in the editor</a></h2>
<p>You can create a terrain node by clicking <code>Create -&gt; Terrain</code>. It will create a terrain with fixed width, height,
and resolution (see <a href="./terrain_node.html#limitations-and-known-issues">limitations</a>). Once the terrain is created, select
it in the World Viewer and click on Hill icon on the toolbar. This will enable terrain editing, brush options panel
should also appear. See the picture below with all the steps:</p>
<p><img src="./terrain_editing.png" alt="terrain editing" /></p>
<p>The green rectangle on the terrain under the cursor represents current brush. You can edit brush options in the
<code>Brush Options</code> window:</p>
<p><img src="./brush_options.png" alt="brush options" /></p>
<ul>
<li><em>Shape:</em> Select a circular brush or a rectangular brush. When a circular brush is selected, a control to adjust its
radius appears. When a rectangular brush is select, controls for its width and length appear. The size of the green
rectangle changes to reflect the size of the brush based on these controls.</li>
<li><em>Mode:</em> Select the terrain editing operation that the brush should perform.
<ul>
<li><em>Raise or Lower:</em> Modifies the existing value by a fixed amount. When the number is positive, the value is
increased. When the number is negative, the value is decreased. When the brush target is "Height Map", this can be
to raise or lower the terrain. When the <code>Shift</code> key is held at the start of a brush stroke, the number of raising or lowering
is negated, so a raise operation becomes a lowering operation.</li>
<li><em>Assign Value:</em> Replaces the existing value with a given value. For example, if you want to create a plateau
with land of a specific height, you can select this mode and type in the height you want as the brush value.</li>
<li><em>Flatten:</em> Levels terrain by spreading the value of the terrain from point where you click across wherever
you drag the brush. It works just like <em>Assign Value</em> except you do not need to specify the desired value because it
is taken automatically from the value of the terrain where the brush stroke starts.</li>
<li><em>Smooth:</em> For each point of the terrain touched by the brush, replace that value with an average of the nearby values.
This tends to diminish sharp transitions in terrain value.</li>
</ul>
</li>
<li><em>Target:</em> There are multiple aspects of terrain that can be edited by a brush, and this control allows you to select which
one you will be editing. Setting it to "Height Map" causes the brush to change the terrain elevation.
Setting it to "Layer Mask" causes it to change the transparency of the layer with a chosen index.
Masks are always clamped to be between 0 and 1, regardless of what brush mode is selected, since 0 represents fully transparent
and 1 represents the layer being fully opaque.</li>
<li><em>Transform:</em> This is a 2x2 matrix that is applied to the brush's shape, allowing linear transformations such as rotating
a rectangular brush, or skewing, or stretching.
For most purposes the identity matrix of \(\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix}\) works well, since that is the default that applies no modification to the brush's shape.
If the matrix is not invertable, then it will be ignored.</li>
<li><em>Hardness:</em> The effect of a brush does not need to be applied equally across its entire area. The <em>hardness</em>
of a brush controls how much of a brush gets its full effect.
When hardness is 0, only the exact center of the brush receives the full effect, while the rest of the brush fades from
full effect to no effect at the edges.
When hardness is 1 or greater, the entire brush gets the full effect.
If the value is less than 0, then even the center of the brush does not receive the full effect.</li>
<li><em>Alpha:</em> The \(\alpha\) value linearlly interpolates between the current value of the terrain and the value that would be
produced by the full effect of the brush.
If \(v_0\) is the current value of a point on the terrain and and \(v_1\) is the full effect of the brush, then the actual
effect that the brush will apply will be \((1 - \alpha) * v_0 + \alpha * v_1\).
There is no requirement that \(\alpha\) must be between 0 and 1. Values less than 0 will invert the effect of the brush,
while values greater than 1 will exaggerate the effect of the brush.
Values close to 0 can be used to make fine adjustments by applying an effect incrementally across multiple brush strokes.</li>
</ul>
<p>Each brush stroke is treated as an independent operation starting from when the mouse button is pressed and ending when
the mouse button is released. Repeatedly dragging the mouse across the same area of terrain will not increase the effect
of the brush as it is all part of the same brush stroke, but repeatedly pressing and releasing the mouse button will
cause the brush's effect to be applied repeatedly since that is counted as multiple brush strokes.</p>
<h2 id="creating-terrain-from-code"><a class="header" href="#creating-terrain-from-code">Creating terrain from code</a></h2>
<p>Terrain brushes can also be used to edit terrain from code by using <code>fyrox::scene:terrain::Brush</code> and <code>fyrox::scene::terrain::BrushContext</code>.</p>
<p>The <code>Brush</code> structure has fields for each of the brush options, and the <code>BrushContext</code> structure has methods for accepting a <code>Brush</code> and
applying it to a terrain. BrushContext allows you to start a new stroke, perform stamps and smears during the stroke, then end the stroke
to write the constructed brush stroke to the terrain. It is also possible to <code>flush</code> a partially finished stroke to the terrain, so that
a brush stroke may be animated across multiple frames instead of appearing on the terrain all at once.</p>
<p>Here is a list of methods provided by <code>BrushContext</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn start_stroke(&amp;mut self, terrain: &amp;Terrain, brush: Brush)
<span class="boring">}</span></code></pre></pre>
<p>Call this to choose the brush that will be used for the rest of the stroke. At this point the <code>BrushContext</code> records which textures the
terrain is using to represent the data for the given brush's target. and those textures are the ones that will finally be modified
when <code>end_stroke</code> is eventually called.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn stamp(&amp;mut self, terrain: &amp;Terrain, position: Vector3&lt;f32&gt;)
<span class="boring">}</span></code></pre></pre>
<p>Call this to stamp the brush at a single point on the terrain. A stroke should already have been started, as this is potentially just
one operation out of many that could make up a stroke.</p>
<p>The terrain is not modified; it is only being used to translate the the given position from world space to terrain texture space.
In order to actually see the results of this stamp in the terrain, <code>flush</code> or <code>end_stroke</code> must be called.</p>
<p>The y-coordinate of the position is ignored as the position is projected onto the terrain.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn smear(&amp;mut self, terrain: &amp;Terrain, start: Vector3&lt;f32&gt;, end: Vector3&lt;f32&gt;)
<span class="boring">}</span></code></pre></pre>
<p>A smear is just like a stamp, except it continuously paints with the brush along a line from <code>start</code> to <code>end</code>.
Again, a stroke should already have been started in order to select the brush to paint with, and the results will not
appear immediately on the terrain.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn flush(&amp;mut self)
<span class="boring">}</span></code></pre></pre>
<p>Call this to force the terrain to update to include the modifications due to a partially completed brush stroke.
If a stroke is being drawn across multiple frames, it would make sense to call <code>flush</code> at the end of each frame.
The <code>flush</code> method does not require the terrain to be passed in because <code>BrushContext</code> already knows which textures
need to be modified in order to update the terrain.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn end_stroke(&amp;mut self)
<span class="boring">}</span></code></pre></pre>
<p>Call this to update the terrain to include the modifications due to the stroke, and clear all data for that stroke
so that the context is ready to begin a new stroke.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shape(&amp;mut self) -&gt; &amp;mut BrushShape
<span class="boring">}</span></code></pre></pre>
<p>This provides mutable access to the brush's shape, making it possible to change the shape without starting a new stroke.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hardness(&amp;mut self) -&gt; &amp;mut f32
<span class="boring">}</span></code></pre></pre>
<p>This provides mutable access to the brush's hardness, making it possible to change the hardness without starting a new stroke.</p>
<p>There are also similiar methods for changing the brush's alpha and mode in the middle of a stroke, but these are unlikely to serve
any practical use as brush strokes do not tend to react well to such changes. It is best to start a new stroke if a new brush mode
is needed. It is particularly not possible to change the brush's target in the middle of a stroke, because that would require
updating other details of the internal state of the <code>BrushContext</code>.</p>
<p>Here is an example of <code>BrushContext</code> in use:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_layer_material(
    material: &amp;mut Material,
    resource_manager: ResourceManager,
    diffuse_texture: &amp;str,
    normal_texture: &amp;str,
) {
    material.bind(
        "diffuseTexture",
        Some(resource_manager.request::&lt;Texture&gt;(diffuse_texture)),
    );
    material.bind(
        "normalTexture",
        Some(resource_manager.request::&lt;Texture&gt;(normal_texture)),
    );
    material.set_property("texCoordScale", Vector2::new(10.0, 10.0));
}

pub fn create_random_two_layer_terrain(
    graph: &amp;mut Graph,
    resource_manager: &amp;ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    let terrain = TerrainBuilder::new(BaseBuilder::new())
        .with_layers(vec![
            Layer {
                material: {
                    let mut material = Material::standard_terrain();
                    setup_layer_material(
                        &amp;mut material,
                        resource_manager.clone(),
                        "examples/data/Grass_DiffuseColor.jpg",
                        "examples/data/Grass_NormalColor.jpg",
                    );
                    MaterialResource::new_ok(ResourceKind::Embedded, material)
                },
                ..Default::default()
            },
            Layer {
                material: {
                    let mut material = Material::standard_terrain();
                    setup_layer_material(
                        &amp;mut material,
                        resource_manager.clone(),
                        "examples/data/Rock_DiffuseColor.jpg",
                        "examples/data/Rock_Normal.jpg",
                    );
                    MaterialResource::new_ok(ResourceKind::Embedded, material)
                },
                ..Default::default()
            },
        ])
        .build(graph);

    let terrain_ref = graph[terrain].as_terrain_mut();
    let mut context = BrushContext::default();

    // Draw something on the terrain.
    for _ in 0..60 {
        let x = thread_rng().gen_range(4.0..60.00);
        let z = thread_rng().gen_range(4.0..60.00);
        let radius = thread_rng().gen_range(2.0..4.0);
        let height = thread_rng().gen_range(1.0..3.0);
        let tail_x = thread_rng().gen_range(-5.0..=5.0);
        let tail_z = thread_rng().gen_range(-5.0..=5.0);

        // Pull terrain.
        context.start_stroke(
            terrain_ref,
            Brush {
                shape: BrushShape::Circle { radius },
                mode: BrushMode::Raise { amount: height },
                target: BrushTarget::HeightMap,
                hardness: 0.0,
                ..Brush::default()
            },
        );
        context.stamp(terrain_ref, Vector3::new(x, 0.0, z));
        *context.shape() = BrushShape::Circle {
            radius: radius * 0.5,
        };
        context.smear(
            terrain_ref,
            Vector3::new(x, 0.0, z),
            Vector3::new(x + tail_x, 0.0, z + tail_z),
        );
        context.end_stroke();

        // Draw rock texture on top.
        context.start_stroke(
            terrain_ref,
            Brush {
                shape: BrushShape::Circle { radius },
                mode: BrushMode::Assign { value: 1.0 },
                target: BrushTarget::LayerMask { layer: 1 },
                hardness: 0.0,
                ..Brush::default()
            },
        );
        context.stamp(terrain_ref, Vector3::new(x, 0.0, z));
        *context.shape() = BrushShape::Circle {
            radius: radius * 0.5,
        };
        context.smear(
            terrain_ref,
            Vector3::new(x, 0.0, z),
            Vector3::new(x + tail_x, 0.0, z + tail_z),
        );
        context.end_stroke();
    }

    terrain
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see there is quite a lot of code, ideally you should use editor all the times, because handling everything
from code could be very tedious. The result of its execution (if all textures are set correctly) could be something
like this (keep in mind that terrain will be random everytime you run the code):</p>
<p><img src="./terrain_random.png" alt="terrain from code" /></p>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>By default, terrains does not have respective physical body and shape, it should be added manually. Create a static
rigid body node with a collider with Heightmap shape (<a href="../physics/collider.html">learn more about colliders</a>). Then attach
the terrain to the rigid body. Keep in mind that terrain's origin differs from Heightmap rigid body, so you need to offset
the terrain to match its physical representation. Enable physics visualization in editor settings to see physical shapes
and move terrain. Now to move the terrain you should move the body, instead of the terrain (because of parent-child
<a href="../beginning/scene_and_scene_graph.html#local-and-global-coordinates">relations</a>).</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Terrain rendering complexity have linear dependency with the number of layers terrain have. Each layer forces the engine
to re-render terrain's geometry with different textures and mask. Typical number of layers is from 4 to 8. For example,
a terrain could have the following layers: dirt, grass, rock, snow. This is a relatively lightweight scheme. In any case,
you should measure frame time to understand how each new layer affects performance in your case.</p>
<h2 id="chunking"><a class="header" href="#chunking">Chunking</a></h2>
<p>Terrain itself does not define any geometry or rendering data, instead it uses one or more chunks for that purpose. Each
chunk could be considered as a "sub-terrain". You can "stack" any number of chunks from any side of the terrain. To do
that, you define a range of chunks along each axis. This is very useful if you need to extend your terrain in a particular
direction. Imagine that you've created a terrain with just one chunk (<code>0..1</code> range on both axes), but suddenly you found
that you need to extend the terrain to add some new game locations. In this case you can change the range of chunks at
the desired axis. For instance, if you want to add a new location to the right from your single chunk, then you should
change <code>width_chunks</code> range to <code>0..2</code> and leave <code>length_chunks</code> as is (<code>0..1</code>). This way terrain will be extended, and
you can start shaping the new location.</p>
<h2 id="level-of-detail"><a class="header" href="#level-of-detail">Level-of-detail</a></h2>
<p>Terrain has automatic LOD system, which means that the closest portions of it will be rendered with the highest
possible quality (defined by the resolution of height map and masks), while the furthest portions will be
rendered with the lowest quality. This effectively balances GPU load and allows you to render huge terrains with
low overhead.</p>
<p>The main parameter that affects LOD system is <code>block_size</code> (<code>Terrain::set_block_size</code>), which defines size of the patch
that will be used for rendering. It is used to divide the size of the height map into a fixed set of blocks using
quad-tree algorithm.</p>
<p>Current implementation uses modified version of CDLOD algorithm without patch morphing. Apparently it is not needed,
since bilinear filtration in vertex shader prevents seams to occur.</p>
<p>Current implementation makes it possible to render huge terrains (64x64 km) with 4096x4096 heightmap resolution in about a
millisecond on average low-to-middle-end GPU.</p>
<h2 id="limitations-and-known-issues"><a class="header" href="#limitations-and-known-issues">Limitations and known issues</a></h2>
<p>There is no way to cut holes in the terrain yet, it makes impossible to create caves. There is also no way to create
ledges, use separate meshes to imitate this. See <a href="https://github.com/FyroxEngine/Fyrox/issues/351">tracking issue</a> for
more info.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../scene/particle_system_node.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../scene/camera_node.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../scene/particle_system_node.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../scene/camera_node.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
