<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2D Platformer tutorial - Fyrox Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../../fyrox/introduction.html"><strong aria-hidden="true">2.</strong> fyrox</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/beginning/getting_started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/beginning/scripting.html"><strong aria-hidden="true">2.1.1.</strong> Plugins and Scripts</a></li><li class="chapter-item expanded "><a href="../../../fyrox/beginning/editor_overview.html"><strong aria-hidden="true">2.1.2.</strong> Editor Overview</a></li><li class="chapter-item expanded "><a href="../../../fyrox/beginning/scene_and_scene_graph.html"><strong aria-hidden="true">2.1.3.</strong> Scene and scene graph</a></li><li class="chapter-item expanded "><a href="../../../fyrox/beginning/assets.html"><strong aria-hidden="true">2.1.4.</strong> Assets</a></li><li class="chapter-item expanded "><a href="../../../fyrox/beginning/data_management.html"><strong aria-hidden="true">2.1.5.</strong> Data management</a></li><li class="chapter-item expanded "><a href="../../../fyrox/beginning/installation.html"><strong aria-hidden="true">2.1.6.</strong> Installation (Obsolete)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/beginning/framework.html"><strong aria-hidden="true">2.1.7.</strong> Framework (Obsolete)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/beginning/custom_game_loop.html"><strong aria-hidden="true">2.1.8.</strong> Custom game loop (Obsolete)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/scene.html"><strong aria-hidden="true">2.2.</strong> Scene</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/scene/graph.html"><strong aria-hidden="true">2.2.1.</strong> Graph</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/base_node.html"><strong aria-hidden="true">2.2.2.</strong> Base node</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/mesh_node.html"><strong aria-hidden="true">2.2.3.</strong> Mesh node</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/light_node.html"><strong aria-hidden="true">2.2.4.</strong> Light node</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/sprite_node.html"><strong aria-hidden="true">2.2.5.</strong> Sprite node</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/particle_system_node.html"><strong aria-hidden="true">2.2.6.</strong> Particle system node (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/terrain_node.html"><strong aria-hidden="true">2.2.7.</strong> Terrain node (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/camera_node.html"><strong aria-hidden="true">2.2.8.</strong> Camera node</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/decal_node.html"><strong aria-hidden="true">2.2.9.</strong> Decal node</a></li><li class="chapter-item expanded "><a href="../../../fyrox/scene/rectangle.html"><strong aria-hidden="true">2.2.10.</strong> Rectangle node</a></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/animation/animation.html"><strong aria-hidden="true">2.3.</strong> Animation (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/rendering/rendering.html"><strong aria-hidden="true">2.4.</strong> Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/rendering/shaders.html"><strong aria-hidden="true">2.4.1.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="../../../fyrox/rendering/materials.html"><strong aria-hidden="true">2.4.2.</strong> Materials</a></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/sound/sound.html"><strong aria-hidden="true">2.5.</strong> Sound</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/sound/hrtf.html"><strong aria-hidden="true">2.5.1.</strong> HRTF (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/physics/physics.html"><strong aria-hidden="true">2.6.</strong> Physics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/physics/rigid_body.html"><strong aria-hidden="true">2.6.1.</strong> Rigid body</a></li><li class="chapter-item expanded "><a href="../../../fyrox/physics/collider.html"><strong aria-hidden="true">2.6.2.</strong> Collider</a></li><li class="chapter-item expanded "><a href="../../../fyrox/physics/joint.html"><strong aria-hidden="true">2.6.3.</strong> Joint (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/resources/resources.html"><strong aria-hidden="true">2.7.</strong> Resource Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/resources/model.html"><strong aria-hidden="true">2.7.1.</strong> 3D Models</a></li><li class="chapter-item expanded "><a href="../../../fyrox/resources/texture.html"><strong aria-hidden="true">2.7.2.</strong> Textures</a></li><li class="chapter-item expanded "><a href="../../../fyrox/resources/sound.html"><strong aria-hidden="true">2.7.3.</strong> Sound Buffers</a></li><li class="chapter-item expanded "><a href="../../../fyrox/resources/curve.html"><strong aria-hidden="true">2.7.4.</strong> Curves</a></li><li class="chapter-item expanded "><a href="../../../fyrox/resources/absm.html"><strong aria-hidden="true">2.7.5.</strong> Animation Machines</a></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/ui.html"><strong aria-hidden="true">2.8.</strong> User Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/ui/basic_concepts/basic_concepts.html"><strong aria-hidden="true">2.8.1.</strong> Basic concepts</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/setting_up.html"><strong aria-hidden="true">2.8.2.</strong> Setting up a user interface</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/general_rules.html"><strong aria-hidden="true">2.8.3.</strong> General rules</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/font.html"><strong aria-hidden="true">2.8.4.</strong> Fonts</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/theme.html"><strong aria-hidden="true">2.8.5.</strong> Theme</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/widgets.html"><strong aria-hidden="true">2.8.6.</strong> Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/ui/button.html"><strong aria-hidden="true">2.8.6.1.</strong> Button</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/border.html"><strong aria-hidden="true">2.8.6.2.</strong> Border</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/canvas.html"><strong aria-hidden="true">2.8.6.3.</strong> Canvas</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/checkbox/check_box.html"><strong aria-hidden="true">2.8.6.4.</strong> Check box</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/curve_editor.html"><strong aria-hidden="true">2.8.6.5.</strong> Curve editor (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/decorator.html"><strong aria-hidden="true">2.8.6.6.</strong> Decorator (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/dock.html"><strong aria-hidden="true">2.8.6.7.</strong> Docking manager (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/dropdown_list.html"><strong aria-hidden="true">2.8.6.8.</strong> Dropdown list (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/expander.html"><strong aria-hidden="true">2.8.6.9.</strong> Expander (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/file_browser.html"><strong aria-hidden="true">2.8.6.10.</strong> File browser (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/grid.html"><strong aria-hidden="true">2.8.6.11.</strong> Grid</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/image.html"><strong aria-hidden="true">2.8.6.12.</strong> Image</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/inspector.html"><strong aria-hidden="true">2.8.6.13.</strong> Inspector (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/list_view.html"><strong aria-hidden="true">2.8.6.14.</strong> List view (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/menu.html"><strong aria-hidden="true">2.8.6.15.</strong> Menu (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/message_box.html"><strong aria-hidden="true">2.8.6.16.</strong> Message box (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/numeric.html"><strong aria-hidden="true">2.8.6.17.</strong> Numeric field (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/popup.html"><strong aria-hidden="true">2.8.6.18.</strong> Popup (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/progress_bar.html"><strong aria-hidden="true">2.8.6.19.</strong> Progress bar (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/range.html"><strong aria-hidden="true">2.8.6.20.</strong> Range (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/rect.html"><strong aria-hidden="true">2.8.6.21.</strong> Rect (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/scroll_bar.html"><strong aria-hidden="true">2.8.6.22.</strong> Scroll bar (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/scroll_panel.html"><strong aria-hidden="true">2.8.6.23.</strong> Scroll panel (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/scroll_viewer.html"><strong aria-hidden="true">2.8.6.24.</strong> Scroll viewer (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/stack_panel.html"><strong aria-hidden="true">2.8.6.25.</strong> Stack panel</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/tab_control.html"><strong aria-hidden="true">2.8.6.26.</strong> Tab Control</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/text.html"><strong aria-hidden="true">2.8.6.27.</strong> Text</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/text_box.html"><strong aria-hidden="true">2.8.6.28.</strong> Text box</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/tree.html"><strong aria-hidden="true">2.8.6.29.</strong> Tree (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/vector_image.html"><strong aria-hidden="true">2.8.6.30.</strong> Vector image (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/window.html"><strong aria-hidden="true">2.8.6.31.</strong> Window</a></li><li class="chapter-item expanded "><a href="../../../fyrox/ui/wrap_panel.html"><strong aria-hidden="true">2.8.6.32.</strong> Wrap panel</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/serialization/serialization.html"><strong aria-hidden="true">2.9.</strong> Serialization (WIP)</a></li><li class="chapter-item expanded "><a href="../../../fyrox/tutorials/tutorials.html"><strong aria-hidden="true">2.10.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/tutorials/fps/intro.html"><strong aria-hidden="true">2.10.1.</strong> FPS Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.10.1.1.</strong> Character controller</a></li><li class="chapter-item expanded "><a href="../../../fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html"><strong aria-hidden="true">2.10.1.2.</strong> Weapons</a></li><li class="chapter-item expanded "><a href="../../../fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html"><strong aria-hidden="true">2.10.1.3.</strong> Bots and AI</a></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/tutorials/rpg/intro.html"><strong aria-hidden="true">2.10.2.</strong> RPG Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.10.2.1.</strong> Character controller</a></li></ol></li><li class="chapter-item expanded "><a href="../../../fyrox/tutorials/platformer/part1.html" class="active"><strong aria-hidden="true">2.10.3.</strong> 2D Platformer tutorial</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="2d-platformer-tutorial"><a class="header" href="#2d-platformer-tutorial">2D Platformer Tutorial</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#2d-platformer-tutorial">2D Platformer Tutorial</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#project">Project</a></li>
<li><a href="#using-the-editor">Using the Editor</a></li>
<li><a href="#scripts---player">Scripts - Player</a></li>
<li><a href="#animation">Animation</a></li>
<li><a href="#final-steps">Final Steps</a></li>
<li><a href="#standalone-game">Standalone Game</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In this tutorial, we'll make a 2D platformer using the new plugin and scripting system that has become available in Fyrox 0.25 and
improved in Fyrox 0.26. Here's what you'll get after finishing the tutorial:</p>
<iframe width="560" height="315" src="https://youtube.com/embed/EcvtwEkBxNU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>You can find the source code of the tutorial <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/platformer">here</a>, you can
test it yourself by cloning the repository and <code>cargo run --package editor --release</code> in the <code>platformer</code> directory.</p>
<h2 id="project"><a class="header" href="#project">Project</a></h2>
<p>Let's start by making a new project using the special tiny tool - <code>fyrox-template</code> - it allows you to generate all boilerplate
parts in a single call. Install it using the following command:</p>
<pre><code class="language-shell">cargo install fyrox-template
</code></pre>
<p>Navigate to a folder where you want the project to be created and do the following command:</p>
<pre><code class="language-shell">fyrox-template --name platformer
</code></pre>
<p>The tool accepts only one argument - project name (it could be extended in the future). After the project is generated, you
should memorize two commands:</p>
<ul>
<li><code>cargo run --package editor --release</code> - launches the editor with your game attached, the editor allows you to run your game
inside it and edit game entities. It is intended to be used only for development.</li>
<li><code>cargo run --package executor --release</code> - creates and runs the production binary of your game that can be shipped (for
example - to a store).</li>
</ul>
<p>Navigate to the <code>platformer</code> directory and run <code>cargo run --package editor --release</code>, after some time you should see the editor:</p>
<p><img src="editor.png" alt="editor" /></p>
<p>Great! Now we can start making our game. Go to <code>game/src/lib.rs</code> - it is where your game logic is located, as you can see
the <code>fyrox-template</code> generate quite some code for you. There are tiny comments about which place is for what. For more info
about each method, please refer <a href="https://docs.rs/fyrox/0.26.0/fyrox/plugin/trait.Plugin.html">to the docs</a>.</p>
<h2 id="using-the-editor"><a class="header" href="#using-the-editor">Using the Editor</a></h2>
<p>For now, we don't even need to write a single line of code, we can create a scene entirely in the editor. This section will guide
you through the process of scene creation, as a final result we'll get something similar to this:</p>
<p><img src="editor_with_scene.png" alt="editor with scene" /></p>
<p>At first, we need some assets, I prepared all required (and some more) in a separate zip archive, so you don't need to search
assets all over the internet. Download assets from <a href="assets.zip">here</a> and unpack them in a <code>data</code> folder in the root folder of
your project.</p>
<p>Let's start by creating a new scene. Run the editor and go to <code>File -&gt; New Scene</code>. Since we're making a 2D game, switch the editor
camera mode to <code>Orthographic</code> at the right top corner of the scene preview window. Now we need to populate the scene with some objects,
we'll start by adding a simple ground block. Right-click on <code>__ROOT__</code> of the scene in <code>World Viewer</code> and select
<code>Add Child -&gt; Physics2D -&gt; Rigid Body</code>. This will create a rigid body for the ground block, select the rigid body, and
set <code>Body Type</code> to <code>Static</code> in <code>Inspector</code>, by doing this we're telling the physics engine that our ground block should not move
and be rock-solid.
Every rigid body requires a collider, otherwise, the physics engine will not know how to handle collisions, right-click on the rigid body in <code>Inspector</code> and click <code>Add Child -&gt; Physics2D -&gt; Collider</code>. We've just added a new collider to the rigid
body, by default it has a <code>Cuboid</code> shape with a <code>1.0</code> meter in height and width. Finally, we need to add some graphics to the rigid body,
right-click on the rigid body and click <code>Add Child -&gt; 2D -&gt; Rectangle</code>. This adds a simple 2D sprite, select it and set a texture
to it by drag'n'dropping it from the asset browser on the white field of the <code>Texture</code> field in the <code>Inspector</code>. For my scene, I'm gonna
be using three sprites.</p>
<ul>
<li><code>data/tiles/13.png</code> - left ground block</li>
<li><code>data/tiles/14.png</code> - center ground block</li>
<li><code>data/tiles/15.png</code> - right ground block</li>
</ul>
<p>You can use any other textures and build your level as you like. After doing all these steps you should get something like this:</p>
<p><img src="editor_step1.png" alt="editor_step1" /></p>
<p>Clone the block by selecting its rigid body and pressing <code>Ctrl+C</code> followed by <code>Ctrl+V</code>, navigate to sprite in the copy and change its
texture to either the left or right end of the block. Use <code>Move Tool</code> to move the block somewhere you like (you can also use grid-snapping
by going to <code>File -&gt; Setting</code> and setting <code>Snap To Grid</code> for <code>Move Interaction Mode</code>). Do this one more time for the opposite end and you
should get something like this:</p>
<p><img src="editor_step2.png" alt="editor_step2" /></p>
<p>Repeat these steps if you like, to add more platforms. You can also add some background objects, by creating a new sprite
(right click <code>__ROOT__</code> and click <code>Add Child -&gt; 2D -&gt; Rectangle</code>) and assigning a texture to it:</p>
<p><img src="editor_step3.png" alt="editor_step3" /></p>
<p>As the last step of world editing, let's add some dynamic objects, like boxes. Pick some random ground block, select its rigid body, and
clone it. Switch body type of the copy to <code>Dynamic</code>. Now change its sprite texture to a box (drag'n'drop <code>data/objects/Crate.png</code> to
<code>Texture</code> field) and clone the box a few times, you should get something like this:</p>
<p><img src="editor_step4.png" alt="editor_step4" /></p>
<p>Now for the player. As always, let's start by creating a new rigid body, adding a 2D collider to it, and setting its shape to capsule with the following
parameters - <code>Begin = 0.0, 0.0</code> and <code>End = 0.0, 0.3</code>. Add a 2D sprite (rectangle) to the rigid body and set its texture to a texture from
<code>data/characters/adventurer/Individual Sprites</code>. We also need a camera, otherwise, we won't see anything. Add it as a child to a player's
rigid body. By default our camera will have no background, there'll be a black &quot;void&quot;, this is not great and let's fix that. Select the camera
and set the <code>Skybox</code> property to <code>Some</code>. Now go to asset browser and find <code>data/background/BG.png</code>, drag'n'drop it to the <code>Front</code> field of the
<code>Skybox</code> property. Don't forget to adjust the far plane distance to something like <code>20.0</code>, otherwise, you'll see just a portion of the background image.
If everything is done correctly, you should get something like this:</p>
<p><img src="editor_step5.png" alt="editor_step5" /></p>
<p>Save your scene to <code>data/scene.rgs</code> - go to <code>File -&gt; Save Scene</code>, select <code>data</code> folder in the tree and set filename to <code>scene.rgs</code>. Now we can
run the game using the <code>Play/Stop</code> button at the top of the scene previewer. You should see pretty much the same as in the scene preview, except
for service graphics, such as rigid body shapes, node bounds, and so on. Now we can start writing scripts, but at first, let's make our life easier
and force the editor to load the scene for us on startup. Go to <code>editor/src/main.rs</code> and replace this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Some(StartupData {
    working_directory: Default::default(),
    // Set this to `&quot;path/to/your/scene.rgs&quot;.into()` to force the editor to load the scene on startup.
    scene: Default::default(),
})
<span class="boring">}
</span></code></pre></pre>
<p>with this</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Some(StartupData {
    working_directory: Default::default(),
    scene: &quot;data/scene.rgs&quot;.into(),
})
<span class="boring">}
</span></code></pre></pre>
<p>Now if you re-run the editor, it will automatically load the requested scene, this saves some extra clicks and only a few seconds,
but if you multiply that by a number of restarts, this will give you a decent time save.</p>
<p>As the last preparation step, let's import all entities at the beginning, so you don't need to find them manually, add the following code
at the beginning of the <code>game/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{
        algebra::{Vector2, Vector3},
        futures::executor::block_on,
        inspect::{Inspect, PropertyInfo},
        pool::Handle,
        uuid::{uuid, Uuid},
        visitor::prelude::*,
    },
    engine::resource_manager::ResourceManager,
    event::{ElementState, Event, VirtualKeyCode, WindowEvent},
    gui::inspector::{CollectionChanged, FieldKind, PropertyChanged},
    handle_collection_property_changed, handle_object_property_changed,
    plugin::{Plugin, PluginContext, PluginRegistrationContext},
    resource::texture::Texture,
    scene::{
        camera::Camera,
        dim2::{rectangle::Rectangle, rigidbody::RigidBody},
        node::{Node, TypeUuidProvider},
        Scene, SceneLoader,
    },
    script::{ScriptContext, ScriptTrait},
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="scripts---player"><a class="header" href="#scripts---player">Scripts - Player</a></h2>
<p>Our scene has pretty much everything we need to start adding scripts, we'll start from the <code>Player</code> script and make our character
move. Navigate to <code>game/src/lib.rs</code> and at the end of the file add the following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        inspect::{Inspect, PropertyInfo},
</span><span class="boring">        uuid::{uuid, Uuid},
</span><span class="boring">        visitor::prelude::*,
</span><span class="boring">    },
</span><span class="boring">    event::Event,
</span><span class="boring">    gui::inspector::PropertyChanged,
</span><span class="boring">    scene::node::TypeUuidProvider,
</span><span class="boring">    script::{ScriptContext, ScriptTrait},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct Game;
</span><span class="boring">
</span><span class="boring">impl Game {
</span><span class="boring">    fn type_uuid() -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Visit, Inspect, Debug, Clone, Default)]
struct Player;

impl TypeUuidProvider for Player {
    // Returns unique script id for serialization needs.
    fn type_uuid() -&gt; Uuid {
        uuid!(&quot;c5671d19-9f1a-4286-8486-add4ebaadaec&quot;)
    }
}

impl ScriptTrait for Player {
    // Accepts events from Inspector in the editor and modifies self state accordingly.
    fn on_property_changed(&amp;mut self, args: &amp;PropertyChanged) -&gt; bool {
        false
    }

    // Called once at initialization.
    fn on_init(&amp;mut self, context: ScriptContext) {}

    // Called whenever there is an event from OS (mouse click, keypress, etc.)
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: ScriptContext) {}

    // Called every frame at fixed rate of 60 FPS.
    fn on_update(&amp;mut self, context: ScriptContext) {}

    // Returns unique script ID for serialization needs.
    fn id(&amp;self) -&gt; Uuid {
        Self::type_uuid()
    }

    // Returns unique id of parent plugin.
    fn plugin_uuid(&amp;self) -&gt; Uuid {
        Game::type_uuid()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a typical &quot;skeleton&quot; of any script, for now, its methods are pretty much empty, we'll fill it with actual code very soon.
Let's go over the most important parts. The snippet starts from the <code>Player</code> structure definition which has <code>#[derive(Visit, Inspect, Debug, Clone, Default)]</code>
attributes:</p>
<ul>
<li><code>Visit</code> implements serialization/deserialization functionality, it is used by the editor to save your object to a scene file.</li>
<li><code>Inspect</code> implements read-only static reflection that provides introspection for your type - in other words, it allows the editor
to &quot;see&quot; what's inside your structure.</li>
<li><code>Debug</code> - provides debugging functionality, it is mostly for the editor to let it print stuff into the console.</li>
<li><code>Clone</code> - makes your structure clone-able, why do we need this? We can clone objects and we also want the script instance to be
copied.</li>
<li><code>Default</code> implementation is very important - the scripting system uses it to create your scripts in the default state.
This is necessary to set some data to it and so on. If it's a special case, you can always implement your own <code>Default</code>'s
implementation if it's necessary for your script.</li>
<li><code>TypeUuidProvider</code> is used to attach some unique id for your type, every script *<em>must</em> have a unique ID, otherwise, the engine will
not be able to save and load your scripts. To generate a new UUID, use <a href="https://www.uuidgenerator.net/">Online UUID Generator</a> or
any other tool that can generate UUIDs.</li>
</ul>
<p>Finally, we implement <code>ScriptTrait</code> for the <code>Player</code>. It has a bunch of methods, their names speak for themselves. Learn more about
every method in <a href="https://docs.rs/fyrox/0.26.0/fyrox/script/trait.ScriptTrait.html">documentation</a></p>
<p>Before we can use the script in the editor, we must tell the engine that our script exists - we must register it. Remember that
<code>on_register</code> method in the <code>Plugin</code> trait implementation? It is exactly for script registration, replace its implementation with the following
code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_register(&amp;mut self, context: PluginRegistrationContext) {
    let script_constructors = &amp;context.serialization_context.script_constructors;
    script_constructors.add::&lt;Game, Player, _&gt;(&quot;Player&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Now the engine knows about our script and will be able to use it. It is pretty much useless in the current state, but we can already
assign it to the player. Select the player's rigid body node and find <code>Script</code> in the <code>Inspector</code>, select <code>Player</code> from the respective
drop-down list and that's pretty much it - now the script is assigned:</p>
<p><img src="script_selection.png" alt="script_selection" /></p>
<p>Let's learn how to edit script properties from the editor. In the next section, we'll be adding keyframe animation for your character,
it is a perfect opportunity to learn how the engine and the editor operate with user-defined properties in scripts. To animate the player
we need to get its sprite first. Let's start by adding the required field in the <code>Player</code> structure:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Inspect, Debug, Clone, Default)]
struct Player {
    sprite: Handle&lt;Node&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>After adding this, the editor will be able to see the field and give you the ability to edit it in the Inspector, but for now, any
changes done in Inspector will not be applied to the script instance. We need to take care of this, it is a bit of manual work,
future versions of the engine will most likely do this automatically. We're interested in the <code>on_property_changed</code> method, fill it
the following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>handle_object_property_changed!(self, args, Self::SPRITE =&gt; sprite)
<span class="boring">}
</span></code></pre></pre>
<p>This single line of code applies changes to the <code>sprite</code> field if in the editor it's &quot;view&quot; was edited. The macro hides most of boilerplate
code from you, when a macro is expanded the result code would look like:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let FieldKind::Object(ref value) = args.value {
    match args.name.as_ref() {
        Self::SPRITE =&gt; {
            self.sprite = value.cast_clone().unwrap();
            true
        }
        _ =&gt; false,
    }
} else {
    false
}
<span class="boring">}
</span></code></pre></pre>
<p>It is good to know what it is doing, before using macros. At first, the code checks value kind, if it is a simple object, then we're
checking the name of the property, and if it is our <code>sprite</code>, setting the value. The method expects <code>true</code> or <code>false</code> as a return value,
what does each mean? <code>true</code> means that the property was handled, and <code>false</code> - the opposite. If the editor sees <code>false</code> it prints a warning
message informing you that the property handler is missing.</p>
<p>To assign the correct handle of the sprite to the respective field in script properties, hold <code>Alt</code> and start dragging the sprite node from
the world viewer to the respective field in the player script. Release the mouse button and if everything is ok, the field should &quot;say&quot;
something different than &quot;Unassigned&quot;.</p>
<p>Alright, at this point we know how to work with script properties, now we can start adding basic movement for the player.
Go to the <code>Player</code> structure and add the following fields:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>move_left: bool,
move_right: bool,
jump: bool,
<span class="boring">}
</span></code></pre></pre>
<p>These fields will store the state of keyboard keys responsible for player movement. Now for <code>on_os_event</code>, add the following code there:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Event::WindowEvent { event, .. } = event {
    if let WindowEvent::KeyboardInput { input, .. } = event {
        if let Some(keycode) = input.virtual_keycode {
            let is_pressed = input.state == ElementState::Pressed;

            match keycode {
                VirtualKeyCode::A =&gt; self.move_left = is_pressed,
                VirtualKeyCode::D =&gt; self.move_right = is_pressed,
                VirtualKeyCode::Space =&gt; self.jump = is_pressed,
                _ =&gt; (),
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code responds to OS events and modifies internal movement flags accordingly. Now we need to use the flags somehow, it's time for
<code>on_update</code>. The method is called each frame and allows you to put game logic there:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Called every frame at fixed rate of 60 FPS.
fn on_update(&amp;mut self, context: ScriptContext) {
    // The script can be assigned to any scene node, but we assert that it will work only with
    // 2d rigid body nodes.
    if let Some(rigid_body) = context.node.cast_mut::&lt;RigidBody&gt;() {
        let x_speed = match (self.move_left, self.move_right) {
            (true, false) =&gt; 3.0,
            (false, true) -&gt; -3.0,
            _ =&gt; 0.0,
        };

        if self.jump {
            rigid_body.set_lin_vel(Vector2::new(x_speed, 4.0));
        } else {
            rigid_body.set_lin_vel(Vector2::new(x_speed, rigid_body.lin_vel().y));
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, some interesting code. At first, we check if the node to which the script is assigned is a 2d rigid body, next
we're checking movement flags and form horizontal speed, and applying velocity to the body. Velocity is applied in two ways: if
the jump button was pressed - apply horizontal velocity and some vertical velocity for jumping. If the jump button wasn't pressed -
just change horizontal velocity - this will allow the player to free fall.</p>
<p>Run the editor and enter play mode, press <code>[A][D][Space]</code> buttons to check if everything works correctly - the player should move
horizontally and be able to jump. You can jump to the boxes on the right and push them off the ledge.</p>
<p>The movement is working, but the player does not change orientation, if we'll go to the left - it looks ok (despite the lack of animation),
but if we'll move to the right - it looks like the player moves backward. Let's fix that by changing the horizontal scaling of the player's
sprite. Add the following code at the end of the <code>if let ...</code> block of the code above:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It is always a good practice to check whether the handles are valid, at this point we don't know
// for sure what's the value of the `sprite` field. It can be unassigned and the following code won't
// execute. A simple `context.scene.graph[self.sprite]` would just panicked in this case.
if let Some(sprite) = context.scene.graph.try_get_mut(self.sprite) {
    // We want to change player orientation only if he's moving.
    if x_speed != 0.0 {
        let local_transform = sprite.local_transform_mut();
        let current_scale = **local_transform.scale();

        local_transform.set_scale(Vector3::new(
            // Just change X scaling to mirror player's sprite.
            current_scale.x.copysign(-x_speed),
            current_scale.y,
            current_scale.z,
        ));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The comments should clarify what's going on here, but in short, we're changing the horizontal scaling of the player's sprite if the player is
moving. The line <code>current_scale.x.copysign(-x_speed)</code> could be confusing, what it does? It replaces the sign of current horizontal scaling
using the opposite sign of <code>x_speed</code>.</p>
<p>Now if you run the game, the player will &quot;look&quot; in correct direction depending on the velocity vector.</p>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<p>Since we're making a 2D game, we'll be using simple animations based on the continuous change of keyframes. In other words, we'll be changing
the texture of the player's body sprite. The engine does not provide such functionality yet, simply because it was focused primarily on 3D games
for quite a long period. It is easy to make such an animation &quot;system&quot; ourselves.</p>
<p>Put this code snippet somewhere at the end of <code>lib.rs</code> of the <code>game</code> project and we'll start learning what it's doing:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Inspect, Visit, Debug, Clone)]
pub struct KeyFrameTexture {
    texture: Option&lt;Texture&gt;,
}

impl KeyFrameTexture {
    fn on_property_changed(&amp;mut self, args: &amp;PropertyChanged) -&gt; bool {
        handle_object_property_changed!(self, args, Self::TEXTURE =&gt; texture)
    }

    fn restore_resources(&amp;mut self, resource_manager: ResourceManager) {
        // It is very important to restore texture handle after loading, otherwise the handle will
        // remain in &quot;shallow&quot; state when it just has path to data, but not the actual resource handle.
        resource_manager
            .state()
            .containers_mut()
            .textures
            .try_restore_optional_resource(&amp;mut self.texture);
    }
}

#[derive(Inspect, Visit, Debug, Clone)]
pub struct Animation {
    name: String,
    keyframes: Vec&lt;KeyFrameTexture&gt;,
    current_frame: u32,
    speed: f32,

    // We don't want this field to be visible from the editor, because this is internal parameter.
    #[inspect(skip)]
    t: f32,
}

impl Default for Animation {
    fn default() -&gt; Self {
        Self {
            name: &quot;Unnamed&quot;.to_string(),
            speed: 10.0,
            ..Default::default()
        }
    }
}

impl Animation {
    // Once again, we must implement support for property editing, it is a bit tedious
    // but must be done once.
    fn on_property_changed(&amp;mut self, args: &amp;PropertyChanged) -&gt; bool {
        handle_object_property_changed!(self, args,
            Self::CURRENT_FRAME =&gt; current_frame,
            Self::NAME =&gt; name,
            Self::SPEED =&gt; speed
        ) || handle_collection_property_changed!(self, args, Self::KEYFRAMES =&gt; keyframes)
    }

    pub fn current_frame(&amp;self) -&gt; Option&lt;&amp;KeyFrameTexture&gt; {
        self.keyframes.get(self.current_frame as usize)
    }

    fn restore_resources(&amp;mut self, resource_manager: ResourceManager) {
        for key_frame in self.keyframes.iter_mut() {
            key_frame.restore_resources(resource_manager.clone());
        }
    }

    pub fn update(&amp;mut self, dt: f32) {
        self.t += self.speed * dt;

        if self.t &gt;= 1.0 {
            self.t = 0.0;

            // Increase frame index and make sure it will be clamped in available bounds.
            self.current_frame = (self.current_frame + 1) % self.keyframes.len() as u32;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippets are quite big, but this is pretty much everything we need for simple keyframe animation.
We start by defining the <code>KeyFrameTexture</code> structure - it is a simple new-type-ish structure that holds a single
field - optional texture handle.</p>
<p>Next goes the implementation of the structure, in the <code>on_property_changed</code> we're handing editor's messages
and syncing the state of the keyframe. The next method is more interesting - <code>restore_resources</code> restores texture
handle on deserialization. Sounds complicated, why do we need to do anything after deserialization? Well,
the answer is simple - we don't store texture data in the texture, instead, we just save the path to an external
resource and request the resource manager to load the texture.</p>
<p>Finally, we're at the <code>Animation</code> structure, nothing unusual there, it just stores a list of keyframes, an index
of a current keyframe, speed, and some service fields. The implementation of it is very straightforward too,
the most interesting method is <code>update</code>. Inside it, we're updating the internal <code>t</code> parameter which holds the &quot;fraction&quot;
of the next frame's index, when it reaches <code>1.0</code> we're increasing the index of the current frame and wrapping it so it
never exceeds the maximum amount of keyframes - instead, it will start counting from 0.</p>
<p>It's time to start using the new animation system, just add the following fields to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">struct Animation;
</span><span class="boring">struct Player {
</span>animations: Vec&lt;Animation&gt;,
current_animation: u32,
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Currently, we just pass default values.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>..Default::default()
<span class="boring">}
</span></code></pre></pre>
<p>The Player will use multiple animations in future tutorials, but for now, it will use only two - idle and run.
Now we need to somehow switch animations. Go to <code>on_update</code> in <code>Player</code> and add the following lines after
the <code>x_speed</code> declaration:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Player {
</span><span class="boring">    current_animation: usize,
</span><span class="boring">}
</span><span class="boring">impl Player {
</span><span class="boring">    pub fn on_update(&amp;mut self) {
</span><span class="boring">      let x_speed = 0.0;
</span>if x_speed != 0.0 {
    self.current_animation = 0;
} else {
    self.current_animation = 1;
}
<span class="boring">   }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Here we assume that the run animation will be at index <code>0</code> and the idle animation at index <code>1</code>. We also need to
apply the texture from the current animation to the player's sprite, and add the following lines at the end of <code>on_update</code></p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(current_animation) = self.animations.get_mut(self.current_animation as usize) {
    current_animation.update(context.dt);

    if let Some(sprite) = context
        .scene
        .graph
        .try_get_mut(self.sprite)
        .and_then(|n| n.cast_mut::&lt;Rectangle&gt;())
    {
        // Set new frame to the sprite.
        sprite.set_texture(
            current_animation
                .current_frame()
                .and_then(|k| k.texture.clone()),
        )
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code is pretty straightforward - we start by trying to get a reference to the current animation by its index,
and if we're succeeded, we update it. At the next step, we're getting sprite and assigning a current frame of
the current animation. Experienced game developers could immediately ask - why not use sprite sheets and get
better performance and stuff. Well, the main purpose of this tutorial is to teach how to use the engine to
achieve some goal, such as <em>making a game</em>. You can always optimize your game later when you'll have something
working and playable.</p>
<h2 id="final-steps"><a class="header" href="#final-steps">Final Steps</a></h2>
<p>Three more steps before we can run the game, we need to call <code>restore_resources</code> for each animation. To do that,
the script trait has the <code>on_restore_resources</code> method, add the following code to <code>impl ScriptTrait for Player</code></p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn restore_resources(&amp;mut self, resource_manager: ResourceManager) {
    for animation in self.animations.iter_mut() {
        animation.restore_resources(resource_manager.clone());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As a second step, replace the contents of the <code>editor/src/main.rs</code> with the following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">//! Editor with your game connected to it as a plugin.
use fyrox::gui::inspector::editors::collection::VecCollectionPropertyEditorDefinition;
use fyrox::{
    event_loop::EventLoop,
    gui::inspector::editors::inspectable::InspectablePropertyEditorDefinition,
};
use fyroxed_base::{Editor, StartupData};
use platformer::{Animation, Game, KeyFrameTexture};

fn main() {
    let event_loop = EventLoop::new();
    let mut editor = Editor::new(
        &amp;event_loop,
        Some(StartupData {
            working_directory: Default::default(),
            scene: &quot;data/scene.rgs&quot;.into(),
        }),
    );
    editor.add_game_plugin(Game::new());

    // Register property editors here.
    let property_editors = &amp;editor.inspector.property_editors;
    property_editors.insert(InspectablePropertyEditorDefinition::&lt;KeyFrameTexture&gt;::new());
    property_editors.insert(InspectablePropertyEditorDefinition::&lt;Animation&gt;::new());
    property_editors.insert(VecCollectionPropertyEditorDefinition::&lt;KeyFrameTexture&gt;::new());
    property_editors.insert(VecCollectionPropertyEditorDefinition::&lt;Animation&gt;::new());

    editor.run(event_loop)
}
</code></pre></pre>
<p>The most interesting code here is this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Register property editors here.
let property_editors = &amp;editor.inspector.property_editors;
property_editors.insert(InspectablePropertyEditorDefinition::&lt;KeyFrameTexture&gt;::new());
property_editors.insert(InspectablePropertyEditorDefinition::&lt;Animation&gt;::new());
property_editors.insert(VecCollectionPropertyEditorDefinition::&lt;KeyFrameTexture&gt;::new());
property_editors.insert(VecCollectionPropertyEditorDefinition::&lt;Animation&gt;::new());
<span class="boring">}
</span></code></pre></pre>
<p>Here we're registering <em>property editors</em> for our game types. This very important step, tells the editor how to
visualize your data. In most cases, you'll be using those two generic types - <code>InspectablePropertyEditorDefinition</code>
and <code>VecCollectionPropertyEditorDefinition</code>. Which is responsible for what?</p>
<ul>
<li><code>InspectablePropertyEditorDefinition</code> - is responsible for showing properties of any object that implements
<code>Inspect</code> trait. All of your game entities must implement such traits.</li>
<li><code>VecCollectionPropertyEditorDefinition</code> - it is responsible for showing <code>Vec&lt;T: Inspect&gt;</code> collection, every
collection item <strong>must</strong> implement <code>Inspect</code> trait. This is a bit tedious, especially in the case of simple collections
like <code>Vec&lt;f32&gt;</code>, but that's a limitation of the current implementation. It can be mitigated by using a new-type technique,
which was shown earlier.</li>
</ul>
<p>This is yet another place for manual work, but it must be done, the editor cannot use &quot;magic&quot; to understand which widget
to use to visualize your data, there's no magic here.</p>
<p>And a final step is to change how the script properties are handled:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_property_changed(&amp;mut self, args: &amp;PropertyChanged) -&gt; bool {
    handle_object_property_changed!(self, args, Self::SPRITE =&gt; sprite)
        // The following line handles collection modification.
        || handle_collection_property_changed!(self, args, Self::ANIMATIONS =&gt; animations)
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to go to the editor again and add the animations to the <code>Player</code>, select the player's rigid body, and
find the <code>Script</code> section in the <code>Inspector</code>. Add two animations there like so:</p>
<p><img src="editor_step6.png" alt="editor_step6" /></p>
<h2 id="standalone-game"><a class="header" href="#standalone-game">Standalone Game</a></h2>
<p>As a final step, we'll add proper support for standalone mode (&quot;production builds&quot;), let's replace <code>on_standalone_init</code>
with the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_standalone_init(&amp;mut self, context: PluginContext) {
    let mut scene = block_on(
        block_on(SceneLoader::from_file(
            &quot;data/scene.rgs&quot;,
            context.serialization_context.clone(),
        ))
        .unwrap()
        .finish(context.resource_manager.clone()),
    );

    self.set_scene(context.scenes.add(scene), context);
}
<span class="boring">}
</span></code></pre></pre>
<p>The code just loads our scene and sets it as current, we need to do this manually when the game runs in standalone mode
(without editor), because the editor does some work for us when we run the game inside it.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial, we've learned the basics of the new scripting system of the engine that was added in Fyrox 0.25. The game
we've built it very simple, but it is just the beginning.
It is easy to add more scripts for enemies, weapons, collectible items, and so on.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
